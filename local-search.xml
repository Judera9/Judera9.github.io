<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>光流估计目标追踪-简单的KLT Feature Tracker</title>
    <link href="/2022/06/13/2022-06-13-KLT-naive-version/"/>
    <url>/2022/06/13/2022-06-13-KLT-naive-version/</url>
    
    <content type="html"><![CDATA[<p>  这是大三下学期在数字图像处理（DIP）课程最后几周做的项目（其实最后就只花了一两天肝的）。项目是一个400多行代码手捏的使用光流估计的目标追踪，主要部分包括Harris角点检测和LK光流估计。</p><span id="more"></span><p>  下面是最后一天做的一个小视频，看起来效果还不错。不过我在最后写报告的时候发现有几个比较大的bug，很神奇。这让我认识到，即使是充满bug的代码，也能跑的不错嘛（大雾。后续的改进方案是通过卡尔曼滤波和图像金字塔，不过我目前没打算去实现，以后再说吧。以后想用这个光流的方法做一下SLAM试试，感觉还挺可能的呢。暑假打算继续在CV和DIP的坑里摸爬滚打一下，啃几本书和大项目代码，到时会继续更新博客。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=299480056&bvid=BV1WF41157CX&cid=729840410&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe><h2 id="introduction">Introduction</h2><p>Object tracking is an interesting and effective technology in Digital Image Processing (DIP) and Computer Vision (CV). It should be noted that object tracking is different from object detection, though they might share some similarities. In short, object detection uses a static image and globally searches the objects that we are interested in, while object tracking handles the motion information in a video stream to track the moving objects. The latter is much more efficient than the first one, so in an industrial visual task we often first detect the objects and then use certain methods to track them rather than constantly detect them.</p><p>Lucas-Kanade (LK) method is a widely used differential method for optical flow estimation. It is based on the least square estimation (LSE) strategy on a local neighborhood of pixels. The classical Kanade Lucas Tomasi (KLT) feature tracker algorism which I implemented in this project is based on the LK optical flow estimation, utilizing the feature points extracted by the Harris Corner method.</p><p>The result could be seen in <a href="https://www.bilibili.com/video/BV1WF41157CX/?vd_source=45dbbabddf51fc5827a0fed713c90afd">this video link</a> (recommend to watch it!), which is made and uploaded by myself. I do not compare the result with other mature algorisms in strict norms, because I do not implement it in C++ or other high-efficiency languages. But I could give some intuitive and elemental conclusions.</p><p>First, the KLT algorism I implemented is fast. Compared with the algorisms listed in Table 1 below, my method is over the average for the FPS index. I use Numba to compile python functions into C++ execution function variables, and I could handle a video stream of 30 fps with my simple 400 lines of codes. Second, the tracking effect is desirable when the motions of target objects are small, though still, we need a re-detection when all the feature points are lost. Third, some of the methods listed in Table 1 more or less refer to the basics of the KLT algorism. For example, the TLD method adds a classifier beyond the KLT feature tracker to stabilize the tracking result. In a nutshell, the KLT feature tracker I implemented is very simple and there are many improved ways, but it has already shown a promising effect.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220613003037779.png" alt="Table 1" style="zoom: 67%;" /></p><center>Table 1: Other traditional object tracking algorisms</center><h2 id="summary">Summary</h2><p>The object tracking methods would be concluded in two classes:</p><ol type="1"><li>Traditional ways: These methods are usually based on feature extraction and filtering searching algorisms. For the feature extraction task, there are global and local features, histogram, PCA, template, binary pattern, Sparse representation, generative model, and so on. For searching strategies, there are particle filter, Markov chain Monte Carlo method, local optimum search, and so on. The KLT filter could be concluded in this class, but I utilize the motion information between frames to track corner point features, without using a complicated searching strategy.</li><li>Deep Learning ways: Mostly are some tracking-by-detection methods, like the famous YOLO, SSD, and so on. Besides, some methods combine the traditional filtering algorisms with Neural networks. There are also some generative methods like Siamese Networks, which are also based on feature matching.</li></ol><p>Because we are prohibited from using some Deep Learning methods, I try a traditional one. The reason I want to implement KLT is that I am very interested in optical flow technology, so I want to try one related to it. Besides, after reading some papers and blogs about the methods listed in Table 1, I could only find the KLT feature tracker practicable to implement all by myself in these few weeks, and it looks good enough for displaying a final exhibition.</p><h2 id="methods">Methods</h2><p>I do not use any other third-party libraries for the main body of my codes. I only use OpenCV to read the video stream and convert them to grayscale images. The other algorisms are all implemented by myself in python, accelerated by Numba. The whole process and the methods I use could be seen in the following Fig 1.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/KLT pre ver4.jpg" alt="KLT pre ver4" style="zoom:33%;" /></p><center>Fig 1: the process of the KLT feature tracker I implemented</center><h3 id="image-registration-problem1">Image Registration Problem<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Bruce D. Lucas and Takeo Kanade. An Iterative Image Registration Technique with an Application to Stereo Vision. International Joint Conference on Artificial Intelligence, pages 674–679, 1981.">[1]</span></a></sup></h3><p>The image registration problem could be presented below. Given functions <span class="math inline">\(F(x,y)\)</span> and <span class="math inline">\(G(x,y)\)</span>, which represent the pixel values of two images, we wish to find the disparity vector <span class="math inline">\((h_x,h_y)\)</span> that minimizes the difference between <span class="math inline">\(F(x+h_x, y+h_y)\)</span> and <span class="math inline">\(G(x,y)\)</span>, for <span class="math inline">\((x,y)\)</span> in some region of interest (ROI) <span class="math inline">\(R\)</span>. The way to judge the registration effect has many methods, like using L1 norm, L2 norm and negative of normalized correlation. For example: <span class="math display">\[\begin{aligned}\mbox{L1 norm: }&amp; \sum_{x \in R}{|F(x+h_x, y+h_y)-G(x,y)|}\\\mbox{L2 norm: }&amp; \sqrt{\sum_{x \in R}{[F(x+h_x, y+h_y)-G(x,y)]^2}}\\\end{aligned}\]</span></p><h3 id="harris-corner-detector2">Harris Corner Detector<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Jianbo Shi and Carlo Tomasi. Good Features to Track. IEEE Conference on Computer Vision and Pattern Recognition, pages 593–600, 1994.">[2]</span></a></sup></h3><p>Intuitively, we want to track some features that could be constantly detected and identified, thus how to find these kinds of points of interest is tricky. There are many feature detection strategies in Computer Vision, like the Sobel edge detection method we learned in class. In the KLT algorithm, we apply the Harris corner detection method to extract features from an image. Corners are important features in an image, they are generally termed as interest points that are invariant to translation, rotation, and illumination.</p><p>Assume the pixel values of a grayscale 2-D image is given as <span class="math inline">\(I\)</span>. Consider shifting an image patch <span class="math inline">\(R\)</span> with <span class="math inline">\((h_x,h_y)\)</span>. The weighted <em>sum of squared differences (SSD)</em>, denoted as <span class="math inline">\(S\)</span>, is given by the below equation (<span class="math inline">\(S\)</span> is the square of the difference). <span class="math display">\[\begin{aligned}S(x,y)&amp;=\sum_{(x,y)\in R}[I(x+h_x,y+h_y)-I(u,v)]^2\\I(x+h_x,y+h_y)&amp;=I(x,y)+I_xh_x+I_yh_y\\\end{aligned}\]</span> Substitute the Taylor expansion approximation into <span class="math inline">\(S\)</span>, we get the matrix form. Notice that the terms <span class="math inline">\(I_x,I_y\)</span> could be the results of the Sobel operator. The tensor matrix <span class="math inline">\(M\)</span> could be seen as the partial derivative in this neighborhood. We use the properties of <span class="math inline">\(M\)</span> to judge whether this neighborhood contains corner. <span class="math display">\[\begin{aligned}S(x,y)&amp;=\sum_{(x,y)\in R}[I_xh_x+I_yh_y]^2\\&amp;=\begin{bmatrix}h_x &amp; h_y\end{bmatrix}\sum_{(x,y)\in R}\begin{bmatrix}I^2_x &amp; I_xI_y\\ I_xI_y &amp; I^2_y\end{bmatrix}\begin{bmatrix}h_x \\ h_y\end{bmatrix}\\&amp;=\begin{bmatrix}h_x &amp; h_y\end{bmatrix}M\begin{bmatrix}h_x \\ h_y\end{bmatrix}\end{aligned}\]</span> <span class="math inline">\(M\)</span> is a symmetric and positive definite matrix, therefore its eigenvalues <span class="math inline">\(\lambda_1, \lambda_2 &gt; 0\)</span>. The concept is similar to what we learn in Modern Control theory: after diagonalizing <span class="math inline">\(M\)</span>, we want both of the eigenvalues are large, therefore a Harris response calculation <span class="math inline">\(R\)</span> is designed to judge this (the first form is better because it would not encounter invalid calculation). <span class="math display">\[\begin{aligned}R&amp;=\lambda_1\lambda_2-k(\lambda_1+\lambda_2)^2\\&amp;=\det(M)-k\trace(M)\\&amp;k\in [0.04,0.06]\\\mbox{Another form is: }R&amp;=\frac{\lambda_1\lambda_2}{\lambda_1+\lambda_2}\end{aligned}\]</span> Then, we need to find the local maximum (like using a max filter with 5x5) and try to remove some redundant points that overlapping with each other. Through the above process, good tracking features have been found.</p><p>Here is the pseudocode of it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">before passing into the following function: convert &#x27;img&#x27; into grayscale<br><br>def harris_corner_response(Ix, Iy, k=0.0):<br>    &quot;&quot;&quot;<br>    :param arr: input 2d array with size MxN<br>    :param k: 0.0 or [0.4, 0.6]<br>    :return: the harris response matrix (MxN)<br>    &quot;&quot;&quot;<br><br>    IxIy = Ix * Iy<br>    M is the tensor of Ix and Iy<br>    M[:, 0, 0] = Ix ** 2 # left-up side<br>    M[:, 0, 1] = IxIy # right-up side<br>    M[:, 1, 0] = IxIy # left-down side<br>    M[:, 1, 1] = Iy ** 2 # right-down side<br>    M_det is the determinant of M tensor<br>    M_tr is the trace of M tensor<br>    calculate M_det / (M_tr + 0.0001) or M_det - k * M_tr ** 2 as harris response<br><br>def find_harris_corner(img, sigma, tensor_k, suppressed_size, threshold):<br>    &quot;&quot;&quot;<br>    :param img: input a gray-scale image<br>    :param sigma: gaussian filter param, usually about 1 is ok<br>    :param tensor_k: the parameter related to harris corner response, 0.0 for the division form or [0.4, 0.6] for the minus form<br>    :param suppressed_size: do something like max filter to suppress local maximum and avoid tracking the same feature, the recommend is 10-20<br>    :param threshold: the threshold for marking high response points, 0.001 is ok<br>    &quot;&quot;&quot;<br><br>    - use gaussian filter to smoothen the &#x27;img&#x27; and get &#x27;gauss_img&#x27;<br>    - get the gradients &#x27;Ix&#x27;, &#x27;Iy&#x27; by using sobel operator on &#x27;gauss_img&#x27;<br>    - calculate the harris response of &#x27;gauss_img&#x27;, use the above function `def harris_corner_response`, get &#x27;response&#x27;<br>    - do non-maximum suppression on &#x27;response&#x27;, by choosing the biggest values in a neighborhood, then set the others to 0, the neighborhood moves without overlapping, get &#x27;suppressed&#x27;<br>    - normalize the &#x27;suppressed&#x27; variable into [0, 1), get &#x27;normalized&#x27;<br>    - mark the values higher than the threshold value in &#x27;normalized&#x27;, which is calculated by giving a lower bound with proportion given by &#x27;threshold&#x27;<br></code></pre></td></tr></table></figure><h3 id="lucas-kanade-method3">Lucas Kanade Method<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255.">[3]</span></a></sup></h3><p>Lucas-Kanade method assumes that the displacement of the image contents between two sequenced frames is small and approximately constant within a neighborhood. Thus the functions to solve the displacement (optical flow) are more than the number of variables. <span class="math display">\[\begin{aligned}\mbox{From constancy assumption:}&amp;\\I(x,y,t)&amp;=I(x+\delta x,y+\delta y,t+\delta t)\\&amp;=I(x,y,t)+\frac{\partial I}{\partial x}\delta x+\frac{\partial I}{\partial y}\delta y+\frac{\partial I}{\partial t}\delta t \\\Rightarrow \frac{\partial I}{\partial x}\frac{\delta x}{\delta t}+\frac{\partial I}{\partial y}\frac{\delta y}{\delta t}&amp;=-\frac{\partial I}{\partial t}\\I_xV_x+I_yV_y&amp;=-I_t\\\\\mbox{In a neighborhood:}&amp;\\Av&amp;=b\\\begin{bmatrix}I_x(q_1) &amp; I_y(q_1)\\I_x(q_2) &amp; I_y(q_2)\\... &amp; ... \\I_x(q_n) &amp; I_y(q_n)\\\end{bmatrix}\begin{bmatrix}V_x \\ V_y\end{bmatrix}&amp;=\begin{bmatrix}-I_t(q_1)\\-I_t(q_2)\\...\\-I_t(q_n)\\\end{bmatrix}\\\Rightarrow v&amp;=(A^TA)^{-1}A^Tb\\&amp;=\begin{bmatrix}\sum_{i=1}^nI^2_{xi} &amp; \sum_{i=1}^nI_{xi}I_{yi}\\ \sum_{i=1}^nI_{xi}I_{yi} &amp; \sum_{i=1}^nI^2_{yi}\end{bmatrix}^{-1}\begin{bmatrix}-\sum_{i=1}^nI_{xi}I_{ti} \\ -\sum_{i=1}^nI_{yi}I_{ti}\end{bmatrix}\end{aligned}\]</span> The vector <span class="math inline">\(v\)</span> found by the above algorithm is the corresponding optical flow, we could track the position of the feature point by multiply the sample time constant <span class="math inline">\(\Delta t=1/fps\)</span>. It need be mentioned that <span class="math inline">\((A^TA)\)</span> in the last equation is the structure tensor mentioned in the Harris Corner Detector part. The condition KLT could work is that <span class="math inline">\((A^TA)\)</span> is invertible, and it is good to track. This means that Harris corner would be a suitable feature for KLT to track.</p><p>A better implementation is to use a weight for the neighborhood, because we are concerned about the central pixels rather than the margin. A gaussian template would be useful to do this.</p><h3 id="klt-feature-tracker3">KLT Feature Tracker<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255.">[3]</span></a></sup></h3><p>Kanade-Lucas-Tomasi Feature Tracker (KLT) is an approach to feature extraction. Some traditional image registration techniques are generally costly, KLT applies the spatial intensity information to find the match faster. <span class="math display">\[\begin{aligned}F(x+h_x, y+h_y)&amp;=F(x,y)+\begin{bmatrix}h_x &amp; h_y\end{bmatrix}\begin{bmatrix}F&#39;_x \\ F&#39;_y\end{bmatrix}\\&amp;=F(x,y)+hF&#39;(x,y)\\\mbox{Use L2 norm, error is: }E&amp;=\sum_{x \in R}[F(x+h_x, y+h_y) - G(x, y)]^2\\&amp;=\sum_{x \in R}[F(x,y)+hF&#39;(x,y) - G(x, y)]^2\\\mbox{To minimize the error: }0 &amp;=\frac{\partial E}{\partial h}\\&amp;\approx \sum_{x \in R}2F&#39;(x,y)[F(x,y)+hF&#39;(x,y) - G(x, y)]\\\Rightarrow h &amp;\approx\frac{\sum_{x \in R}F&#39;(x,y)[G(x,y) - F(x, y)]}{\sum_{x \in R}F&#39;(x,y)^2}\\\end{aligned}\]</span> The procedure is applied repeatedly by Newton-Raphson iteration. The Newton-Raphson iteration is a method that solve function approximately by applying the derivatives of the function, thus it would converge the sequence of estimation into the best <span class="math inline">\(h\)</span>. <span class="math display">\[\begin{aligned}\left\{\begin{aligned}h_0&amp;=0\\h_{k+1}&amp;=h_k+\frac{\sum_{x \in R}w(x,y)F&#39;(x+h_x, y+h_y)[G(x,y) - F(x+h_x, y+h_y)]}{\sum_{x \in R}w(x,y)F&#39;(x+h_x, y+h_y)^2}\\\end{aligned}\right.\end{aligned}\]</span></p><p>Here is the pseudocode of it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">def calculate_pixel_LK(start_xy, Ix, Iy, img_t, img_t2,<br>                       interp_window_size=(25, 25), iteration=20):<br>    &quot;&quot;&quot;<br>    :param start_xy: the start position of the corner point in img_t<br>    :param Ix: the gradient of img_t along x<br>    :param Iy: the gradient of img_t along y<br>    :param img_t: the img gray scale at time t<br>    :param img_t2: the img gray scale at time t+1<br>    :param interp_window_size: the window that interpolated to estimate LK optical flow, affecting the code efficiency<br>    :param iteration: Newton-Raphson iteration times<br>    &quot;&quot;&quot;<br>    get &#x27;H&#x27; and &#x27;W&#x27; as image shapes<br>    interpolate &#x27;img_t&#x27;, &#x27;Ix&#x27; and &#x27;Iy&#x27; by &#x27;interp_window_size&#x27; to get &#x27;I1_interp&#x27;, &#x27;Ix_interp&#x27; and &#x27;Iy_interp&#x27;, the window center is the position &#x27;start_xy&#x27;<br>    define a variable I whose column space is [&#x27;Ix&#x27;, &#x27;Iy&#x27;]<br>    define a matrix &#x27;A = I.T @ I&#x27;, this is similar to Least Square<br>    if the eigenvalue of the inverse matrix of &#x27;A&#x27; is too small, stop tracking this feature because it is not a good feature to track<br>    compute the inverse matrix of &#x27;A&#x27; as &#x27;invA&#x27;<br>    for &#x27;iteration&#x27; times, default is 20:<br>        interpolate &#x27;img_t2&#x27; to get &#x27;I2_interp&#x27;, similar to the above<br>        calculate &#x27;It = (I2_interp - I1_interp)&#x27; as the differential<br>        calculate &#x27;dx += -invA @ (_I.T @ _It)&#x27; to get the motions of this feature point<br></code></pre></td></tr></table></figure><h2 id="result">Result</h2><p>Recommend to watch the real-time result in <a href="https://www.bilibili.com/video/BV1WF41157CX/?vd_source=45dbbabddf51fc5827a0fed713c90afd">this video link</a>.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/output2.00_01_05_00.Still003.png" alt="output2.00_01_05_00.Still003" style="zoom: 67%;" /></p><center>Fig 2: a screenshot of the result video</center><p>Compare with the former project I have done by using Yolo 4, which is an open-source tracking-by-detection method, the KLT tracker has far less complexity in the program itself. I only use 400 lines of code to reproduce the whole algorism. Besides, it has better efficiency because detection is much more resource-consuming than the tracking method. However, my program would be easy to fail in tracking some objects with large motion or the background is too complex.</p><p>I try to analyze the performance of the KLT feature tracker theoretically. After doing some experiments, the number of feature points to track is the critical factor that affects the performance of the real-time test. As shown in the above part, for each feature point, we need to estimate its motion of it with 20 times of iteration of calculation in a certain neighborhood. Therefore, the Harris Corner detection should neither be too ambitious nor conservative. I use a suppression filter and a threshold to control the selection of feature points. Besides, my program would give up some feature points that have bad performance or have already lost the tracking object (out of the bounding box).</p><p>After adjusting the strategy and parameters of the program, my KLT feature tracker succeeds in tracking an object with a small translation for a long time. However, when the background is too complex or the motion is too fast, feature points would still go lost quickly, and the user need to re-select the object using ROI.</p><h2 id="conclusion">Conclusion</h2><p>In conclusion, I implemented a KLT feature tracker all in python without using third-party libraries, and then accelerated the program and run in real-time. The whole process is described in Fig 1. The main algorisms in this project are feature extraction and LK optical flow calculation. The optimized method I use focuses on choosing proper feature points and dynamically dropping off some bad feature points. The result is nice and beyond my expectation. I would use a Kalman filter or pyramid to improve the method and reduce the chance of losing feature points under complex backgrounds and large motion conditions.</p><p>In my view, optical flow contains much information and we have not found a way to utilize all of them. For example, the depth of field would affect the size of the optical flow, and affine transform and another complex transform rather than simple 2D translation also have their unique optical flow distribution. Therefore, theoretically developing some DIP methods to utilize the optical flow might be meaningful in many visual tasks.</p><h2 id="appendix">Appendix</h2><h3 id="harris-corner-detector-codes">Harris Corner Detector Codes</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">harris_corner_response</span>(<span class="hljs-params">arr, k=<span class="hljs-number">0.0</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    calculate the harris detection response of input array. If k=0.0, it uses the division strategy; if k!=0, the</span><br><span class="hljs-string">    recommended range for it is [0.4, 0.6]</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param arr: input 2d array with size MxN</span><br><span class="hljs-string">    :param k: 0.0 or [0.4, 0.6]</span><br><span class="hljs-string">    :return: the harris response matrix (MxN)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    g_x, g_y = grad(arr)<br>    IxIy = g_x * g_y<br>    M = np.zeros((g_x.size, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>    M[:, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = g_x ** <span class="hljs-number">2</span><br>    M[:, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] = IxIy<br>    M[:, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>] = IxIy<br>    M[:, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] = g_y ** <span class="hljs-number">2</span><br>    M_det = M[:, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] * M[:, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] - M[:, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] * M[:, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    M_tr = M[:, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] + M[:, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0.0</span>:<br>        <span class="hljs-keyword">return</span> M_det / (M_tr + <span class="hljs-number">0.0001</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> M_det - k * M_tr ** <span class="hljs-number">2</span><br><br><span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_harris_corner</span>(<span class="hljs-params">img, gaussian_sigma=<span class="hljs-number">1.0</span>, tensor_k=<span class="hljs-number">0.04</span>, suppressed_size=<span class="hljs-number">15</span>, threshold=<span class="hljs-number">0.05</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    could use larger `suppressed_size` and smaller `threshold` to get more corner points</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param img: input a gray-scale image</span><br><span class="hljs-string">    :param gaussian_sigma: gaussian filter param, usually about 1 is ok</span><br><span class="hljs-string">    :param tensor_k: the parameter related to harris corner response, 0.0 or [0.4, 0.6]</span><br><span class="hljs-string">    :param suppressed_size: do something like max filter for this, recommend 10-20</span><br><span class="hljs-string">    :param threshold: the threshold for marking high response points, 0.001 is ok</span><br><span class="hljs-string">    :return: the harris corners&#x27; x and y coordinates</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    _gaussian_filtered = gaussian_filter(img, gaussian_sigma, <span class="hljs-number">1</span>)<br>    _g_x, _g_y = grad(_gaussian_filtered)<br>    _tensor = harris_corner_response(_gaussian_filtered, k=tensor_k).reshape(img.shape[<span class="hljs-number">0</span>], img.shape[<span class="hljs-number">1</span>])<br>    _non_maximum_suppressed = non_maximum_suppression(_tensor, kernel_size=suppressed_size)<br>    _marked = mark_local_maximum(_non_maximum_suppressed, set_threshold=threshold)<br>    <span class="hljs-keyword">return</span> _marked<br></code></pre></td></tr></table></figure><h3 id="optical-flow-calculation-codes">Optical Flow Calculation Codes</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_pixel_LK</span>(<span class="hljs-params">start_xy, Ix, Iy, img_t, img_t2,</span></span><br><span class="hljs-params"><span class="hljs-function">                       interp_window_size=(<span class="hljs-params"><span class="hljs-number">25</span>, <span class="hljs-number">25</span></span>), iteration=<span class="hljs-number">20</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    calculate the translation of a detected harris corner point</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param start_xy: the start position of the corner point in img_t</span><br><span class="hljs-string">    :param Ix: the gradient of img_t along x</span><br><span class="hljs-string">    :param Iy: the gradient of img_t along y</span><br><span class="hljs-string">    :param img_t: the img gray scale at time t</span><br><span class="hljs-string">    :param img_t2: the img gray scale at time t+1</span><br><span class="hljs-string">    :param interp_window_size: the window that interpolated to estimate LK optical flow, affecting the code efficiency</span><br><span class="hljs-string">    :param iteration: Newton-Raphson iteration times</span><br><span class="hljs-string">    :return: the translation in _dx = (dx, dy)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    H, W = img_t.shape[<span class="hljs-number">0</span>], img_t.shape[<span class="hljs-number">1</span>]<br>    img_t = img_t.astype(np.float64)<br>    img_t2 = img_t2.astype(np.float64)<br>    I1_value = interp2d(img_t, start_xy, interp_window_size).ravel()<br>    _Ix = interp2d(Ix.reshape(H, W), start_xy, interp_window_size).ravel()<br>    _Iy = interp2d(Iy.reshape(H, W), start_xy, interp_window_size).ravel()<br>    _I = np.zeros((_Ix.size, <span class="hljs-number">2</span>))<br>    _I[:, <span class="hljs-number">0</span>] = _Ix<br>    _I[:, <span class="hljs-number">1</span>] = _Iy<br>    _A = _I.T @ _I<br>    <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">any</span>(np.linalg.eig(_A)[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">10e-3</span>):  <span class="hljs-comment"># handle the failure of inverse term `(A.T @ A) ** -1`</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># try:</span><br>    _invA = np.linalg.inv(_A)<br>    <span class="hljs-comment"># except np.linalg.LinAlgError:</span><br>    <span class="hljs-comment">#     return None</span><br>    _dx = np.zeros(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iteration):<br>        I2_value = interp2d(img_t2, (start_xy[<span class="hljs-number">0</span>] + _dx[<span class="hljs-number">0</span>], start_xy[<span class="hljs-number">1</span>] + _dx[<span class="hljs-number">1</span>]), interp_window_size).ravel()<br>        _It = (I2_value - I1_value).ravel()<br>        _dx += -_invA @ (_I.T @ _It)<br>    <span class="hljs-keyword">return</span> _dx<br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Bruce D. Lucas and Takeo Kanade. An Iterative Image Registration Technique with an Application to Stereo Vision. <em>International Joint Conference on Artificial Intelligence</em>, pages 674–679, 1981. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Jianbo Shi and Carlo Tomasi. Good Features to Track. <em>IEEE Conference on Computer Vision and Pattern Recognition</em>, pages 593–600, 1994. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255. <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>Python</tag>
      
      <tag>光流</tag>
      
      <tag>目标追踪</tag>
      
      <tag>特征点提取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行走机器人课程-ZMP双足控制与动力学</title>
    <link href="/2022/06/13/2022-06-13-ZMP-dynamics/"/>
    <url>/2022/06/13/2022-06-13-ZMP-dynamics/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>ZMP (Zero moment point) is used for legged locomotion control, specifying <strong>the point with respect to which dynamic reaction force at the contact of the foot with the ground does not produce any moment in the horizontal direction</strong>. The concept assumes the contact area is planar and has sufficiently high friction to keep the feet from sliding.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317142420502.png" alt="image-20220317142420502" style="zoom:50%;" /></p><p>The following figure demonstrates how ZMP works for discussing robot's motion and the ground reaction force. The left figure using <strong>inertia force</strong>, which learned in high school, for expressing the effect of acceleration. The right figure is simply doing force balancing.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220319102806761.png" alt="image-20220319102806761" style="zoom:67%;" /></p><h2 id="zmp-analysis">ZMP Analysis</h2><h3 id="convex-set-and-convex-hull">Convex Set and Convex Hull</h3><p>These two concepts are sued to introduce the support polygon concept, which depicts the region of the ZMP. <strong>If a segment by connecting any arbitrary two points included in the set <span class="math inline">\(S\)</span> is also included in <span class="math inline">\(S\)</span>, the set is defined to be the convex set</strong>. In equation, A subset <span class="math inline">\(S\)</span> of <span class="math inline">\(R^n\)</span> is defined to be the convex set if (<span class="math inline">\(\alpha\)</span> depicts positions between <span class="math inline">\(p_1,p_2\)</span>): <span class="math display">\[\alpha p_1 + (1 -\alpha)p_2 \in S\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317151756410.png" alt="image-20220317151756410" style="zoom:67%;" /></p><p>The minimum convex set including <span class="math inline">\(S\)</span> is defined to be the convex hull <span class="math inline">\(coS\)</span>, that is, <strong>the minimum polygon area containing all the vector of edges <span class="math inline">\(p_j \quad (j=1,...,N)\)</span> of a subset <span class="math inline">\(S\)</span> of <span class="math inline">\(R^n\)</span> corresponds to the convex hull</strong>: <span class="math display">\[coS=\left\{\sum^{N}_{j=1}\alpha_jp_j | \alpha_j \geq 0, \sum^{N}_{j=1}\alpha_j=1,p_j \in S \quad (j=1,...,N)\right\}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317154131122.png" alt="image-20220317154131122" style="zoom:67%;" /></p><h3 id="zmp-and-com">ZMP and CoM</h3><p><strong>Zero momentum always exists inside of the support polygon</strong>, while CoM may lays on the outside when body moves dynamically, like the following figure. When the ground projection of CoM coincides with ZMP, the body can keep balance.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317154709012.png" alt="image-20220317154709012" style="zoom:67%;" /></p><h3 id="d-analysis">2D Analysis</h3><p>From the knowledge of mechanics, we know that the ground reaction force can be analyzed separately as vertical component <span class="math inline">\(\rho(\xi)\)</span> and horizontal component <span class="math inline">\(\sigma(\xi)\)</span>. Then equivalent them to the ZMP, we got the following relationships:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317172212767.png" alt="image-20220317172212767" style="zoom:67%;" /> <span class="math display">\[\begin{aligned}f_x&amp;=\int_{x_1}^{x_2}\sigma(\xi)d\xi \\f_z&amp;=\int_{x_1}^{x_2}\rho(\xi)d\xi \\\tau(p_x)&amp;=-\int_{x_1}^{x_2}(\xi-p_x)\rho(\xi)d\xi \\&amp;\Rightarrow \tau(p_x)=0 \\&amp;\Rightarrow p_x=\frac{\int_{x_1}^{x_2}\xi\rho(\xi)d\xi}{\int_{x_1}^{x_2}\rho(\xi)d\xi}\end{aligned}\]</span> From the equation above and the figure below, there are a few points to be concluded:</p><ol type="1"><li>ZMP should locate inside the support polygon while maintaining a certain margin from the end</li><li>By <span class="math inline">\(\rho(\xi) \geq 0\)</span> we can obtain that <span class="math inline">\(x_1 \leq p_x \leq x_2\)</span>, that is, the ZMP always lay inside the polygon region</li><li>The Shear force has no contribution to the position of ZMP</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317212843187.png" alt="image-20220317212843187" style="zoom:67%;" /></p><h3 id="extend-to-3d">Extend to 3D</h3><p>It is the same with the 2D condition, just replacing integral over length with area. Since <span class="math inline">\(\rho(\xi,\eta)\)</span> is equivalent to the pressure over the surface of the sole, the point <span class="math inline">\((p_x, p_y)\)</span> is the center of pressure or in other word, ZMP.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317214934414.png" alt="image-20220317214934414" style="zoom:67%;" /> <span class="math display">\[\begin{aligned}f_z&amp;=\int_S\rho(\xi,\eta)dS \\\tau_n(p) &amp;\equiv[\tau_{nx} \ \tau_{ny} \ \tau_{nz}]^T \\\Rightarrow &amp;\left\{\begin{aligned}\tau_{nx}&amp;=\int_S(\eta-p_y)\rho(\xi,\eta)dS=0 \\\tau_{ny}&amp;=-\int_S(\xi-p_x)\rho(\xi,\eta)dS=0 \\\tau_{nz}&amp;=0\end{aligned}\right. \\\Rightarrow &amp;\left\{\begin{aligned}p_x=\frac{\int_S\xi\rho(\xi,\eta)dS}{\int_S\rho(\xi,\eta)dS} \\p_y=\frac{\int_S\eta\rho(\xi,\eta)dS}{\int_S\rho(\xi,\eta)dS}\end{aligned}\right. \\\end{aligned}\]</span> Notice that one thing is different from the 2D case: <strong>the moment on z-axis is not zero for ZMP</strong>. Therefore, ZMP only control the row and pitch angle, but not the yaw angle. <span class="math display">\[\begin{aligned}\tau_p &amp; = [0 \ 0 \ \tau_{tz}]^T \\\tau_{tz} &amp;=\int_S[(\xi-p_x)\sigma_y(\xi,\eta)-(\eta-p_y)\sigma_x(\xi,\eta)]dS\end{aligned}\]</span></p><h3 id="measurement-of-zmp">Measurement of ZMP</h3><p>When the robot moves and the foot is forced on the ground, the output of the force/torque sensor at the foot is generated. By using this sensor information, the position of the ZMP is measured.</p><p>The sensor used here is the 6 Axis Force/Torque Sensor, which could measure <span class="math inline">\([f_x,f_y,f_z,\tau_x,\tau_y,\tau_z]\)</span> data on a single foot. However, using multiple one dimensional force sensors or 3 axis force sensors can work as well. The general measure metric is described below:</p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220317233835889.png" alt="image-20220317233835889" style="zoom: 67%;" /> $$<span class="math display">\[\begin{aligned}&amp;\mbox{&#39;j&#39; corresponds to the jth sensor measurement:} \\\tau(p)&amp;=\sum^{N}_{j=1}(p_j-p)\times f_j+\tau_j \\&amp;\mbox{set x and y components to zero:} \\&amp;\Rightarrow \hat{p}\times f_j = (\hat{p}_yf_{jz}-\hat{p}_zf_{jy})i+(\hat{p}_zf_{jx}-\hat{p}_xf_{jz})j+(\hat{p}_xf_{jy}-\hat{p}_yf_{jx})k \\&amp;\Rightarrow\left\{\begin{aligned}(\hat{p}\times f_j)_y = \hat{p}_zf_{jx}-\hat{p}_xf_{jz} \\(\hat{p}\times f_j)_x = \hat{p}_yf_{jz}-\hat{p}_zf_{jy} \\\end{aligned}\right. \\\Rightarrow&amp;\left\{\begin{aligned}\sum^{N}_{j=1}\hat{p}_yf_{jz}-\hat{p}_zf_{jy}+\tau_{jx}=0 \\\sum^{N}_{j=1}\hat{p}_zf_{jx}-\hat{p}_xf_{jz}+\tau_{jy}=0\end{aligned}\right. \\\Rightarrow&amp;\left\{\begin{aligned}&amp;p_x = \frac{\sum^{N}_{j=1}[-\tau_{jy}-(p_{jz}-p_z)f_{jx}+p_{jx}f_{jz}]}{\sum^{N}_{j=1}f_{jz}} \\&amp;p_y = \frac{\sum^{N}_{j=1}[\tau_{jx}-(p_{jz}-p_z)f_{jy}+p_{jy}f_{jz}]}{\sum^{N}_{j=1}f_{jz}} \\\end{aligned}\right. \\\end{aligned}\]</span><p>$$</p><p>For the both feet contact, we can just combine the right and left foot ZMPs which are <span class="math inline">\(p_R, p_L\)</span>, and the forces on them are <span class="math inline">\(f_R, f_L\)</span>. The following formula is used when both feet are on the ground, otherwise use the above equations for single foot condition. <span class="math display">\[\begin{aligned}p_x=\frac{p_{Rx}f_{Rz}+p_{Lx}f_{Lz}}{f_{Rz}+f_{Lz}} \\p_y=\frac{p_{Ry}f_{Rz}+p_{Ly}f_{Lz}}{f_{Rz}+f_{Lz}}\end{aligned}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220318103239720.png" alt="image-20220318103239720" style="zoom:67%;" /></p><h3 id="limitation-of-zmp">Limitation of ZMP</h3><p>ZMP only contains 2D constriction information, but the ground reaction force is 6 dimensional information with force/moment.</p><ol type="1"><li>ZMP cannot determine whether or not the sole slips on the ground surface, and it cannot depict the yaw rotation as well. It can only describe roll and pitch for biped motion.</li><li>If the ground surface is not flat, the friction is uncertain, so ZMP cannot work.</li><li>If the arms or the hands of a humanoid robot contact the environment, ZMP need to be extended.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/R.189ad494ff5812a6034397a3f47f5ce8rik=MT9araNcXOvGeA&riu=http%3a%2f%2fi.stack.imgur.com%2f65EKz.png&ehk=bSDL3CiJcolTGpJpClPnetLzgtf65cZ%2fMILbGlcd2Ns%3d&risl=&pid=ImgRaw&r=0" alt="See the source image" style="zoom: 50%;" /></p><h2 id="dynamics-of-humanoid-robots">Dynamics of Humanoid Robots</h2><h3 id="physics-review">Physics Review</h3><p>Let's review the knowledge of physics:</p><ol type="1"><li>Momentum is <span class="math inline">\(P=\dot{c}M\)</span>, <span class="math inline">\(c\)</span> is the CoM and M is the total mass, <span class="math inline">\(c=\sum^{N}_{i=1}m_ip_i/M\)</span>. Derived from CoM, <span class="math inline">\(\dot{c}=\sum^{N}_{i=1}m_i\dot{p_i}/M=\dot{P}/M\)</span></li><li>The derivative of momentum describes the force acting on the center, <span class="math inline">\(\dot{P}=f_{all}=Mg+f\)</span></li><li>Similar with (linear) momentum, the change of angular momentum describes torque about the origin, <span class="math inline">\(\dot{L}=\tau_{all}=c\times Mg+\tau\)</span>. When robot is still, the ground reaction moment <span class="math inline">\(\tau\)</span> applied should balance with the moment generated by gravity.</li><li>The angular and linear momentum has relation of <span class="math inline">\(L_i=p_i\times P_i\)</span>, which is a pseudo vector like angular velocity. The angular momentum is not only a property for rotational motion, for example, <strong>constant speed linear motion and constant speed rotation both have conservation of angular momentum</strong>.</li><li>The derivative of angular momentum is equal to the overall torque, proof is below:</li></ol><p><span class="math display">\[\begin{aligned}\dot{L_i}&amp;=\dot{p_i}\times P_i+p_i\times \dot{P_i} \\&amp;=0+p_i\times \dot{P_i} =p_i\times m_i\ddot{p_i}\\&amp;= \sum^{N}_{j=1}p_i\times f_{ij}^int+p_i\times f_i^{ext} \\\dot{L}&amp;=\sum^{N}_{i=1}p_i\times f_i^{ext}=\tau_{all}\end{aligned}\]</span></p><h3 id="derive-the-inertia-tensor-of-rigid-body">Derive the Inertia Tensor of Rigid Body</h3><p>Using the conclusions of pseudo vector mentioned in the former blog, we proved that <span class="math inline">\(I \equiv \sum_im_i\hat{p_i}\hat{p_i}^T\)</span>, which is a 3 x 3 symmetric matrix. <span class="math display">\[\begin{aligned}L&amp;=\sum_ip_i\times P_i \\&amp;=\sum_ip_i\times m_iv_i \\&amp;=\sum_ip_i\times (m_i\omega\times p_i) \\&amp;=\sum_im_ip_i\times (-p_i\times \omega) \\&amp;=(\sum_im_i\hat{p_i}\hat{p_i}^T)\omega \\&amp;=I\omega \\\end{aligned}\]</span> We can see from this figure that <strong>the direction of the angular momentum is usually different from that of the angular velocity</strong>. The proof is from the above equation, using a conclusion of multiple cross product, <span class="math inline">\(a\times (b\times c)=(a\cdot c)\cdot b-(a\cdot b)c\)</span>: <span class="math display">\[\begin{aligned}L&amp;=\sum_im_ip_i\times (\omega\times p_i) \\&amp;=\sum_im_i[(p_i\cdot p_i)\cdot \omega-(p_i\cdot \omega)p_i]\end{aligned}\]</span> If <span class="math inline">\(\omega \cdot p_i=0\)</span>, then the direction of <span class="math inline">\(L\)</span> and <span class="math inline">\(\omega\)</span> are the same, that is, the rotation is vertical to the surface of the rigid body.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220319122030857.png" alt="image-20220319122030857" style="zoom:67%;" /></p><p>The inertia of some uniform shape are listed in the following table, for example, the <span class="math inline">\(I\)</span> of a cuboid is below. <span class="math display">\[I=\begin{bmatrix}\frac{m}{12}(l_y^2+l_z^2) &amp;0&amp;0\\0&amp;\frac{m}{12}(l_x^2+l_z^2)&amp; 0\\0&amp;0&amp; \frac{m}{12}(l_x^2+l_y^2)\end{bmatrix}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/momi_table.png" alt="img" style="zoom: 55%;" /></p><p>The rotation frame transform for a rigid body can be done with a rotation matrix, as we discussed before. If we consider that the object is rotated due to the change of view point, we can easily understand that <strong>the relative position of both the angular velocity vector and the angular momentum vector with respect to the rigid body do not change</strong>. <span class="math display">\[\begin{aligned}\omega&#39; &amp;=R\omega \\L&#39; &amp;=RL\\\Rightarrow &amp; L&#39; = (RIR^T)\omega=\hat{I}\omega\end{aligned}\]</span></p><h2 id="code-calculation">Code Calculation</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220328172704672.png" alt="image-20220328172704672" style="zoom: 80%;" /></p><h3 id="center-of-mass">Center of Mass</h3><ul><li>Calculate CoM for the j-th link as <span class="math inline">\(\overline{c}_j\)</span> in local coordinate</li><li>The CoM of each link in world coordinate is <span class="math inline">\(c_j=p_j+R_j\overline{c}_j\)</span></li><li>Divide the sum of moment by the total mass, got <span class="math inline">\(c=\sum^{N}_{j=1}m_jc_j/M\)</span></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mc</span> = <span class="hljs-title">calcMC</span><span class="hljs-params">(j)</span> % <span class="hljs-title">recursive</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> == <span class="hljs-number">0</span> <span class="hljs-comment">% already traverse all the links (of this branch)</span><br>    mc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    mc = uLINK(<span class="hljs-built_in">j</span>).m * (uLINK(<span class="hljs-built_in">j</span>).p + uLINK(<span class="hljs-built_in">j</span>).R * uLINK(<span class="hljs-built_in">j</span>).c );<br>    mc = mc + calcMC(uLINK(<span class="hljs-built_in">j</span>).sister) + calcMC(uLINK(<span class="hljs-built_in">j</span>).child);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">com</span> = <span class="hljs-title">calcCoM</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br>M = TotalMass(<span class="hljs-number">1</span>); <span class="hljs-comment">% add up all the mass, start from the 1st link</span><br>MC = calcMC(<span class="hljs-number">1</span>);<br>com = MC / M;<br></code></pre></td></tr></table></figure><h3 id="link-speed-and-angular-velocity">Link Speed and Angular Velocity</h3><p><span class="math display">\[\begin{aligned}v_j&amp;=v_i+\omega_i\times R_ib_j \\\omega_j&amp;=\omega_i+R_ia_j\dot{q_j} \\\end{aligned}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ForwardVelocity</span><span class="hljs-params">(j)</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">return</span>; <span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> ~= <span class="hljs-number">1</span><br>    <span class="hljs-built_in">i</span> = uLINK(<span class="hljs-built_in">j</span>).mother;<br>    uLINK(<span class="hljs-built_in">j</span>).v = uLINK(<span class="hljs-built_in">i</span>).v + <span class="hljs-built_in">cross</span>(uLINK(<span class="hljs-built_in">i</span>).w, uLINK(<span class="hljs-built_in">i</span>).R * uLINK(<span class="hljs-built_in">j</span>).b);<br>    <span class="hljs-comment">% w = a * dq, dq is the amplitude of omega and a is the direction</span><br>    uLINK(<span class="hljs-built_in">j</span>).w = uLINK(<span class="hljs-built_in">i</span>).w + uLINK(<span class="hljs-built_in">i</span>).R * (uLINK(<span class="hljs-built_in">j</span>).a * uLINK(<span class="hljs-built_in">j</span>).dq);<br><span class="hljs-keyword">end</span><br>ForwardVelocity(uLINK(<span class="hljs-built_in">j</span>).sister);<br>ForwardVelocity(uLINK(<span class="hljs-built_in">j</span>).child);<br></code></pre></td></tr></table></figure><h3 id="momentum">Momentum</h3><p><span class="math display">\[\begin{aligned}P &amp;= \sum^{N}_{j=1}m_j\dot{c_j} \\\dot{c_j} &amp;=v_j+\omega_j\times(R_j\overline{c}_j)\end{aligned}\]</span></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220328180716548.png" alt="image-20220328180716548" style="zoom: 25%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span> = <span class="hljs-title">calcP</span><span class="hljs-params">(j)</span> % <span class="hljs-title">calculate</span> <span class="hljs-title">the</span> <span class="hljs-title">overall</span> <span class="hljs-title">momentum</span> <span class="hljs-title">recursively</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> == <span class="hljs-number">0</span><br>    P = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    c1 = uLINK(<span class="hljs-built_in">j</span>).R * uLINK(<span class="hljs-built_in">j</span>).c;<br>    P = uLINK(<span class="hljs-built_in">j</span>).m * (uLINK(<span class="hljs-built_in">j</span>).v + <span class="hljs-built_in">cross</span>(uLINK(<span class="hljs-built_in">j</span>).w , c1));<br>    P = P + calcP(uLINK(<span class="hljs-built_in">j</span>).sister) + calcP(uLINK(<span class="hljs-built_in">j</span>).child);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="angular-momentum">Angular Momentum</h3><p><span class="math display">\[\begin{aligned}L &amp;= \sum^{N}_{j=1}L_j \\L_j &amp;= L_{joint}+L_{local} \\&amp;= c_j\times P_j+R_j\overline{I}_jR^T_j\omega_j\end{aligned}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">L</span> = <span class="hljs-title">calcL</span><span class="hljs-params">(j)</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> == <span class="hljs-number">0</span><br>    L = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    c1 = uLINK(<span class="hljs-built_in">j</span>).R * uLINK(<span class="hljs-built_in">j</span>).c;<br>    c = uLINK(<span class="hljs-built_in">j</span>).p + c1; <span class="hljs-comment">% j-th link CoM in world coordinate</span><br>    P = uLINK(<span class="hljs-built_in">j</span>).m * (uLINK(<span class="hljs-built_in">j</span>).v + <span class="hljs-built_in">cross</span>(uLINK(<span class="hljs-built_in">j</span>).w , c1));<br>    L = <span class="hljs-built_in">cross</span>(c, P) + uLINK(<span class="hljs-built_in">j</span>).R * uLINK(<span class="hljs-built_in">j</span>).I * uLINK(<span class="hljs-built_in">j</span>).R’ * uLINK(<span class="hljs-built_in">j</span>).w;<br>    L = L + calcL(uLINK(<span class="hljs-built_in">j</span>).sister) + calcL(uLINK(<span class="hljs-built_in">j</span>).child);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="zmp-from-robots-motion">ZMP from Robot's Motion</h3><p>We should know that the reason we use ZMP is to simplify the analysis of ground reaction force. The GRF can be expressed by ZMP(<span class="math inline">\(p\)</span>), the force (<span class="math inline">\(f\)</span>) and the moment (<span class="math inline">\(\tau_p\)</span>) about the vertical line including the ZMP. <span class="math display">\[\tau=p\times f+\tau_p\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220328191437208.png" alt="image-20220328191437208" style="zoom:67%;" /></p><p>In the above section, a method to measure ZMP by sensors is introduced, now we want to calculate ZMP by given motion of the robot. Through the result of below, we can observe that <strong>a special condition is when <span class="math inline">\(\dot{P}=\dot{L}=0\)</span>, the ZMP coincides with the CoM</strong>. <span class="math display">\[\begin{aligned}\dot{P} &amp;=Mg+f \\\dot{L} &amp;=c\times Mg+\tau \\&amp;\mbox{substitued back:}\\\tau_p &amp;=\dot{L}-c\times Mg+(\dot{P}-Mg)\times p \\&amp;\mbox{remember that:} \\\hat{a}&amp;=\begin{bmatrix}0 &amp; -a_z &amp; a_y \\a_z &amp; 0 &amp; -a_x \\-a_y &amp; a_x &amp; 0\end{bmatrix} \\c &amp;= [x \ y \ z]^T \\g &amp;= [0 \ 0 \ -g]^T \\\Rightarrow\\&amp;\left\{\begin{aligned}\tau_{px} &amp;=\dot{L}_x+ Mgy+\dot{P}_yp_z-(\dot{P}_z+Mg) p_y=0 \\\tau_{py} &amp;=\dot{L}_y- Mgx-\dot{P}_xp_z+(\dot{P}_z+Mg) p_x=0 \\\end{aligned}\right.\\\Rightarrow\\&amp;\left\{\begin{aligned}&amp;p_x = \frac{Mgx+\dot{P}_yp_z-\dot{L}_y}{\dot{P}_z+Mg}\\&amp;p_y = \frac{Mgy+\dot{P}_yp_z+\dot{L}_x}{\dot{P}_z+Mg}\\\end{aligned}\right.\end{aligned}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[px,py]</span> = <span class="hljs-title">calcZMP</span><span class="hljs-params">(c,dP,dL,pz)</span></span><br><span class="hljs-keyword">global</span> M G<br><br><span class="hljs-comment">% dP and dL are numerical differentiation of the momentum and angular momentum</span><br><span class="hljs-comment">% P and L are sequences when robot are in motion</span><br>px = (M*G*c(<span class="hljs-number">1</span>) + pz * dP(<span class="hljs-number">1</span>) - dL(<span class="hljs-number">2</span>))/(M*G + dP(<span class="hljs-number">3</span>));<br>py = (M*G*c(<span class="hljs-number">2</span>) + pz * dP(<span class="hljs-number">2</span>) + dL(<span class="hljs-number">1</span>))/(M*G + dP(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h3 id="calculating-zmp-by-approximation">Calculating ZMP by Approximation</h3>As we discussed above, the angular momentum of the j-th link is as shown. To simplify the model, we ignore the inertia tensor of each link about its CoM: <span class="math display">\[\begin{aligned}L_j &amp;= c_j\times P_j+R_j\overline{I}_jR^T_j\omega_j \\&amp;\approx c_j\times P_j \\\end{aligned}\]</span> <strong>It can be calculated with enough accuracy if we model each link by using multiple point masses</strong>. However, we can also approximate all the mass into a single CoM for the whole system, which we would use in biped gait pattern design. Below are approximation strategy based on multiple CoMs system and single CoM system. $$<span class="math display">\[\begin{aligned}&amp;\mbox{* Multiple CoMs System:}\\ L &amp;= \sum^N_{i=1}c_j\times P_j \\\Rightarrow\\p_x&amp;=\frac{\sum^N_{i=1}m_i\{(\ddot{z}_i+g)x_i-(z_i-p_z)\ddot{x}_i)\}}{\sum^N_{i=1}m_i(\ddot{z}_i+g)}\\p_y&amp;=\frac{\sum^N_{i=1}m_i\{(\ddot{z}_i+g)y_i-(z_i-p_z)\ddot{y}_i)\}}{\sum^N_{i=1}m_i(\ddot{z}_i+g)}\\&amp;\mbox{* Single CoM System:}\\ P&amp;=M\dot{c}=\begin{bmatrix}M\ddot{x} \\ M\ddot{y}\\ M\ddot{z}\end{bmatrix}\\L&amp;=c\times M\dot{c}=\begin{bmatrix}M(y\ddot{z}-z\ddot{y}) \\ M(z\ddot{x}-x\ddot{z})\\ M(x\ddot{y}-y\ddot{x})\end{bmatrix}\\\Rightarrow\\p_x&amp;=x-\frac{(z-p_z)\ddot{x}}{\ddot{z}+g}\\p_y&amp;=y-\frac{(z-p_z)\ddot{y}}{\ddot{z}+g}\end{aligned}\]</span><p>$$ <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220328201646072.png" alt="image-20220328201646072" style="zoom:67%;" /></p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Zero_moment_point">Zero moment point</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://spiff.rit.edu/classes/phys216/workshops/w9c/w9c.html">Parallel-axis theorem, torque</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>Walking Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ZMP</tag>
      
      <tag>Dynamics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行走机器人课程-运动学复习</title>
    <link href="/2022/06/12/2022-06-12-walking-robot-kinematics/"/>
    <url>/2022/06/12/2022-06-12-walking-robot-kinematics/</url>
    
    <content type="html"><![CDATA[<p>大三下学期行走机器人这门课程的一些笔记，用的教材是日本Kajita的Introduction to Humanoid Robotics，估计是因为老师主要是做双足机器人的。</p><span id="more"></span><h2 id="腿足机器人相关术语">腿足机器人相关术语</h2><table><tr><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303202715842.png" alt="image-20220303202715842" style="zoom: 67%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303203014777.png" alt="image-20220303203014777" style="zoom:67%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303203312534.png" alt="image-20220303203312534" style="zoom:67%;" /></td></tr></table><h2 id="坐标系">坐标系</h2><h3 id="绝对坐标系">绝对坐标系</h3><p>  绝对坐标系或世界坐标系（World Coordinates）<span class="math inline">\(\sum_W\)</span>中，位置向量用绝对位置（Absolute Positions）来表示： <span class="math display">\[p_h=\begin{bmatrix}p_{hx} \\ p_{hy} \\ p_{hz}\end{bmatrix}\]</span></p><h3 id="相对坐标系与坐标变换">相对坐标系与坐标变换</h3><p>  相对坐标系和绝对坐标系之间的转换可以用变换关系<span class="math inline">\(p_h=p_a+R_a \ ^{a}p_h\)</span>表示，<span class="math inline">\(p_a\)</span>描述与<span class="math inline">\(\sum_W\)</span>的相对位置关系，<span class="math inline">\(R_a\)</span>描述相对<span class="math inline">\(\sum_W\)</span>的旋转角度。可以将下图右侧的相对坐标系<span class="math inline">\(\sum_a\)</span>的单位向量投影到<span class="math inline">\(\sum_W\)</span>，得到： <span class="math display">\[e_{ax}=\begin{bmatrix}1 \\ 0 \\ 0\end{bmatrix}, &amp;   &amp;e_{ay}=\begin{bmatrix}0 \\ cos\phi \\ sin\phi\end{bmatrix}, &amp;   &amp;e_{az}=\begin{bmatrix}0 \\ -sin\phi \\ cos\phi\end{bmatrix}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303184501646.png" alt="image-20220303184501646" style="zoom:67%;" /></p><p>  将整个坐标系变换关系用一个4 x 4矩阵表示，用0和1来匹配dimensions得到下面的齐次变换矩阵（Homogeneous transformation matrices）： <span class="math display">\[\begin{bmatrix}p_h \\ 1\end{bmatrix}=\begin{bmatrix}R_a &amp; p_a \\ 0\ 0\ 0 &amp; 1\end{bmatrix}\begin{bmatrix}^{a}p_h \\ 1\end{bmatrix}=T_a\begin{bmatrix}^{a}p_h \\ 1\end{bmatrix}\]</span>   对于两个相对坐标系，存在相同的关系，例如现在描述elbow相对shoulder的关系<span class="math inline">\(^{a}\sum_b\)</span>，并由此可以继续推出elbow和should共同运动的结果相对<span class="math inline">\(\sum_W\)</span>的齐次变换<span class="math inline">\(T_b\)</span>。对这个结论进行推广，由链式法则得到第N个joint的齐次变换矩阵，<em>其实这就是正运动学的原理了</em>。 <span class="math display">\[\begin{aligned}\begin{bmatrix}^{a}p_h \\ 1\end{bmatrix} &amp; =\begin{bmatrix}^{a}R_b &amp; ^{a}p_b \\ 0\ 0\ 0 &amp; 1\end{bmatrix}\begin{bmatrix}^{b}p_h \\ 1\end{bmatrix}=\ ^{a}T_b\begin{bmatrix}^{b}p_h \\ 1\end{bmatrix} \\\\\Rightarrow\begin{bmatrix}p_h \\ 1\end{bmatrix} &amp; =\ T_a \ ^{a}T_b\begin{bmatrix}^{b}p_h \\ 1\end{bmatrix}\RightarrowT_b \equiv T_a \ ^{a}T_b \\\\\RightarrowT_N &amp; = T_1 \ ^{1}T_2 \ ^{2}T_3 \ ^{3}T_4... \ ^{N-1}T_N\end{aligned}\]</span></p><h2 id="旋转矩阵与欧拉角">旋转矩阵与欧拉角</h2><h3 id="欧拉角与旋转矩阵关系">欧拉角与旋转矩阵关系</h3><p>  欧拉角的定义挺灵活的，有的时候根据物体运动特点定义，有的时候根据坐标轴定义，所以在看课本或paper之前要看好定义。本课本中定义<span class="math inline">\(roll,pitch,yaw\)</span>为<span class="math inline">\(xyz\)</span>三轴的旋转角：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402150402685.png" alt="image-20220402150402685" style="zoom: 50%;" /> <span class="math display">\[\begin{aligned}p&#39;&amp;=R_{rpy}(\phi,\theta,\psi)p \\&amp;=R_z(\psi)R_y(\theta)R_x(\phi)p \\\end{aligned}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402150908339.png" alt="image-20220402150908339" style="zoom: 33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402153453022.png" alt="image-20220402153453022" style="zoom: 33%;" /></p><h3 id="旋转矩阵的两种理解">旋转矩阵的两种理解</h3><p>  旋转矩阵<span class="math inline">\(p&#39;=Rp\)</span>可以理解为两种情形：</p><ol type="1"><li>将旋转矩阵<span class="math inline">\(R\)</span>看作一个Operator，可以拆解成三个轴方向旋转的叠加，作用是旋转向量<span class="math inline">\(p\)</span>到<span class="math inline">\(p&#39;\)</span></li><li>旋转矩阵<span class="math inline">\(R\equiv[e_x \ e_y \ e_z]\)</span>的列向量对应一个新的坐标系，<span class="math inline">\(Rp\)</span>本质是线性变换，将新坐标系中的坐标<span class="math inline">\(p\)</span>变换到世界坐标系中的<span class="math inline">\(p&#39;\)</span></li></ol><blockquote><p>How can we figure out a rotation matrix used in which meaning, (1) operator to rotate a vector, or (2) attitude of a local frame? <strong>We can see it by checking whether the point exists in the same coordinate space before and after the calculation</strong>. Most of the time, however, it is clear from the context.</p></blockquote><h3 id="旋转矩阵性质">旋转矩阵性质</h3><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402153730601.png" alt="image-20220402153730601" style="zoom:33%;" /> <span class="math display">\[R^{-1}=R^T\]</span></p><h3 id="旋转矩阵求导">旋转矩阵求导</h3><p>  在前面提到了旋转矩阵的第二种理解方式，即坐标系的线性变换。现在将该公式两侧进行求导，<span class="math inline">\(\overline{p}\)</span>是局部坐标系的坐标向量，但是在线性变换它是作为weight的，因此右侧的求导是对<span class="math inline">\(R\)</span>进行： <span class="math display">\[\begin{aligned}p &amp;=R\overline{p} \\\dot{p} &amp;= \dot{R}\overline{p} \\&amp;= \dot{R}(R^{-1}p) \\\Rightarrow \dot{p}&amp;= \dot{R}R^Tp\end{aligned}\]</span>   用该公式可以计算，物体一个顶点vertex的运动速度。</p><h2 id="角速度向量">角速度向量</h2><h3 id="定义">定义</h3><p>  用<span class="math inline">\(w\)</span>来表示角速度向量，即<span class="math inline">\(w=[x,y,z]^T\)</span>。使用<span class="math inline">\(w\)</span>能够描述旋转刚体上任何点的速度，使用下图对应的公式描述，<span class="math inline">\(v=w\times p\)</span>，其中<span class="math inline">\(p\)</span>是位置向量，<span class="math inline">\(v\)</span>的方向可以用右手螺旋定则判断（Right screw rule，由四指向<span class="math inline">\(w\)</span>向<span class="math inline">\(p\)</span>方向握拳）。</p><p>  所谓的outer product或cross product满足： <span class="math display">\[w\times p=\begin{bmatrix}w_x \\ w_y \\ w_z\end{bmatrix} \times\begin{bmatrix}p_x \\ p_y \\ p_z\end{bmatrix} =\begin{bmatrix}w_yp_z-w_zp_y \\ w_zp_x-w_xp_z \\ w_xp_y-w_yp_x\end{bmatrix} \\\abs{v}=\abs{w}\abs{p}sin\theta \\(v\perp{w})\cap(v\perp{p})\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303141839733.png" alt="image-20220303141839733" style="zoom:67%;" /></p><p>  另外一种定义的方法是用旋转轴的单位向量<span class="math inline">\(a\)</span>，乘上旋转角速度幅值<span class="math inline">\(\dot{q}\)</span>： <span class="math display">\[\omega = a\dot{q}\]</span></p><h3 id="角速度向量omega的旋转">角速度向量<span class="math inline">\(\omega\)</span>的旋转</h3><p>  旋转矩阵对<span class="math inline">\(\omega\)</span>的操作可以理解为对旋转轴的单位向量<span class="math inline">\(a\)</span>的旋转，即<span class="math inline">\(\omega&#39;=R\omega=(Ra)\dot{q}\)</span>。</p><p>  关于<span class="math inline">\(R(w\times p)=(Rw)\times(Rp)\)</span>这个结论，我写作业的时候证明的太复杂了，其实是个很直观的原理。<strong>相当于三个向量同时进行了相同的旋转，即所在坐标系发生了旋转，因此等号保持不变</strong>。我自己的证明也在下面：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220303170425922.png" alt="image-20220303170425922" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/1ed0f2d4716220d13fc75fd041a2bb8.png" alt="1ed0f2d4716220d13fc75fd041a2bb8" style="zoom: 33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/f871343e1b880baa0f35e4c8925f9e1-16462987879351.png" alt="f871343e1b880baa0f35e4c8925f9e1" style="zoom: 33%;" /></p><h3 id="角速度的矩阵表示hatomega">角速度的矩阵表示<span class="math inline">\(\hat{\omega}\)</span></h3>  由上面矩阵导数的结果推导，得到角速度的反对称矩阵表示： <span class="math display">\[\begin{aligned}\dot{p}&amp;=\omega \times p \\&amp;=\begin{bmatrix}\omega_x \\ \omega_y\\ \omega_z\end{bmatrix}\times\begin{bmatrix}p_x \\ p_y\\ p_z\end{bmatrix}\\&amp;=\begin{bmatrix}\omega_yp_z-\omega_zp_y \\ \omega_zp_x-\omega_xp_z\\ \omega_xp_y-\omega_yp_x\end{bmatrix}\\&amp;=\begin{bmatrix}0 &amp; -\omega_z &amp; \omega_y \\\omega_z &amp; 0 &amp; -\omega_x \\-\omega_y &amp; \omega_x &amp; 0\end{bmatrix}\begin{bmatrix}p_x \\ p_y\\ p_z\end{bmatrix}\\&amp;=\hat{w}p\\&amp;=(\dot{R}R^T)p \\\Rightarrow \hat{w}&amp;=\dot{R}R^T\end{aligned}\]</span>   本书中角速度向量和反对称矩阵的notation为： $$<span class="math display">\[\begin{aligned}&amp;\begin{bmatrix}0 &amp; -\omega_z &amp; \omega_y \\\omega_z &amp; 0 &amp; -\omega_x \\-\omega_y &amp; \omega_x &amp; 0\end{bmatrix}^{\vee}=\begin{bmatrix}\omega_x \\ \omega_y\\ \omega_z\end{bmatrix} \\&amp;\begin{bmatrix}\omega_x \\ \omega_y\\ \omega_z\end{bmatrix}^{\wedge}= \begin{bmatrix}0 &amp; -\omega_z &amp; \omega_y \\\omega_z &amp; 0 &amp; -\omega_x \\-\omega_y &amp; \omega_x &amp; 0\end{bmatrix}\\&amp;\hat{\omega}=\dot{R}R^T\end{aligned}\]</span><p>$$</p><h3 id="rodrigues-formula">Rodrigues’ formula</h3><p>  上面的式子是从旋转矩阵得到角速度向量（矩阵），那么通过微分方程能够得到由角速度计算旋转矩阵的公式，使用指数函数的泰勒多项式展开得到Rodrigues’ formula。<strong>这个公式非常有用！</strong>下面是作业中的证明： <span class="math display">\[e^{\hat{a}\theta}=E+\hat{a}\sin\theta+\hat{a}^2(1-\cos\theta) \quad \theta\equiv \omega t\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402183133778.png" alt="image-20220402183133778" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402183250127.png" alt="image-20220402183250127" style="zoom:50%;" /></p><h3 id="矩阵对数">矩阵对数</h3><p>  由上面得出的旋转矩阵指数表示法，经过一系列推导，得到用<span class="math inline">\(R\)</span>求解<span class="math inline">\(\hat{a}\)</span>的公式： <span class="math display">\[\begin{aligned}\ln R&amp;=\ln e^{\hat{\omega}}\equiv\hat{\omega}\\\omega&amp;=(\ln R)^{\vee}\\(\ln R)^{\vee}&amp;=\left\{\begin{aligned}&amp;\begin{bmatrix}0 &amp; 0 &amp; 0\end{bmatrix}^{T}  \quad \mbox{(if R=E)}\\&amp;\frac{\pi}{2}\begin{bmatrix}r_{11}+1 \\ r_{22}+1 \\ r_{33}+1\end{bmatrix}^{T}  \quad \mbox{(else if R is diagonal)}\\&amp;\theta\frac{l}{||l||} \quad \mbox{(otherwise)}\\\end{aligned}\right.\\\\R &amp;=\begin{bmatrix}r_{11} &amp; r_{12} &amp; r_{13}\\r_{21} &amp; r_{22} &amp; r_{23}\\r_{31} &amp; r_{32} &amp; r_{33}\\\end{bmatrix}\\l &amp;=\begin{bmatrix}r_{32} - r_{23} \\r_{13} - r_{31} \\r_{21} - r_{12} \\\end{bmatrix}\\\theta &amp;=\atan2(||l||, r{11}+r{22}+r{33}-1)\end{aligned}\]</span>   但是根据Kevin的《现代机器人学》这本书的内容，这里的公式推导好像有点问题：首先，当<span class="math inline">\(R=E\)</span>时，角速度不是0而是未定义的（好像问题不大）；其次，这个“R is diagonal“（这里好像是代入<span class="math inline">\(\theta=\frac{\pi}{2}...\)</span>）的情况好像没有推导的必要，因为通解的特殊情况是<span class="math inline">\(\sin\theta=0\)</span>。我自己推导了一部分放在下面，另外可以参考原书的推导：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220402233735396.png" alt="image-20220402233735396" style="zoom:50%;" /></p><div class="row">    <embed src="https://github.com/Judera9/Pictures-for-Blogs/blob/main/file/%E7%9F%A9%E9%98%B5%E5%AF%B9%E6%95%B0%E6%8E%A8%E5%AF%BC.pdf" width="100%" height="550" type="application/pdf"></div><p>  矩阵对数能够实现在两个旋转矩阵<span class="math inline">\(R_1,R_2\)</span>之间插值，下面用python对该算法进行验证： <span class="math display">\[\begin{aligned}\mbox{Get the rotation matrix which links the two matrices: } &amp;R =R_1^TR_2\\\mbox{Get the equivalent angular velocity vector from this rotation matrix: } &amp;\omega=(\ln R)^{\vee}\\\mbox{The angular velocity vector in world coordinates is: } &amp;R_1\omega\\\mbox{The interpolation becomes: } &amp;R(t)=R_1e^{\hat{\omega}t}\\\end{aligned}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.linalg <span class="hljs-keyword">import</span> expm, logm<br><br><span class="hljs-comment">#1. Generate test R1, R2, example array</span><br><br>R1 = np.array([<br>    [np.sin(<span class="hljs-number">2</span>), np.cos(<span class="hljs-number">2</span>), <span class="hljs-number">0</span>],<br>    [np.cos(<span class="hljs-number">2</span>), -np.sin(<span class="hljs-number">2</span>), <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>])<br><br>R2 = np.array([<br>    [-np.sin(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>, np.cos(<span class="hljs-number">3</span>)],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [np.cos(<span class="hljs-number">3</span>), <span class="hljs-number">0</span>, np.sin(<span class="hljs-number">3</span>)]])<br><br>test_arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><br><span class="hljs-comment">#2. Find omega by matrix logarithm algorithm</span><br><br>R = R1.T @ R2<br>l = np.array([[R[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] - R[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]],<br>              [R[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] - R[<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]],<br>              [R[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] - R[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]])<br>norm_l = np.linalg.norm(l)<br>theta = np.arctan2(norm_l, R[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] + R[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] + R[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] - <span class="hljs-number">1</span>)<br>omega = theta * l / norm_l <span class="hljs-comment"># equ to: (R - R.T) / (2 * np.sin(theta)) * theta</span><br><br>np.set_printoptions(precision=<span class="hljs-number">3</span>)<br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(omega.ravel()) <span class="hljs-comment"># [-1.828  0.399  2.108]</span><br><br><span class="hljs-comment">#3. Check result with scipy.logm</span><br><br>np.set_printoptions(precision=<span class="hljs-number">3</span>)<br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><br>omega_m = logm(R)<br><span class="hljs-built_in">print</span>(omega_m)<br><span class="hljs-comment"># [[ 0.    -2.108  0.399]</span><br><span class="hljs-comment">#  [ 2.108 -0.     1.828]</span><br><span class="hljs-comment">#  [-0.399 -1.828  0.   ]]</span><br><br><span class="hljs-comment">#4. Test the given array for interpolation</span><br><br>np.set_printoptions(precision=<span class="hljs-number">3</span>)<br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><br>test1 = R1 @ test_arr.T<br>test2 = R2 @ test_arr.T<br><br><span class="hljs-built_in">print</span>(test1.ravel())<br><span class="hljs-built_in">print</span>(test2.ravel())<br><span class="hljs-comment"># [ 0.493 -1.325  0.   ]</span><br><span class="hljs-comment"># [-0.141  1.    -0.99 ]</span><br><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>):<br>    interp_R = R1 @ (expm(omega_m * t/<span class="hljs-number">10</span>))<br>    <span class="hljs-built_in">print</span>((interp_R @ test_arr.T).ravel())<br><span class="hljs-comment"># [ 0.493 -1.325  0.   ]</span><br><span class="hljs-comment"># [ 0.211 -1.379 -0.235]</span><br><span class="hljs-comment"># [-0.062 -1.329 -0.481]</span><br><span class="hljs-comment"># [-0.304 -1.179 -0.719]</span><br><span class="hljs-comment"># [-0.496 -0.943 -0.93 ]</span><br><span class="hljs-comment"># [-0.623 -0.637 -1.098]</span><br><span class="hljs-comment"># [-0.675 -0.287 -1.209]</span><br><span class="hljs-comment"># [-0.647  0.08  -1.255]</span><br><span class="hljs-comment"># [-0.543  0.435 -1.231]</span><br><span class="hljs-comment"># [-0.369  0.75  -1.141]</span><br><span class="hljs-comment"># [-0.141  1.    -0.99 ]</span><br></code></pre></td></tr></table></figure><h2 id="d运动描述">3D运动描述</h2><h3 id="速度与角速度">速度与角速度</h3><p>  其实是在上面旋转矩阵的基础上，添加了平动向量，将矩阵扩充为<span class="math inline">\(rank(4)\)</span>的齐次矩阵。<strong>一对<span class="math inline">\((p,R)\)</span>可以看作一个与物体绑定的local coordinate与世界坐标系的变换关系</strong>，下面是三维运动公式： <span class="math display">\[\begin{aligned}p_k &amp;=p+R\overline{p}_k \\\dot{p}_k &amp;=\dot{p}+\dot{R}\overline{p}_k \\&amp;= v + \hat{\omega}R\overline{p}_k \\&amp;=v+\omega\times(p_k - p) \\\\v &amp;\equiv\dot{p} \\\omega &amp;\equiv(\dot{R}R^T)^{\vee} \\R\overline{p}_k &amp;\equiv (p_k - p)\end{aligned}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220403115542777.png" alt="image-20220403115542777" style="zoom:33%;" /></p><h3 id="多物体速度与角速度变换">多物体速度与角速度变换</h3><p><span class="math display">\[\begin{aligned}\mbox{Given:}&amp;\\T_1 &amp;= \begin{bmatrix}R_1 &amp; p_1 \\0 \ 0 \ 0 &amp; 1\end{bmatrix} \\^{1}T_2 &amp;= \begin{bmatrix}R_d &amp; p_d \\0 \ 0 \ 0 &amp; 1\end{bmatrix} \\\Rightarrow T_2 &amp;=T_1 \ ^{1}T_2 \\&amp;=\begin{bmatrix}(R_1R_d) &amp; (p_1+R_1p_d) \\0 \ 0 \ 0 &amp; 1\end{bmatrix} \\\\\Rightarrow p_2 &amp;=p_1 + R_1p_d \\R_2 &amp;= R_1R_d\\\\\mbox{Find velocity of object 2:}&amp;\\v_2 &amp;= \frac{d}{dt}(p_1+R_1p_d)\\&amp;=\dot{p}_+\dot{R}_1p_d+R_1\dot{p}_d \\&amp;=v_1 + \omega_1\times (p_2 - p_1) + R_1v_d \\\\\mbox{Find angular velocity:}\\\hat{\omega}_2 &amp;= \dot{R}_2R_2^T \\&amp;= \frac{d}{dt}(R_1R_d)R_2^T \\&amp;= (\dot{R}_1R_d+ R_1\dot{R}_d)R_2^T \\&amp;=(\hat{\omega}_1R_1R_d+R_1\hat{\omega}_dR_d)R_2^T \\&amp;= \hat{\omega}_1 + R_1\hat{\omega}_dR_1^T \\&amp;= \hat{\omega}_1 + (R_1\hat{\omega}_d)^{\wedge} \\(\hat{\omega}_2)^{\vee} &amp;= (\hat{\omega}_1 + (R_1\hat{\omega}_d)^{\wedge})^{\vee}\\\\\Rightarrow \omega_2 &amp;= \omega_1 + R_1\omega_d\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>Walking Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标系变换</tag>
      
      <tag>旋转矩阵</tag>
      
      <tag>欧拉角</tag>
      
      <tag>角速度向量</tag>
      
      <tag>控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带传动选型笔记</title>
    <link href="/2022/06/12/2022-06-12-belt-design-process/"/>
    <url>/2022/06/12/2022-06-12-belt-design-process/</url>
    
    <content type="html"><![CDATA[<p>参考<a href="https://www.bilibili.com/video/BV1FW41127QB?p=34">机械设计课程视频</a>，对应<a href="https://github.com/Judera9/Pictures-for-Blogs/blob/main/file/%E6%9C%BA%E6%A2%B0%E8%AE%BE%E8%AE%A1%E5%B8%A6%E4%BC%A0%E5%8A%A8.pdf">课本143-164</a></p><span id="more"></span><h2 id="带传动类型">带传动类型</h2><h3 id="摩擦型带传动">摩擦型带传动</h3><p>  该带传动的工作原理是<strong>摩擦力</strong>， 为了产生摩擦需要将同步带与轮子之间有正压力。但<strong>“只要靠摩擦力工作都不可靠”</strong>，所以通过V带传动能够增加带的侧面和轮槽侧面的正压力，如下图1右侧。下面是带传动的一些特点：</p><ol type="1"><li><strong>传动平稳</strong>：在主动轴上的运动不平稳不会传动到从动轴上，与齿轮不同，弹性的同步带能够抵消运动的不平稳</li><li><strong>过载打滑</strong>：类比车在泥泞路上打滑，过载打滑有好有坏。好处是有过载保护的效果，能够保护从动轴后续零件的；坏处是传动失效了，属于“丧失了正常工作条件”的失效形式</li><li><strong>传动中心距大</strong>：优点是相对齿轮而言，主动轮和从动轮之间的距离能够相当大；缺点是距离太远，传动过程缓慢（呈波浪形传动）</li><li><strong>结构简单</strong>：所以成本低，安装维护简单</li><li><strong>传动比不准确</strong>：因为是靠摩擦工作的，所以瞬时传动比不准确</li><li><strong>需要张紧</strong>：需要拉紧来提供正压力</li><li><strong>轴上受力大</strong>：由于主动轮与从动轮拉紧，两轮之间的连轴承受较大的力。对轮上的轴承的要求较高，并且轴可能会弯曲</li><li><strong>安装精度不高</strong>：安装时一般通过将中心距拉大来张紧，安装精度不高，因此对制造要求不高</li><li><strong>急速、反向转动性能差，不适合在高转速下使用</strong></li></ol><h3 id="同步带传动">同步带传动</h3><p>  靠如下图2所示的齿啮合传动，不再靠摩擦力，因此可靠性更好。部分特点与摩擦性带传动一致，下面是相对于摩擦型带传动，同步带的优点：<strong>承载能力高、传动比准确、效率高</strong></p><h3 id="v带的类型与结构">V带的类型与结构</h3><p>  带是标准件，可以直接买到特定型号的带。V带的类型可以根据结构类型区分，有帘布结构和绳芯结构，如下图3。虽然V带形状上宽下窄，但是在拉紧之后，上侧实际上收到较大的拉力而宽度减小，下侧受到挤压宽度变大，因此V带侧面不再平齐的直线。据谭老师说，日本有一种在V带基础上将下侧做成弧线的窄V带，能够在拉紧后侧面呈直线，如图3右侧。<strong>普通V带型号为：Y、Z、A、B、C、D、E，对应的宽度（截面积）依次递增</strong>，如下图4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220401160508902.png" alt="image-20220401160508902" style="zoom: 33%;" /></p><h2 id="带传动受力分析">带传动受力分析</h2><p>  如下图1，假设带的初始拉力为<span class="math inline">\(F_0\)</span>，现在让带顺时针转动。<strong>下侧带扩张的量等比于<span class="math inline">\(F_1-F_0\)</span>，同理上侧缩紧带的量等比于<span class="math inline">\(F_0-F_2\)</span>，因此得到<span class="math inline">\(2F_0=F_1 - F_2\)</span></strong>。分别将小带轮和小带轮上的带单独分析，得到下面两个平衡方程， 其中<strong><span class="math inline">\(F_e=F_1-F_2\)</span>称有效拉力</strong>。当<span class="math inline">\(\frac{2T}{d}&gt;F_f\)</span>时带会打滑： <span class="math display">\[\begin{aligned}F_1 -F_2 &amp;= \frac{2T}{d} \\F_1 - F_2 &amp;= F_f\end{aligned}\]</span>   另外，带传动有两个固有的缺点，如图2：</p><ol type="1"><li><p>由于上下两侧的拉力不等，因此在轮子处会产生力的过渡，发生弹性滑动，导致传动比不准确</p></li><li><p>在小带轮处带收缩，在大带轮处带扩展，因此带与轮间产生滑动摩擦力，会损坏带表面</p></li></ol><p>  带传动功率的公式为： <span class="math display">\[P=\frac{F_ev}{1000}kW\]</span>   由图3中的推导得到<strong>柔韧体的欧拉公式</strong>，反应极限状态（即将打滑）下<span class="math inline">\(F_1, F_2\)</span>的比值。这个公式非常有用，对于类似的机构都能使用。将该公式带入有效拉力的公式和<span class="math inline">\(F_0\)</span>的公式，得到最大有效圆周力<span class="math inline">\(F_{ec}\)</span>的公式，该公式的影响因素是：</p><ol type="1"><li>初拉力<span class="math inline">\(F_0\)</span></li><li>包角<span class="math inline">\(\alpha (&gt;120°)\)</span></li><li>摩擦系数<span class="math inline">\(f_v\)</span>，在图4推导了<span class="math inline">\(f_v\)</span>与原始摩擦系数<span class="math inline">\(f\)</span>的关系</li></ol><p><span class="math display">\[\begin{aligned}F_1 &amp;=F_2e^{f_v\alpha}\\&amp;\mbox{substitute back into:} \\&amp;\left\{\begin{aligned}F_e &amp;= F_1-F_2 \\2F_0 &amp;= F_1 + F_2\end{aligned}\right.\Rightarrow F_{ec}=2F_0\frac{e^{f_va}-1}{e^{f_va}+1}\end{aligned}\]</span></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220401184146954.png" alt="image-20220401184146954" style="zoom: 33%;" /></p><h2 id="带的应力分析">带的应力分析</h2><h3 id="拉应力与弯曲应力">拉应力与弯曲应力</h3><p>  分析带在初始拉力、紧边松边拉力、高速旋转的离心力等力的作用下，对带的疲劳强度的影响，即分析受到的应力。拉应力较好理解，弯曲应力可以直接从材料力学弯曲的公式近似推导得到。<strong>从公式看出，小带轮直径小<span class="math inline">\(D_1&lt;D_2\)</span>，因此小带轮上的弯曲应力大<span class="math inline">\(\sigma_{b1}&gt;\sigma_{b2}\)</span>。为了避免弯曲应力过大，应该限定<span class="math inline">\(D_1 \geq D_{min}\)</span></strong>： <span class="math display">\[\begin{aligned}\mbox{拉应力: }&amp;\\\sigma_1&amp;=\frac{F_1}{A}\\\sigma_2&amp;=\frac{F_2}{A}\\\mbox{弯曲应力: }&amp;\\\sigma_b&amp;=E\frac{h}{D}\\\end{aligned}\]</span>   在选型中，V带轮的最小基准直径<span class="math inline">\(D_{min}\)</span>是重要的指标之一，对于不同型号的V带该指标是不同的，如下表所示。出现该现象的原因是：<strong>随着截面尺寸增大，如果不增大小带轮的直径，那么由于过大的弯曲应力会自身消耗掉传动的力，传动能力无法提升</strong>。</p><table><colgroup><col style="width: 10%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th>槽型</th><th>Z (SPZ)</th><th>A (SPA)</th><th>B (SPB)</th><th>C (SPC)</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(D_{min}\)</span></td><td>63 (<span class="math inline">\(\geq\)</span> 50)</td><td>90 (<span class="math inline">\(\geq\)</span> 75)</td><td>140 (<span class="math inline">\(\geq\)</span> 125)</td><td>224 (<span class="math inline">\(\geq\)</span> 200)</td><td><span class="math inline">\(\geq\)</span> 355</td><td><span class="math inline">\(\geq\)</span> 500</td></tr></tbody></table><h3 id="离心应力">离心应力</h3><p>  离心应力<span class="math inline">\(F_c\)</span>的产生原因是为了阻止轮上的一段带因离心力作用而飞出去，如下图。<strong>为了避免离心应力过大，需要限制带的传动速度</strong>。但是速度也不能太低，由前面带传动的功率公式，速度过低会导致传动效率很差。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220401194725038.png" alt="image-20220401194725038" style="zoom: 20%;" /></p><h3 id="综合应力分析">综合应力分析</h3><p>  由下图所示，<strong>应力之和的最大值在紧边与小带轮相切位置发生</strong>，符合我们的直观认知。带传动过程中，应力是在不断变化的，因此长期使用的带断裂通常是由于疲劳导致的。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220401194318222.png" alt="image-20220401194318222" style="zoom:25%;" /></p><h2 id="带传动的失效形式">带传动的失效形式</h2><h3 id="弹性滑动与打滑">弹性滑动与打滑</h3><p>  如下图1所示，以小带轮为例：弹性滑动是由于受拉力不均匀导致带发生延红色箭头方向的收缩，<strong>当所有与小带轮接触的部分均发生弹性滑动时，即发生打滑现象</strong>。发生打滑后，上下两侧的速度不等，<span class="math inline">\(v_2&lt;v_1\)</span>，因此用速度表征滑动率<span class="math inline">\(\varepsilon\)</span>。带传动的准确传动比<span class="math inline">\(i\)</span>与<span class="math inline">\(\varepsilon\)</span>有关，不是常数： <span class="math display">\[\begin{aligned}\varepsilon&amp;=\frac{v_1-v_2}{v_1}\\v&amp;=\frac{\pi Dn}{60\times 1000} (?)\\i&amp;=\frac{n_1}{n_2}=\frac{D_2}{D_1(1-\varepsilon)}\neq C\end{aligned}\]</span>   从传动比公式可以看出，实际的传动比与上下 侧速度差值有关，而后者又与带上拉力的差值有关，拉力差值与负载有关，因此得出：<strong>打滑的根本原因是负载太大</strong>。图2为弹性滑动曲线，可以看到，<strong>当发生打滑时，滑动率迅速上升，传动效率迅速下降，此时发生失效</strong>。对于弹性滑动区，传动比可以近似为<span class="math inline">\(i=\frac{n_1}{n_2}\approx \frac{D_2}{D_1}\)</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220401210947700.png" alt="image-20220401210947700" style="zoom:33%;" /></p><h2 id="带传动的设计">带传动的设计</h2><h3 id="设计依据">设计依据</h3><blockquote><p>在机械设计中，有一个不变的条件就是在设计任何机械零件时都是遵循一个固定的模式。首先分析失效形式，然后分析失效的原因，根据失效原因制定设计准则，根据准则来设计零件。</p></blockquote><p>  <strong>对于带传动，失效形式主要是疲劳和打滑</strong>，因此设计准则为：<strong>保证带传动不打滑，并使胶带有一定的疲劳强度和寿命</strong>。如何使该准则有可操作性？首先回顾最大有效圆周力的公式，然后于疲劳强度的公式结合，得到额定功率<span class="math inline">\(P_0\)</span>的公式： <span class="math display">\[\begin{aligned}\mbox{保证不打滑条件: }&amp; F_{ec}=2F_0\frac{e^{f_va}-1}{e^{f_va}+1}\to \sigma_1A(1-\frac{1}{e^{f_va}})\\\mbox{保证V带有一定疲劳强度条件: }&amp; \sigma_1\leq[\sigma]-\sigma_{b1}-\sigma_c\\\Rightarrow P_0&amp;=\frac{F_{ec}v}{1000}=\frac{([\sigma]-\sigma_{b1}-\sigma_c)(1-\frac{1}{e^{f_va}})Av}{1000}\end{aligned}\]</span>   但是注意到，该公式与小带轮的弯曲应力<span class="math inline">\(\sigma_{b1}\)</span>、离心应力<span class="math inline">\(\sigma_c\)</span>、包角<span class="math inline">\(\alpha\)</span>有关，这些量与实际设计的指标有关，因此我们先以一个主从动轮等大的特例开始进行计算，该特例的<span class="math inline">\(P_0\)</span>为基本额定功率。<strong>简而言之，因为该公式中，包角<span class="math inline">\(\alpha\)</span>与两轮直径和中心距有关，较为复杂，因此我们通过计算该特例的结果作为参考来进行设计，后续可以进行修正。</strong></p><p>  参数选择和设计计算：</p><ol type="1"><li><strong>已知条件</strong>：转递功率P、转速（传动比）<span class="math inline">\(n_1,n_2\)</span>、传动位置要求、工作条件等</li><li><strong>设计内容</strong>：确定带的型号、长度、根数、传动中心距、带轮直径、结构尺寸等</li></ol><h3 id="设计步骤">设计步骤</h3><ol type="1"><li><strong>确定设计功率（工况系数）</strong>，<span class="math inline">\(P_d=K_AP\)</span></li><li><strong>选择带的型号</strong>，按<span class="math inline">\(P_d,n_1\)</span>由选型图选择合适的型号，参考下图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220403164735436.png" alt="image-20220403164735436" style="zoom:50%;" /></p><ol start="3" type="1"><li><p><strong>选定带轮的基准直径<span class="math inline">\(D_1, D_2\)</span></strong>，为避免弯曲应力过大，应使<span class="math inline">\(D_1\geq D_{min}\)</span>。为避免离心应力过大，应使<span class="math inline">\(v=\frac{\pi D_1 n_1}{60\times 1000} \leq v_{max}\)</span>，一般应使<span class="math inline">\(v=5-25m/s\)</span></p></li><li><p><strong>确定中心距<span class="math inline">\(a\)</span>和带长<span class="math inline">\(L_d\)</span></strong>，<span class="math inline">\(0.7(D_1+D_2)\leq a_0\leq 2(D_1+D_2)\)</span>；如果<span class="math inline">\(a\)</span>过小，则包角<span class="math inline">\(\alpha_1\)</span>小，如果<span class="math inline">\(a\)</span>过大，则产生颤动；然后计算带长，<span class="math inline">\(L&#39;_d=2a_0+\frac{\pi}{2}(d_1+d_2)+\frac{(d_2-d_1)^2}{4a_0}\)</span></p></li><li><p><strong>验算小带轮包角<span class="math inline">\(\alpha_1\)</span></strong>，要求<span class="math inline">\(\alpha_1= 180-\frac{D_2-D_1}{a}\times 57.3° \geq 120°\)</span>，如果不满足，可加大中心距或加张紧轮</p></li><li><p><strong>确定带的根数<span class="math inline">\(Z\)</span></strong>，<span class="math inline">\(z=\frac{P_d}{(P_0+\Delta P_0)K_{\alpha}K_L}\)</span>，其中<span class="math inline">\(P_0\)</span>是之前计算的基本额定功率，我们在这里需要考虑实际情况与特殊情况（两轮直径等大）的区别，然后进行补偿</p></li><li><p><strong>确定初拉力<span class="math inline">\(F_0\)</span></strong>，<span class="math inline">\(F_0=500\frac{P_d}{zv}(\frac{2.5}{K_{\alpha}}-1)+qv^2\)</span></p></li><li><p><strong>确定压轴力<span class="math inline">\(F_Q\)</span></strong>，<span class="math inline">\(F_Q=2zF_0sin(\alpha_1/2)\)</span>，这个力很大，因此需要防止轴弯曲；可以参考一下卸载带轮，是一种能够解决这个问题的结构，将力传到机体上</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>机械设计基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械设计</tag>
      
      <tag>带传动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花束般的恋爱观后感</title>
    <link href="/2022/06/12/2022-06-12-hanakaba-mitaina-koi-o-shita/"/>
    <url>/2022/06/12/2022-06-12-hanakaba-mitaina-koi-o-shita/</url>
    
    <content type="html"><![CDATA[<p>  可惜没有妹子陪我看，是和韶哥一起去看的这部电影。他评价是：这部电影确实好看，日本じん很会讲这种很普通简单而注重细节、让人感动的恋爱故事，包括日本的小说和电影都是如此。正确的，中肯的！然后我也去看了他推荐的另一部，叫情书，b站可以看，也挺好看的（不过个人更喜欢花束般的恋爱）。</p><p>  电影开场和结尾的设计就很别出心裁（日本动画和电影都蛮喜欢插叙倒叙的方式诶）。电影开场时，镜头是主角二人给自己对象介绍关于“和情侣共用一对耳机听音乐是对音乐人不尊重”这样的冷知识，镜头的切换很有意思。然后两人准备上前去和那对秀恩爱的情侣说明这个道理，这时两人互相发现了对方，并且当场尬住。我在看的时候，就有隐约察觉到雰囲気不太对劲了，两人感觉像是认识对方的，然后两人都是同一类人，结果在最后结尾的时候果然如此！直接首尾呼应，最后的挥手告别直接把全剧拉高一个档次！</p><p>  中间的剧情倒是很常规的爱情故事，俩人巧遇并发现和对方很谈得来，然后就开始谈恋爱。絹ちゃん和麦君两个人都是爱好音乐、文学和艺术的大好文艺青年，并且有着非常相似的爱好与价值观。偶然的巧遇让两者接触了彼此，然后相互倾心陷入爱河。中间也有些情侣间的小插曲啦，比如不好意思告白，想要创造romantic的空气啦，blablabla。总而言之，两人在相遇时好感度就是满的，属于是一见倾心了。这样的爱情故事就直接从“高潮”开始了。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/p2625028954.webp" alt="img" style="zoom:50%;" /></p><p>  随着时间流逝，两人经历了同居、毕业、求职、父母探访等等，仍然尽力维持着一种非常理想的相互包容和理解的状态。但日本也是一个高压社会，光有理想没有机遇和才能是很难在一个领域作出成就的。两人虽然喜欢各种文学艺术啦，漫画游戏啦，但终究没能在喜欢的领域作出成绩，而是不得已做着自己不喜欢的、“谁都能做”的工作。大好文艺青年开始遭受社会毒打，认清现实。随着父母的压力、工作的压力，两人的交流慢慢减少了，吵架开始增加了，无非就是一些鸡毛蒜皮的小事也能产生矛盾和分歧，和之前相互之间如心灵相通的场景形成了巨大的反差。逐渐地，狭小的公寓内仿佛有一道厚重的墙，两人之间的喜悦与悲伤也不能相互分享，沉默侵蚀了大部分相处的时间。</p><p>  这时候，两人的感情已经走到了尽头。最终在一个恰当的时机，两人决定和平分手了。在熟悉的餐馆里，麦君还想挽救一下，提出了“不如结婚吧”的建议。恋爱和结婚也是这部电影的核心主题之一，我认为电影的线索铺垫，与矛盾最终的爆发都在这一段对话中了。男主的建议很有道理，我感觉找不出任何问题，两人5年的同居生活已经有了深厚的感情积累，如果结婚生子的话，也有一个强烈的bonding在两人中间，也许确实会吵架，会沉默，会缺乏交流，但是能“磕磕绊绊”的活着，成为别人眼中的恩爱夫妻吧！现实中很多人也都是这么想的吧！但如果在这里两者结婚了的话，在我眼中这就是平庸之作或是粪作，因为这个故事里已经没有爱情存在了。</p><p>  这时候他们看到了“从前的他们”，是一对和他们五年前一样的情侣，坐在相同的位置。最终他们还是分手了，我感觉，原因是他们终究不想背叛原来的那段感情吧，也可能是他们仍然想去相信爱情，所以没有选择结婚（爱情战胜了生活），而是选择了分手。我不知道这种时候观众是应该欣慰还是可惜，你们看到这是什么感受呢？最后男主又在Google地图上看到俩人照片的时候，真的有种莫名的感动欸，虽然觉得可惜，但也不后悔的这种感觉。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/p2617652208.webp" alt="img" style="zoom:50%;" /></p><p>  回到两人刚开始认识的时候，有一个插曲讲絹ちゃん喜欢的一个博主因为对爱情失望而自杀。然后有一段是絹说“如果把这种花的名字告诉了男朋友，以后他每次看见这种花都会想起那个女孩”，然后到电影结束，麦君也不知道这种花的名字。我想，絹当时也是不想以后分手了麦会天天想到他或甚至对爱情绝望吧。</p><p>  总而言之，从这部爱情电影中，能够很明显的感觉到日本那种物哀和朦胧的美学，但同时也能感受到现实社会与个人理想的冲突。虽然这部电影其实也存在一些问题和槽点啦。比如说女主和社长疑似出轨的剧情感觉有点狗血，父亲对男主直接断了生活费也有点过于冷血，男主和女主本身家庭背景差距很大带来对工作认知上的差距，以及讨论男主和女主谁对谁错之类的，不过分析这些我感觉意义不大。最关键是，它讲了一个好故事，也确实的带来了感动与淡淡的忧愁，甚至能学到一些小小的人生道理。これで十分です！</p><p>  现在的作品总是喜欢玩一些烂俗的套路、换汤不换药的设定，但是从根本上没有讲好一个故事，要么虎头蛇尾，要么玩脱了给冲烂，要么过于注重设定和大局而忽略了人物的心理和现实。现在蛮多异世界穿越的轻小说和番，但我只觉得《无职转生》有在注意将前世的人和转生的人进行讨论，描绘了一个前世的人渣在转生后希望救赎自己的故事，而不是单纯的异世界开挂。因此我现在对一部作品的要求不高，只要能够好好的讲完一个完整的故事就行。</p><p>  写到这里有感而发，想谈谈自己的事。</p><p>  我初中的时候也有点这种文青的感觉，很喜欢看各种散文和小说，然后玩玩音乐。然后高考和大学都一直没有时间，然后就寄了，成了纯纯傻叼工科男。。不过以这部电影为由，感觉想捡回原来一些文艺方面的爱好和看书的习惯了！肯定不是羡慕用丰富的文艺爱好找到npy的主角啦，绝对不是！不过不尬黑，感觉国内现在没找到什么喜欢的文字，音乐界这几年就更拉垮了。感觉全是恶劣低俗的网络环境和走偏的大众品味导致的，毫无深度的网剧和综艺也充斥各个平台。哎~</p><p>  另外是关于恋爱观，想起来高中的时候，有一次辩论赛的主题是“你会选择喜欢你的人，还是你喜欢的人”。我们班被分到的观点是“选择喜欢你的人”。但是那场辩论其实我都不知道说啥，因为从我的爱情观看，我不会选择我不是那么喜欢的人，也不相信什么“以后慢慢培养感情”，也不想抱着“高中就试试看谈恋爱啦”这样的心态去拍拖。如果不是那种我觉得我应该会喜欢一辈子、能包容她所有缺点的人，我是不会去表白的。因为我觉得这样才对得起对方。主要还是讨厌偽物和演戏，究竟是春物看多了还是伪物看多了呢（暴论）。大学的时候，也曾想抱着“试试看”的心态去谈个恋爱，但到了后来感觉自己和对方不合拍，也就当即退出了。可能我这种人对自己和对象的要求都太高了，活该单身一辈子吧。</p><p>  最后，电影的剧情、叙事，音乐，演员都很棒，管田和有村演这种文艺青年都演得蛮到位的！我们是在东门那边深圳戏院看的，后来和韶哥去旁边恰了个日式拉面。味道还不戳，咸度有点高了。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/others/image-20220612205147400.png" alt="image-20220612205147400" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>历史社会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧</tag>
      
      <tag>逆向歧视</tag>
      
      <tag>男性凝视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一维快速傅里叶变换</title>
    <link href="/2022/06/12/2022-06-12-FFT-description-and-code/"/>
    <url>/2022/06/12/2022-06-12-FFT-description-and-code/</url>
    
    <content type="html"><![CDATA[<p>在b站上学习FFT，这个算法在工业界用的还是比较多的，打算好好学然后自己用python实现。顺便DIP的lab在频率域处理时也用到这个函数，二维FFT其实就是按照行列分别一维FFT。</p><span id="more"></span><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=203048598&bvid=BV1za411F76U&cid=262835785&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><p>  上面这个视频虽然挺长，但看下来感觉对FFT讲的还是比较透彻滴。下面是自己看下来记的笔记，以及python实现算法。（btw，发现现在挺多这种数学科普视频用的3Blue1Grown开源的图形工具hhh，只能说大佬牛逼</p><h2 id="公式推导">公式推导</h2><p>  简单的概括FFT到底做了什么，<strong>首先去理解DFT在做什么，然后FFT就是通过巧妙利用对称性，使用分治递归的方法，将复杂度从<span class="math inline">\(O(N^2)\)</span>降低到<span class="math inline">\(O(NlogN)\)</span></strong>。下面的公式是从上面视频中截图的，简单说明一下：视频讲解FFT算法的例子是多项式乘法问题，而这里的<span class="math inline">\(Coeff\)</span>可以理解为时域维度的数值，而<span class="math inline">\(Value\)</span>可以理解为频域维度的数值，因此<span class="math inline">\(Coeff \Rightarrow Value\)</span>对应FFT。这些点不是乱找的，我们通过奇函数和偶函数的对称性，只需要找一半的点，这就是分治的来源。<strong>这种对称性只在实数域是无法实现的，因此引入复数和欧拉公式</strong>。</p><p>  最后是快速傅里叶的逆变换，在FFT基础上简单改一下就完成了，某种程度上变换对也具有对称性。但是视频中的推导有问题，使用Python实验的时候发现用<strong>视频中的IFFT伪代码结果是错的</strong>，正确的代码在下面具体实现中给出。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220326204043965.png" alt="image-20220326204043965" style="zoom:46%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220326205109943.png" alt="image-20220326205109943" style="zoom:46%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220326182747096.png" alt="image-20220326182747096" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220326205317768.png" alt="image-20220326205317768" style="zoom:46%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/image-20220326225853999.png" alt="image-20220326225853999" style="zoom:50%;" /></p><h2 id="代码实现">代码实现</h2><h3 id="伪代码">伪代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">// pseudocode from the video<br>def FFT(P):<br>n=len(P) // n is a power of 2<br>if n == 1:<br>return P<br>w = e^(2*pi*i/n)<br>Pe, Po = [p0, p2,...,p_&#123;n-2&#125;], [p1, p3,...,p_&#123;n-1&#125;] // arr[::2], arr[1::2]<br>ye, yo = FFT(Pe), FFT(Po)<br>y = zeros(n)<br>for j in range(n/2):<br>y[j] = ye[j] + w^j * yo[j]<br>y[j+n/2] = ye[j] - w^j * yo[j]<br>return y<br><br>def IFFT(P):<br>n=len(P)<br>if n == 1:<br>return P<br>w = e^(2*pi*i/n)<br>Pe, Po = [p0, p2,...,p_&#123;n-2&#125;], [p1, p3,...,p_&#123;n-1&#125;]<br>ye, yo = IFFT(Pe), IFFT(Po)<br>y = zeros(n)<br>for j in range(n/2):<br>y[j] = ye[j] + w^j * yo[j]<br>y[j+n/2] = ye[j] - w^j * yo[j]<br>return y / 2<br></code></pre></td></tr></table></figure><h3 id="fft-python">FFT Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fft_recursive</span>(<span class="hljs-params">arr</span>):</span><br>    n_len = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">assert</span> n_len &amp; (n_len - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>  <span class="hljs-comment"># n is a power of 2</span><br>    <span class="hljs-keyword">if</span> n_len == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    Pe, Po = arr[::<span class="hljs-number">2</span>], arr[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>    ye, yo = fft_recursive(Pe), fft_recursive(Po)<br>    n = np.arange(n_len // <span class="hljs-number">2</span>, dtype=<span class="hljs-built_in">int</span>)<br>    w = np.power(np.exp(<span class="hljs-number">2</span> * np.pi * <span class="hljs-number">1j</span> / n_len), n)<br>    y = np.zeros(n_len, dtype=<span class="hljs-built_in">complex</span>)<br>    y[:n_len // <span class="hljs-number">2</span>] = ye + w * yo<br>    y[n_len // <span class="hljs-number">2</span>:] = ye - w * yo<br>    <span class="hljs-keyword">return</span> y<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dft_matrix</span>(<span class="hljs-params">n_size</span>):</span><br>    n = np.arange(n_size).reshape(<span class="hljs-number">1</span>, n_size)<br>    m = np.arange(n_size).reshape(<span class="hljs-number">1</span>, n_size)<br>    idx_Mat = n.T @ m<br>    <span class="hljs-keyword">return</span> np.power(np.exp(<span class="hljs-number">2</span> * np.pi * <span class="hljs-number">1j</span> / n_size), idx_Mat)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fft_shift</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> np.r_[arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>:], arr[:<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fft</span>(<span class="hljs-params">arr, method=<span class="hljs-string">&#x27;smart&#x27;</span>, shift=<span class="hljs-literal">False</span>, return_real=<span class="hljs-literal">False</span></span>):</span><br>    result = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;smart&#x27;</span>:<br>        arr_len = <span class="hljs-built_in">len</span>(arr)<br>        result = fft_recursive(arr) <span class="hljs-keyword">if</span> arr_len &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">7</span> <span class="hljs-keyword">else</span> dft_matrix(<span class="hljs-built_in">len</span>(arr)) @ arr<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;recursive&#x27;</span>:<br>        result = fft_recursive(arr)<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;dft&#x27;</span>:<br>        result = dft_matrix(<span class="hljs-built_in">len</span>(arr)) @ arr<br>    <span class="hljs-keyword">if</span> shift:<br>        result = fft_shift(result)<br>    <span class="hljs-keyword">return</span> np.real(result) <span class="hljs-keyword">if</span> return_real <span class="hljs-keyword">else</span> result<br></code></pre></td></tr></table></figure><h3 id="ifft-python">IFFT Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ifft_recursive</span>(<span class="hljs-params">arr</span>):</span><br>    n_len = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">assert</span> n_len &amp; (n_len - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n_len == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    Pe, Po = arr[::<span class="hljs-number">2</span>], arr[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>    ye, yo = ifft_recursive(Pe), ifft_recursive(Po)<br>    n = np.arange(n_len // <span class="hljs-number">2</span>, dtype=<span class="hljs-built_in">int</span>)<br>    w = np.power(np.exp(<span class="hljs-number">2</span> * np.pi * <span class="hljs-number">1j</span> / n_len), n)<br>    y = np.zeros(n_len, dtype=<span class="hljs-built_in">complex</span>)<br>    y[:n_len // <span class="hljs-number">2</span>] = ye + w * yo<br>    y[n_len // <span class="hljs-number">2</span>:] = ye - w * yo<br>    <span class="hljs-keyword">return</span> y / <span class="hljs-number">2</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">idft_matrix</span>(<span class="hljs-params">n_size</span>):</span><br>    n = np.arange(n_size).reshape(<span class="hljs-number">1</span>, n_size)<br>    m = np.arange(n_size).reshape(<span class="hljs-number">1</span>, n_size)<br>    idx_Mat = n.T @ m<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> / n_size) * np.power(np.exp(<span class="hljs-number">2</span> * np.pi * <span class="hljs-number">1j</span> / n_size), idx_Mat)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ifft_shift</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-keyword">return</span> np.r_[arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>:], arr[:<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ifft</span>(<span class="hljs-params">arr, method=<span class="hljs-string">&#x27;smart&#x27;</span>, shift=<span class="hljs-literal">False</span>, return_real=<span class="hljs-literal">False</span></span>):</span><br>    result = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> shift:<br>        arr = ifft_shift(arr)<br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;smart&#x27;</span>:<br>        arr_len = <span class="hljs-built_in">len</span>(arr)<br>        result = ifft_recursive(arr) <span class="hljs-keyword">if</span> arr_len &gt; <span class="hljs-number">2</span> ** <span class="hljs-number">7</span> <span class="hljs-keyword">else</span> idft_matrix(<span class="hljs-built_in">len</span>(arr)) @ arr<br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;recursive&#x27;</span>:<br>        result = ifft_recursive(arr)<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;idft&#x27;</span>:<br>        result = idft_matrix(<span class="hljs-built_in">len</span>(arr)) @ arr<br>    <span class="hljs-keyword">return</span> np.real(result) <span class="hljs-keyword">if</span> return_real <span class="hljs-keyword">else</span> result<br></code></pre></td></tr></table></figure><h2 id="代码测试">代码测试</h2><p>  一开始递归算法用时可能反而更长的原因，不过从后续来看确实是很有效：</p><ol type="1"><li>递归本身的弊端，不断压栈调用函数，空间自由度更大（python就更不适合了）</li><li>python语言本身对大矩阵乘法<code>@</code>的优化很强，所以递归分成多次乘法反而降低了这种优化</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/output123456.png" alt="output" style="zoom:65%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/output-16483145412911.png" alt="output" style="zoom:65%;" /></p>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>傅里叶变换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CV和DIP处理常见的那个女孩到底是谁</title>
    <link href="/2022/06/12/2022-06-12-Lena-the-CV-girl/"/>
    <url>/2022/06/12/2022-06-12-Lena-the-CV-girl/</url>
    
    <content type="html"><![CDATA[<p>  下面的图像相信做CV和DIP相关领域的人都不陌生，甚至别的相关的学科也会用到这张图来做。想起来以前生物必修课本中的蛋白质女王，也是闲的蛋疼的学生最喜欢整活的人物。DIP课上老师正在用这张图像介绍不记得什么图像处理方法的时候，我突然开始好奇这张图像中的人到底是谁，本着科研精神，我上Wiki查了一下，这一查不得了，我还坐在课堂的前排上课呢（doge</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/Lenna.jpg" alt="Lenna" style="zoom: 67%;" /></p><p>  这张图源自于美国成人男性杂志《花花公子》1972年11月号刊，也是由于这张图，这期创了历史上的销量巅峰（后来走下坡路了）。上了《花花公子》杂志的另一位女性人物相信很多人也很熟悉，就是这个杂志第一期封面女郎玛丽莲·梦露。可惜《花花公子》在ghs上干不过网络sq内容，在2016年后就不再刊登全裸照片了，然后去年给收购合并了。</p><p>  话题回到Lenna身上，在差不多十年后，她好像才知道自己在CV学术领域出名和广为流传，后来也作为嘉宾参加了数字图像相关的会议。不过当下也存在争议，认为使用她的照片属于男性凝视，强调了对女性的刻板印象，对课堂影响不好。不过我个人还是觉得问题不大，毕竟也没有说禁止使用一些女性凝视的照片嘛。况且科研狗们整天盯着干巴巴的标准图像估计也没啥干劲，看着Lenna的图像，想起图像未显示的部分，可能也更有干劲一点扒（不是</p><p>  下图是加个运动模糊退化的原图像（doge</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIP/output.png" alt="Lenna原图加了个丧心病狂的运动模糊" style="zoom:50%;" /></p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://zh.wikipedia.org/wiki/%E8%90%8A%E5%A8%9C%E5%9C%96#cite_note-2 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>没用的知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>频率域滤波</title>
    <link href="/2022/06/12/2022-06-12-Frequency-Domain-Filtering/"/>
    <url>/2022/06/12/2022-06-12-Frequency-Domain-Filtering/</url>
    
    <content type="html"><![CDATA[<p>文章使用的相关<code>.ipynb</code>文件在<a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/spatial%20operation%20and%20filtering">这里</a>。其中lab5对应本文频率域滤波。</p><span id="more"></span><h2 id="introduction">Introduction</h2><p>Frequency domain filtering handle the Fourier transform of an image, then calculate its inverse Fourier transform and get the processed image. This could be depicted as the following equation, in which <span class="math inline">\(H(u,v)\)</span> is the filtering transfer function. <span class="math display">\[g(x,y)=\mathcal{F}^{-1}[H(u,v)F(u,v)]\]</span> We need to multiply <span class="math inline">\(H(u,v)\)</span> and <span class="math inline">\(F(u,v)\)</span> by <span class="math inline">\((-1)^{x+y}\)</span> for shifting and centering the frequency domain function. Why we need to do this? Take 1dimensional DFT for example, the following equation is DFT, apparently we are interested in the positive indices for representing a period <span class="math inline">\([0, M]\)</span>, which in the frequency domain lies in the red area below: <span class="math display">\[\begin{aligned}F(u) &amp;=\sum^{M-1}_{n=0}f_n e^{-j2\pi nm/M} \\F(u,v) &amp;= \sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y) e^{-j2\pi(ux/M+vy/N)}\\\\&amp;\left\{\begin{aligned}&amp;f(n)(-1)^n \Leftrightarrow F(u-M/2) \\&amp;f(x,y)(-1)^{x+y} \Leftrightarrow F(u-M/2,v-N/2) \\\end{aligned} \right.\\\end{aligned}\]</span> <span class="math display">\[\begin{aligned}F^{shift}&amp;=\sum^{M/2-1}_{n=0}(-1)^nf_n e^{-j2\pi nm/M} +\sum^{M-1}_{n=M/2}(-1)^nf_n e^{-j2\pi nm/M} \\&amp;=\sum^{M/2-1}_{n=0}e^{-j\pi n}f_n e^{-j2\pi nm/M} +\sum^{M-1}_{n=M/2}e^{-j\pi n}f_n e^{-j2\pi nm/M} \\&amp;=\sum^{M/2-1}_{n=0}f_n e^{-j2\pi (n+M/2)m/M} +\sum^{M-1}_{n=M/2}e^{-j\pi n}f_n e^{-j2\pi (n+M/2)m/M} \\&amp;=\sum^{-1}_{n=-M/2}f_n e^{-j2\pi nm/M} +\sum^{M/2-1}_{n=0}f_n e^{-j2\pi nm/M} \\&amp;=\sum^{M/2-1}_{n=-M/2}f_n e^{-j2\pi nm/M} \\\\&amp;\mbox{2D is similar, after shifted the DFT is:} \\F^{shift}&amp;=\sum^{M/2-1}_{x=-M/2}\sum^{N/2-1}_{y=-N/2}f(x,y) e^{-j2\pi(ux/M+vy/N)}\\\end{aligned}\]</span></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPwatermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExMzY3NjY2MTk1,size_6,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述" style="zoom: 33%;" /></p><p>According to the periodicity of DFT, the function in <span class="math inline">\([M/2, M]\)</span> is the same with <span class="math inline">\([-M/2, 0]\)</span>. For the sake of better visualizing the red area, we would like to move the DC component to the center, that is, multiply a <span class="math inline">\((-1)^x\)</span> for 1dimensional DFT. For 2 dimension it is the same, the proof are given above. As seen in the following example, the right one is more elegant and could show us more knowledge about the image frequency domain.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput.png" alt="output" style="zoom: 40%;" /></p><p>Frequency domain filtering has important researching value, <strong>some tasks may be difficult to represent by equations in spatial domain, but could be perfectly revealed in frequency domain</strong>. Therefore, we usually see frequency domain filtering as a tool for understanding the effect and principle of a filter template, but implement it in spatial domain.</p><p>If the frequency domain of <span class="math inline">\(h(x,y)\)</span>, that is, <span class="math inline">\(H(u,v)\)</span> should be real and symmetry. <span class="math inline">\(H(u,v)\)</span> should be real because that we want to have a zero-phase result, therefore the spatial domain should be symmetry, so the frequency domain should be real. Similarly, we hope to get a real result after doing IDFT or IFFT, so the frequency domain has better be symmetry. Here one of the proof: <span class="math display">\[\begin{aligned}&amp;\mbox{h(x,y) is real &lt;=&gt; H(u,v) is symmetry: }\\H^{*}(u,v)&amp;=[\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}h(x,y)e^{-j2\pi(ux/M+vy/N)}]^{*} \\&amp;=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}h^{*}(x,y)e^{j2\pi(ux/M+vy/N)} \\&amp;=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}h(x,y)e^{-j2\pi([-u]x/M+[-v]y/N)} \\&amp;=H(-u,-v) \\\end{aligned}\]</span> Besides, <strong>we can find the noise pattern much more easier in frequency domain</strong>, and then use some delicate method to eliminate them, like we would discuss in task 4.</p><h2 id="fft-and-ifft">FFT and IFFT</h2><p>In actual application, we usually use FFT rather than DFT, because the DFT has higher time complexity. I implement DFT by two methods, which are matrix multiplication and FFT algorithm, then analyze the difference. We start by analyze 1 dimension situation:</p><h3 id="principle-and-implementation">Principle and Implementation</h3><p>The DFT process could be done by implementing the following matrix, <span class="math inline">\(F(u^i)\)</span> is the <span class="math inline">\(i\)</span> th frequency value and <span class="math inline">\(f_i\)</span> is the <span class="math inline">\(i\)</span> th spatial value. This is simple to understand, therefore I do not put pseudo code for this original DFT method. <span class="math display">\[\begin{aligned}&amp;\mbox{omega is the frequency component: } \omega=e^{2\pi j/M}\\\begin{bmatrix}F(u^0) \\F(u^1)\\F(u^2)\\...\\F(u^{M-1})\end{bmatrix}&amp;=\begin{bmatrix}1 &amp;1 &amp;1 &amp;...&amp;1 \\1 &amp; \omega&amp; \omega^2&amp;...&amp; \omega^{M-1}\\1 &amp; \omega^2&amp; \omega^4&amp;...&amp; \omega^{2(M-1)}\\... &amp; ... &amp; ... &amp; ... &amp; ... \\1 &amp; \omega^{M-1}&amp; \omega^{2(M-1)}&amp;...&amp; \omega^{(M-1)(M-1)}\\\end{bmatrix}\begin{bmatrix}f_0 \\f_1\\f_2\\...\\f_{M-1}\end{bmatrix}\end{aligned}\]</span> We could easily draw a conclusion that DFT is a <span class="math inline">\(O(N^2)\)</span> algorithm, because this matrix multiplication actually use two <code>for</code> loops. Now we hope to use a <em>divide and conquer</em> concept to implement a <span class="math inline">\(O(NlogN)\)</span> method, utilizing <strong>the symmetry property of even and odd functions</strong>. Here is the pseudocode of FFT (it could be a long discussion if prove FFT in detail):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">def FFT(P):<br>n=len(P)<br>if n == 1:<br>return P<br>w = e^(2*pi*i/n)<br>Pe, Po = [p0, p2,...,p_&#123;n-2&#125;], [p1, p3,...,p_&#123;n-1&#125;]<br>ye, yo = FFT(Pe), FFT(Po)<br>y = zeros(n)<br>for j in range(n/2):<br>y[j] = ye[j] + w^j * yo[j]<br>y[j+n/2] = ye[j] - w^j * yo[j]<br>return y<br></code></pre></td></tr></table></figure><p>As for 2 dimensional FFT and IFFT, we could implement them by doing 1 dimensional FFT or IFFT twice, along axis 1 and axis 0 separately, this is proved as following: <span class="math display">\[\begin{aligned}F(u,v) &amp;= \sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y) e^{-j2\pi(ux/M+vy/N)}\\&amp;=\sum^{M-1}_{x=0}e^{-j2\pi ux/M}(\sum^{N-1}_{y=0}f(x,y) e^{-j2\pi vy/N})\\&amp;=\sum^{M-1}_{x=0}F(x,v) e^{-j2\pi ux/M}\\F(x,v)&amp;=\sum^{N-1}_{y=0}f(x,y) e^{-j2\pi vy/N}\end{aligned}\]</span> Notice that we need to pad zeros for FFT, because it only support sequence size of <span class="math inline">\(2^n\)</span> (every <em>divide and conquer</em> method does) as 1 dimension. I notice that <code>numpy</code> do not pad zeros, after searching for reference, I found that <code>numpy</code> would not use 2 as base number anymore, but 4, 8, or the others. This may sacrifice the time cost a little bit, I do not implement this.</p><p>However, padding zeros would affect the frequency spectrum, because padding would change the size of <span class="math inline">\((M,N)\)</span>, and the interpolation points would increase. This would not change the appearance of frequency spectrum largely, but make it smoother.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16483617961875.png" alt="output" style="zoom: 50%;" /></p><p>IFFT is very similar to FFT, because they are a pair of Fourier transform couple. The pseudo code for it is shown below. The results of inverse transforming the above frequency domain is shown below. I show the result without deleting the zero-pad area for IFFT, I also implement a method <code>def cut_zero_columns</code> for it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">def IFFT(P):<br>n=len(P)<br>if n == 1:<br>return P<br>w = e^(2*pi*i/n)<br>Pe, Po = [p0, p2,...,p_&#123;n-2&#125;], [p1, p3,...,p_&#123;n-1&#125;]<br>ye, yo = IFFT(Pe), IFFT(Po)<br>y = zeros(n)<br>for j in range(n/2):<br>y[j] = ye[j] + w^j * yo[j]<br>y[j+n/2] = ye[j] - w^j * yo[j]<br>return y / 2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16483625326037.png" alt="output" style="zoom: 50%;" /></p><h3 id="proof-for-correctness">Proof for Correctness</h3><p>I randomly generate a sequence and do FFT and DFT on it, comparing the result with <code>numpy.fft.ftt</code>. Then I use IFFT and DFT to transform the frequency domain result in spatial domain, comparing with <code>numpy.fft.ifft</code>. The graph of this sequence below prove the correctness of my algorithms. The 2D FFT and IFFT result are shown in the above part.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16483594045422.png" alt="output" style="zoom: 50%;" /></p><h3 id="time-complexity">Time Complexity</h3><p>First let's see the complexity of 1 dimensional FFT and IFFT, the x-axis of the following graph is <span class="math inline">\(2^n\)</span>, because I do not implement padding for 1 dimensional situation. DFT has greater time complexity than IFFT as we expected, but DFT is faster when the graph size is lower than about <span class="math inline">\(2^7=128\)</span>, here might be the reasons:</p><ol type="1"><li><code>numpy</code> has optimization over matrix multiplication</li><li>recursive methods naturally occupy larger space complexity, and frequently stack functions might affect the speed of program (actually this would happen when M is large)</li></ol><p>Therefore I set a threshold of <span class="math inline">\(2^7\)</span> above which using FFT and Below it using DFT.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16483594253683.png" alt="output" style="zoom: 50%;" /></p><p>For the 2D situation, although FFT is still faster than DFT, but the testing time is too long. So I just run a few <span class="math inline">\(M\)</span> size, the advantage of FFT is not so obvious. Actually a size of <span class="math inline">\(M=8000\)</span> is too large for nowadays PC monitor. The "step" effect of FFT is due to the zero-pad strategy.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164836469072610.png" alt="output" style="zoom: 50%;" /></p><h2 id="distance-matrix">Distance Matrix</h2><p>Many of the following frequency domain filters are designed under this distance matrix. For convenience, I implement a method to calculate distance matrix given image shape, using <code>numpy.meshgrid</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_matrix</span>(<span class="hljs-params">img_shape</span>):</span><br>    half_len = (img_shape[<span class="hljs-number">0</span>] // <span class="hljs-number">2</span>, img_shape[<span class="hljs-number">1</span>] // <span class="hljs-number">2</span>)<br>    n_0 = np.arange(img_shape[<span class="hljs-number">0</span>]) - half_len[<span class="hljs-number">0</span>]<br>    n_1 = np.arange(img_shape[<span class="hljs-number">1</span>]) - half_len[<span class="hljs-number">1</span>]<br>    x, y = np.meshgrid(n_1, n_0)<br>    <span class="hljs-keyword">return</span> np.sqrt(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="task-1">Task 1</h2><p>The convolution theory connects spatial domain and frequency domain. The spatial Sobel filtering is using the functions defined in last lab, shown in the second figure below. The proof for frequency domain Sobel, given a <span class="math inline">\(M\times N\)</span> input <span class="math inline">\(f(x, y)\)</span>: <span class="math display">\[\begin{aligned}&amp;\mbox{If need, pad the margin and get PxQ, transform to: } \\f_s&amp;=(-1)^{x+y}f(x,y) \\F(u, v)&amp;=DFT\{f_s(x, y)\} \ or \ FFT\{f_s(x, y)\} \\&amp;\mbox{Given a spatial template h(x, y), transform to: } \\H(u, v)&amp;=DFT\{h(x, y)\} \ or \ FFT\{h(x, y)\} \\&amp;\mbox{Filtering, correspond to spatial convolution: } \\G(u, v)&amp;=H(u,v)F(u,v) \\&amp;\mbox{Finally, get the result: } \\g(x,y) &amp;= \{real[\mathcal{F}^{-1}[G(u,v)]]\}\\g_s(x,y) &amp;= (-1)^{x+y}g(x,y) \\\\&amp;\mbox{Sobel templates in frequency domain: } \\h_1&amp;=\begin{bmatrix}-1 &amp; -2 &amp; -1 \\0 &amp; 0 &amp; 0\\1 &amp; 2 &amp; 1 \\\end{bmatrix}\quad h_2=\begin{bmatrix}-1 &amp; 0 &amp; 1 \\-2 &amp; 0 &amp; 2\\-1 &amp; 0 &amp; 1 \\\end{bmatrix}\end{aligned}\]</span> Substitute the two templates of Sobel <span class="math inline">\(h_1, h_2\)</span> into the process above, we get the frequency representation of Sobel templates, which are shown in figure 3 and 4 below. The results of filtering using them separately are shown in figure 5 and 6. We can see that each template extract the high frequency component of one dimension, abandoning the low frequency smooth component. The last figure is the frequency filtering result, it is the same with the spatial operation.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16491320186081.png" alt="output" style="zoom: 80%;" /></p><p>The time spatial operation cost is <code>0.965 s</code> while frequency costs <code>0.590 s</code>. It turns out that convolution in spatial domain takes more time than matrix dot product in frequency domain. This match our expectation, because <code>numpy</code> has optimization over matrix operation. Definitely, this is also relevant with the corresponding optimization methods (The Big Mat method for spatial domain and FFT for frequency domain).</p><p>Below is the frequency domain Laplace filtering, we can see that it has explicit different pattern with Sobel filtering. Comparing them, I would conclude that:</p><ol type="1"><li>Sobel templates would reject some high frequency components near the margin, so it could withdraw noise when extracting the edge information. Laplace leaves all the high frequency components, therefore when low frequency parts are removed, the weight of noise would increase.</li><li>Laplace filter reject more low frequency component than Sobel, so its edges are thinner than Sobel.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16491523423054.png" alt="output" style="zoom: 50%;" /></p><h2 id="task-2">Task 2</h2><p>The ideal lowpass filter in frequency domain is, <span class="math inline">\(D_0\)</span> is the cutoff frequency: <span class="math display">\[H(u,v)=\left\{\begin{aligned}1, \quad D(u,v) \leq D_0 \\0, \quad D(u,v) &gt; D_0\end{aligned}\right.\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPimage-20220327184802545.png" alt="image-20220327184802545" style="zoom:50%;" /></p><p>What the filter has done is shown below. The ideal lowpass filter directly cutoff the high frequency parts, leaving the low frequency. We can see from the following graph that the low frequency occupies larger power than the high frequency parts. The filtered high frequency parts are margin information and noises in spatial domain.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837131014416.png" alt="output" style="zoom: 50%;" /></p><p>The results of different <span class="math inline">\(D_0\)</span> is below:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837020747914.png" alt="output" style="zoom: 50%;" /></p><p><strong>When the radius of ILPF increases, the blur effect and the filtered power decrease. IDLF would cause "ringing" effect, which is due to the property of <span class="math inline">\(sinc\)</span> function</strong>. The following graph is the spatial feature of a ILPF with radius of 10. It is a <span class="math inline">\(sinc\)</span> function in 2D. This function convolves with every pixels (impulses) in the image, then many lobes would overlay with each other, these small lobes are the reason of "ringing". <strong>The small lobes are significant when the radius of ILPF is small, so increasing <span class="math inline">\(D_0\)</span> would be helpful to reduce "ringing"</strong>. This is reasonable and correspondent with the lab results above.</p><p>By the way, The upstanding center results in the blur effect, because it strengthen the low frequency parts. Besides, its holding area is too large, therefore the convolution results with pixel impulses would overlap. When <span class="math inline">\(D_0\)</span> increases, the area is smaller, and blur is less.</p><table><tr><td><center><img src="lab5实验报告.assets/output-164837212819417.png" alt="output" style="zoom:50%;" /></center></td><td><center><img src="lab5实验报告.assets/output-164837319386618.png" alt="output" style="zoom:50%;" /></center></td></tr><tr><td><center><img src="lab5实验报告.assets/output-164837407272019.png" alt="output" style="zoom:50%;" /></center></td><div class="code-wrapper"><pre><code class="hljs">&lt;td&gt;&lt;center&gt;&lt;img src=&quot;lab5实验报告.assets/output-164837408549120.png&quot; alt=&quot;output&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre></div></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowpass_freq</span>(<span class="hljs-params">img_shape, d0</span>):</span><br>    dm = distance_matrix(img_shape)<br>    <span class="hljs-keyword">return</span> (dm &lt;= d0).astype(<span class="hljs-built_in">int</span>)<br></code></pre></td></tr></table></figure><h2 id="task-3">Task 3</h2><h3 id="gaussian-lowpass-filter">Gaussian lowpass Filter</h3><p>The equation of gaussian lowpass filter is shown below, <span class="math inline">\(D_0\)</span> is the cutoff frequency: <span class="math display">\[H(u,v)=e^{-D^2(u,v)/2D_0^2}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPimage-20220327184721007.png" alt="image-20220327184721007" style="zoom:50%;" /></p><p>The gaussian filter is better than ILPF, because it do not have small lobes discussed above, which causes the "ringing" effect. However, this means that it sacrifices its effectiveness of lowpass filtering. In the following image, we can see that GLPF has a smooth transition.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837529940422.png" alt="output" style="zoom: 50%;" /></p><p>The results are shown below:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837528703621.png" alt="output" style="zoom:60%;" /></p><p>From the equation of GLPF, <span class="math inline">\(D_0\)</span> is the standard deviation of gaussian. It represents the strength of filtering, that is, more power would be filtered if <span class="math inline">\(D_0\)</span> decreases. From the following graph, we cannot see any small lobes effect in spatial domain. This is because <strong>the IDFT of gaussian is still gaussian</strong>, which is an important property of gaussian.</p><table><tr><td><center><img src="lab5实验报告.assets/output-164837531769123.png" alt="output" style="zoom:50%;" /></center></td><td><center><img src="lab5实验报告.assets/output-164837532971724.png" alt="output" style="zoom:50%;" /></center></td></tr></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gaussian_lowpass_freq</span>(<span class="hljs-params">img_shape, d0</span>):</span><br>    dm = distance_matrix(img_shape)<br>    <span class="hljs-keyword">return</span> np.exp(-dm ** <span class="hljs-number">2</span> / (<span class="hljs-number">2</span> * d0 ** <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="gaussian-highpass-filter">Gaussian highpass filter</h3><p>The equation of Gaussian highpass filter: <span class="math display">\[H(u,v)=1-e^{-D^2(u,v)/2D_0^2}\]</span> The highpass filter would eliminate the low frequency parts in the center of the following spectrum. Comparing with IHPF and BHPF, the filtering result of GHPF is smoother (discussed later).</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837912893225.png" alt="output" style="zoom: 50%;" /></p><p>The results of gaussian highpass filter:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-164837915234126.png" alt="output" style="zoom:60%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gaussian_highpass_freq</span>(<span class="hljs-params">img_shape, d0</span>):</span><br>    dm = distance_matrix(img_shape)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - np.exp(-dm ** <span class="hljs-number">2</span> / (<span class="hljs-number">2</span> * d0 ** <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h2 id="task-4">Task 4</h2><p>A Butterworth notch reject filter is composed of multiple highpass filter couples, the proof is: <span class="math display">\[\begin{aligned}&amp;\mbox{A single butterworth highpass filter: } \\H(u,v)&amp;=\frac{1}{1+[\frac{D(u,v)}{D_0}]^{2n}} \\&amp;\mbox{Therefore a notch filter is: } \\H_{NR}&amp;=\prod^{Q}_{k=1}H_k(u,v)H_{-k}(u,v) \\\end{aligned}\]</span></p><p>In the above equation, <span class="math inline">\(Q\)</span> is the number of filter couples, and <span class="math inline">\(H_k, H_{-k}\)</span> are a pair of couple which are symmetry about the center of frequency domain (DC component). The Butterworth notch reject filter could be gotten simply by <span class="math inline">\(H_{NP} = 1 - H_{NR}\)</span>. Here is the Butterworth filters family:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16491414987472.png" alt="output" style="zoom: 50%;" /></p><p>The figure to process is the third figure, which has Moiré stripes. Moiré pattern is an important feature in DIP, it would be caused by overlapping of similar frequency stripes (can refer to <a href="https://blog.csdn.net/Du_Shuang/article/details/107727272">this blog</a> for understanding its principle). <strong>In the first graph, we can see that there are 8 bright points, they are the overlapping frequency component</strong>. To remove the Moiré stripes, I use Butterworth notch reject filter to eliminate these components, the result is shown in the second figure. Then do IFFT and get the final result, shown in the forth figure. I also use a Butterworth notch pass filter to extract the 8 bright points to see what it is, it turns out that they are stripes of different frequency overlapping with each other.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/DIPoutput-16491415596913.png" alt="output" style="zoom: 47%;" /></p><p>The Butterworth notch reject filter is defined by:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">butterworth_highpass_freq</span>(<span class="hljs-params">img_shape, d0, n, center=(<span class="hljs-params"><span class="hljs-number">0</span>, <span class="hljs-number">0</span></span>)</span>):</span><br>    dm = distance_matrix(img_shape, center=center) + <span class="hljs-number">0.000001</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.power(d0 / dm, <span class="hljs-number">2</span> * n))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">butterworth_notch_reject_freq</span>(<span class="hljs-params">img_shape, d0s, n, centers</span>):</span><br>    HNR = np.ones(img_shape)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(d0s)):<br>        Hk = butterworth_highpass_freq(img_shape, d0s[i], n, center=centers[i])<br>        H_minus_k = butterworth_highpass_freq(img_shape, d0s[i], n, center=(-centers[i][<span class="hljs-number">0</span>], -centers[i][<span class="hljs-number">1</span>]))<br>        HNR *= Hk * H_minus_k<br>    <span class="hljs-keyword">return</span> HNR<br></code></pre></td></tr></table></figure><p>The parameters of Butterworth notch reject filter are:</p><ol type="1"><li><code>img_shape</code>: a tuple of <span class="math inline">\((M, N)\)</span> for an <span class="math inline">\(M\times N\)</span> shape image</li><li><code>d0s</code>: a list of cutoff frequencies correspond to the list of highpass filter pairs. For example, <code>[10, 5]</code> means that we operate a highpass filter with radius of 10 for the first center in <code>centers</code> , and radius of 5 for the second.</li><li><code>n</code>: the order of Butterworth filters, it could adjust the degree of transition of the filter</li><li><code>centers</code>: a list of centers to operate highpass filters, the size should be the same with <code>d0s</code>. In the method body, I would automatically generate the other symmetrical center.</li></ol><p>All the parameters are tuned by experience referring the spectrum of the image. I tried different <code>centers</code> for 3~4 times to fit the bright points, then I gave <code>d0s</code> according to the size of the bright points.<code>n</code> is given 3 because this is a proper parameter for most situation using Butterworth filters, if it is larger, it might occur some "ring" effect.</p><h2 id="conclusion">Conclusion</h2><p>In this lab, I have done the following experiment and discussion:</p><table><colgroup><col style="width: 29%" /><col style="width: 35%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th>Content</th><th>Experiment &amp; Result</th><th>Conclusion</th></tr></thead><tbody><tr class="odd"><td>Introduction</td><td>Discuss the basic method of frequency filtering and <strong>the reason of shifting and why <span class="math inline">\(H(u,v)\)</span> should be real and symmetry</strong></td><td>\</td></tr><tr class="even"><td>Implement FFT</td><td>Implement the 1D recursive FFT algorithm with base 2, then compare the result with <code>numpy.ftt</code> and self implement DFT which using a transform matrix.</td><td>FFT is an elegant and fantastic algorithm, playing a significant role in modern signal processing area. It reduces the time complexity from <span class="math inline">\(O(N^2)\)</span> to <span class="math inline">\(O(NlogN)\)</span>.</td></tr><tr class="odd"><td>Implement FFT2</td><td>The 2D DFT is separable, which means that we can do 1D FFT twice to get the spectrum of an image.</td><td>The base 2 FFT algorithm need zero-pad, so the result of FFT2 might be much larger than DFT. However, this do not have apparent harm on the result, because FFT would done interpolation on the Frequency domain for the zero components. The time complexity is not as good as expected, which might owe to the bottom optimization.</td></tr><tr class="even"><td>Sobel Filter in both spatial and frequency domains</td><td>The spatial domain version is from last lab. Then, I discuss the implementation of frequency domain version step by step. Finally, I compare Sobel and Laplace templates.</td><td>The spatial and frequency domain filtering results are very similar. The frequency domain of Sobel templates shows its pattern clearly. From the comparing with Laplace frequency domain, we can understand the pros and cons of both templates better than spatial domain.</td></tr><tr class="odd"><td>ILPF</td><td>Implement ideal lowpass filter and discuss the "ring" effect</td><td>When the cutoff frequency <span class="math inline">\(d_0\)</span> decreases, the blur effect and the "ring" effect increases. The "ring" effect is caused by small lobes around the impulse. Increasing <span class="math inline">\(d_0\)</span> would reduce the "ring" effect and blurring, but the function of LPF is also weakened.</td></tr><tr class="even"><td>GLPF and GHPF</td><td>Implement gaussian lowpass filter and gaussian highpass filter</td><td>Gaussian filters have larger size than Butterworth filters, which means that its transition around the cutoff frequency is smoother. Therefore, it do not have "ring" effect, but it do not perform as good as Butterworth in filtering.</td></tr><tr class="odd"><td>Butterworth notch filters</td><td>Implement the Butterworth filters family, and discuss how notch filter impact on Moiré pattern</td><td>The effect of filtering is great. Moiré pattern is a phenomenon caused by frequency overlapping, so its spectrum has some bright points corresponds to the stripes of certain frequencies. The parameters are chosen most from tuning and experience (need to find the bright points positions).</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>傅里叶变换</tag>
      
      <tag>频域</tag>
      
      <tag>滤波</tag>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行走机器人课程-数据结构与编程</title>
    <link href="/2022/03/27/2022-3-27-Walking-Robot-data-structure-of-robot/"/>
    <url>/2022/03/27/2022-3-27-Walking-Robot-data-structure-of-robot/</url>
    
    <content type="html"><![CDATA[<p>大三下学期行走机器人这门课程的一些笔记，用的教材是日本Kajita的Introduction to Humanoid Robotics，估计是因为老师主要是做双足机器人的。文章使用的涉及的相关<code>.m</code>文件在<a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/WakingRobot%20support%20files">这里</a>。</p><span id="more"></span><h3 id="关节连杆">关节+连杆</h3><p>  <strong>在实时的机器人运动学求解中，我们很难对所有关节的运动一起求解，所以需要构建一种数据结构来描述求解顺序，然后可以通过递归的方式去顺序求解</strong>。那么如何去将机器人划分为smaller units来构建数据结构？有如下两种方式，因为机器人除了body其他肢体都是符合单一的joint+link的结构，所以使用左边建模更加方便。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303143030115.png" alt="image-20220303143030115" style="zoom:67%;" /></p><h3 id="数据结构">数据结构</h3><h4 id="树-复习">树-复习</h4><h5 id="概念">概念</h5><p>  树是很常用的一种ADT（Abstract Data Type），由n个有限节点组成一个具有层次关系的集合叫做树。<strong>二叉树</strong>的概念想必熟悉，<strong>完全二叉树</strong>指的是“除了最后一层，其余每层的节点均由左向右连续排列至最大”；<strong>平衡二叉树</strong>（AVL树）指的是“任何两棵子树的高度差不大于1的二叉树，此处还涉及AVL树的转换”；<strong>排序二叉树</strong>也称二叉搜索树（Binary Search Tree），与树的排序算法和搜索算法挂钩，特点是能够既能够快速插入和删除，又能快速查找（文件系统用的就是BST）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="树 (数据结构). https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84). ↩︎">[1]</span></a></sup></p><p>  树结构有如下特征：</p><ul><li>每个节点都只有有限个child或无child</li><li>没有father的节点为root</li><li>每个child只有一个father</li><li>每个child可以被分离出来作为单独的子树</li><li>树里面没有cycle</li></ul><h5 id="三种遍历方式">三种遍历方式</h5><ul><li>前序遍历由左向右优先遍历father<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="树-数据结构(Python). https://web.archive.org/web/20181002180935/https://eindex.me/tree-in-python/.">[2]</span></a></sup></li><li>后序遍历由左向右优先遍历child</li><li>层序遍历一层层遍历所有节点</li></ul><table><tr><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303151543227.png" alt="image-20220303151543227" style="zoom: 50%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303212451258.png" alt="image-20220303212451258" style="zoom: 50%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303212603293.png" alt="image-20220303212603293" style="zoom:50%;" /></td></tr></table><h4 id="使用tree求解运动学">使用Tree求解运动学</h4><p>  将Body看作root，所有的末端（extremities）看作叶子节点（leaf）。但是下图这种节点的排列方式会<strong>导致不同的link存在不同的分支数量，这种表示方式会导致更难去Program（存在很多不完全树，排布过于sparse）</strong>。我们在使用树结构的时候，一般会去指定每一层的节点数量。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303214353154.png" alt="image-20220303214353154" style="zoom: 67%;" /></p><p>  因此，另外一种方式是使用二叉树，如下图所示。当前节点左侧连接的是child link，右侧连接的是与当前节点同级的link（sister link），如果已经没有child和sister了就用“0”表示leaf：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303220045537.png" alt="image-20220303220045537" style="zoom: 67%;" /></p><h4 id="matlab代码">MATLAB代码</h4><p>  这次作业要我们实现个树来表示这个9DOF的双足机器人，还是比较简单的：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220303223739296.png" alt="image-20220303223739296" style="zoom: 80%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs matlab">clear;clc;<br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-comment">% assign attributes, idx start from 1</span><br>uLINK = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;BODY&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">2</span>);<br>uLINK(<span class="hljs-number">2</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;RARM&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">3</span>);<br>uLINK(<span class="hljs-number">3</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;RHAND&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">0</span>);<br>uLINK(<span class="hljs-number">4</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;LARM&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">5</span>);<br>uLINK(<span class="hljs-number">5</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;LHAND&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">0</span>);<br>uLINK(<span class="hljs-number">6</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;RLEG&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">7</span>);<br>uLINK(<span class="hljs-number">7</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;RFOOT&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">0</span>);<br>uLINK(<span class="hljs-number">8</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;LLEG&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">9</span>);<br>uLINK(<span class="hljs-number">9</span>) = struct(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;LFOOT&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;sister&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;child&#x27;</span>, <span class="hljs-number">0</span>);<br><br>PrintLinkName(<span class="hljs-number">1</span>)<br>TotalMass(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">%% file: PrintLinkName</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrintLinkName</span><span class="hljs-params">(idx)</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-comment">% this is a preorder traversal</span><br><span class="hljs-keyword">if</span> idx ~= <span class="hljs-number">0</span><br>    fprintf(<span class="hljs-string">&#x27;j=%2d : %s\n&#x27;</span>, idx, uLINK(idx).name);<br>    PrintLinkName(uLINK(idx).child);<br>    PrintLinkName(uLINK(idx).sister);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%% file: TotalMass</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">m</span> = <span class="hljs-title">TotalMass</span><span class="hljs-params">(idx)</span></span><br><span class="hljs-keyword">global</span> uLINK<br><br><span class="hljs-keyword">if</span> idx == <span class="hljs-number">0</span><br>    m = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    m = uLINK(idx).m + TotalMass(uLINK(idx).sister) + TotalMass(uLINK(idx).child);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="参考">参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>树 (数据结构). https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84). ↩︎ <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>树-数据结构(Python). https://web.archive.org/web/20181002180935/https://eindex.me/tree-in-python/. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>Walking Robot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown Tex符号速查</title>
    <link href="/2022/03/27/2022-3-27-markdown-signs-collection/"/>
    <url>/2022/03/27/2022-3-27-markdown-signs-collection/</url>
    
    <content type="html"><![CDATA[<p>参考文档为<a href="https://www.caam.rice.edu/~heinken/latex/symbols.pdf">LATEX Mathematical Symbols - Rice University</a></p><span id="more"></span><h2 id="希腊字母">希腊字母</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122346488.png" alt="image-20220317122346488" style="zoom:75%;" /></p><h2 id="公式符号">公式符号</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123254425.png" alt="image-20220317123254425" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123304331.png" alt="image-20220317123304331" style="zoom:67%;" /></p><h2 id="二元操作符-关系符">二元操作符 &amp; 关系符</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122546440.png" alt="image-20220317122546440" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122618674.png" alt="image-20220317122618674" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122641458.png" alt="image-20220317122641458" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122719659.png" alt="image-20220317122719659" style="zoom:67%;" /></p><h2 id="箭头符号">箭头符号</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317122802739.png" alt="image-20220317122802739" style="zoom:67%;" /></p><h2 id="符号上标">符号上标</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123036134.png" alt="image-20220317123036134" style="zoom:67%;" /></p><h2 id="大括号">大括号</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123123214.png" alt="image-20220317123123214" style="zoom:67%;" /></p><h2 id="字体">字体</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123720516.png" alt="image-20220317123720516" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317123732089.png" alt="image-20220317123732089" style="zoom:67%;" /></p><h2 id="分隔符">分隔符</h2><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220317153659005.png" alt="image-20220317153659005" style="zoom:75%;" /></p><h2 id="补充">补充</h2><ol type="1"><li><p><span class="math inline">\(\partial\)</span>: <code>\partial</code> or <code>\part</code></p></li><li><p>:<span class="math inline">\(\nabla\)</span> <code>\nabla</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灰度变换与空间滤波</title>
    <link href="/2022/03/27/2022-3-27-Intensity-Transform-and-Spatial-Filtering/"/>
    <url>/2022/03/27/2022-3-27-Intensity-Transform-and-Spatial-Filtering/</url>
    
    <content type="html"><![CDATA[<p>文章使用的相关<code>.ipynb</code>文件在<a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/spatial%20operation%20and%20filtering">这里</a>。其中lab3对应锐化滤波以外的部分，lab4对应锐化滤波。</p><span id="more"></span><ul><li><a href="#%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">灰度变换与空间滤波</a><ul><li><a href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">背景知识</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2">基本灰度变换</a><ul><li><a href="#%E5%9B%BE%E5%83%8F%E5%8F%8D%E8%BD%AC">图像反转</a></li><li><a href="#%E5%AF%B9%E6%95%B0%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%8C%87%E6%95%B0%E5%8F%98%E6%8D%A2">对数变换与指数变换</a></li><li><a href="#%E5%B9%82%E5%BE%8B%E4%BC%BD%E9%A9%AC%E5%8F%98%E6%8D%A2">幂律（伽马）变换</a></li><li><a href="#%E5%88%86%E6%AE%B5%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0">分段线性变换函数</a><ul><li><a href="#%E5%AF%B9%E6%AF%94%E5%BA%A6%E6%8B%89%E4%BC%B8">对比度拉伸</a></li><li><a href="#%E7%81%B0%E5%BA%A6%E7%BA%A7%E5%88%86%E5%B1%82">灰度级分层</a></li><li><a href="#%E6%AF%94%E7%89%B9%E5%B9%B3%E9%9D%A2%E5%88%86%E5%B1%82">比特平面分层</a></li></ul></li></ul></li><li><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86">直方图处理</a><ul><li><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1">直方图均衡</a></li><li><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%8C%B9%E9%85%8D">直方图匹配</a></li><li><a href="#%E5%B1%80%E9%83%A8%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86">局部直方图处理</a></li><li><a href="#%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%BB%9F%E8%AE%A1">图像增强中的直方图统计</a></li></ul></li><li><a href="#%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2">空间滤波</a><ul><li><a href="#%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%99%A8">平滑空间滤波器</a><ul><li><a href="#%E5%B9%B3%E6%BB%91%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E5%99%A8">平滑线性滤波器</a></li><li><a href="#%E4%BD%8E%E9%80%9A%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8">低通高斯滤波器</a></li><li><a href="#%E7%BB%9F%E8%AE%A1%E6%8E%92%E5%BA%8F%E6%BB%A4%E6%B3%A2%E5%99%A8">统计排序滤波器</a></li></ul></li><li><a href="#%E9%94%90%E5%8C%96%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E5%99%A8">锐化空间滤波器</a><ul><li><a href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90">拉普拉斯算子</a></li><li><a href="#%E6%8F%90%E5%8D%87%E6%BB%A4%E6%B3%A2">提升滤波</a></li><li><a href="#%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E9%94%90%E5%8C%96">一阶微分锐化</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul><h1 id="灰度变换与空间滤波">灰度变换与空间滤波</h1><ul><li>空间域（spatial domain）</li><li>变换域（transform domain）</li><li>灰度变换（intensity transformations）</li><li>空间滤波（spatial Filtering）</li><li>邻域（neighborhood）</li><li>锐化（sharpening）</li><li>平滑（smoothing）</li><li>算子（operator）</li><li>扩展/压缩（spreading/compressing）</li><li>伽马校正（gamma correction）</li><li>对比度拉伸（contrast stretching）</li><li>直方图（histograms）</li><li>直方图均衡（histogram equalization）</li><li>直方图匹配（histogram matching <em>or</em> specification）</li><li>二义性（ambiguity）</li><li>冲淡（washed-out）</li><li>累计分布函数（CDF）</li><li>离散单位冲激（a discrete unit impulse）</li><li>相关与卷积（correlation and convolution）</li><li>各向同性（isotropic）</li><li>高斯核（gaussian kernel）</li><li>均值与方差（mean and variance）</li><li>边缘模糊（Edge blur）</li><li>锐化（sharpening）</li></ul><h2 id="背景知识">背景知识</h2><p>  图像空间域处理直接对pixels进行操作，这是相对于变换域（例如频域处理）处理而言的。通常，在空间域上处理的计算更加高效，且占用资源较少。空间域处理主要分为灰度变换和空间滤波，前者对单个pixel操作，例如对比度和图像阈值操作；后者对pixel的邻域进行操作，例如锐化和平滑图像。</p><p>  空间域处理的基本公式如下面第一个公式，其中<span class="math inline">\(f(x,y\)</span>)和<span class="math inline">\(g(x,y)\)</span>分别代表输入和输出函数的pixels，<span class="math inline">\(T\)</span>是在点<span class="math inline">\((x,y)\)</span>的邻域上定义的关于<span class="math inline">\(f\)</span>的一种算子。当邻域大小为1 x 1时，如下面第二个公式，称T为<em>灰度变换函数</em>，r和s分别代表处理前后的pixels值： <span class="math display">\[g(x,y)=T[f(x,y)] \\s=T(r)\]</span>   灰度变换和空间滤波的应用非常广泛，不过本章节以<em>图像增强</em>为例。这在机器学习中也是非常有用的方法，即<em>数据增强</em>相关的应用。</p><h2 id="基本灰度变换">基本灰度变换</h2><p>  下图是图像增强常用的三类基本函数：线性函数（Negative and identity transformations）、对数函数（log and inverse-log transformations）、幂律函数（nth power and nth root transformations），下面分别进行介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307164910865.png" alt="image-20220307164910865" style="zoom: 60%;" /></p><h3 id="图像反转">图像反转</h3><p><span class="math display">\[s=L-1-r\]</span></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307165318001.png" alt="image-20220307165318001" style="zoom:67%;" /></p><h3 id="对数变换与指数变换">对数变换与指数变换</h3><p>  以对数变换为例，改变换<strong>将输入中范围较窄的低灰度值区域，映射到输出中范围较宽的区域，即对暗色pixel做扩展操作；然后，将输入中范围较宽的高灰度值区域，映射到输出中范围较窄的区域，即对亮色pixel做压缩操作</strong>。指数变换作用则刚好相反。 <span class="math display">\[s=c\times log(1+r) \\s=c\times (e^{r}-1)\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307170326476.png" alt="image-20220307170326476" style="zoom: 67%;" /></p><h3 id="幂律伽马变换">幂律（伽马）变换</h3><p><span class="math display">\[s=cr^{\gamma}\]</span></p><p>  用于图像获取、打印和显示的各种设备遵循幂律来产生响应，而校正这些幂律响应现象的处理称为<em>伽马校正</em>。各种显示器都需要通过伽马校正来精确在屏幕上显示图像，伽马校正不仅会改变亮度，也会改变RGB图像中三色的比例。下面这个CRT的例子是课本里的：</p><blockquote><p>For example, cathode ray tube (CRT) devices have an intensity-to-voltage response that is a power function, with exponents varying from approximately 1.8 to 2.5. Such display systems would tend to produce images that are darker than intended. The following figure illustrates this effect.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307170903697.png" alt="image-20220307170903697" style="zoom:67%;" /></p><h3 id="分段线性变换函数">分段线性变换函数</h3><p>  用法更加灵活，很多变换形式能够用分段函数来实现。缺点是需要用户进行手动调整，在一些图像处理软件中可能会用到，例如在Photoshop中。</p><h4 id="对比度拉伸">对比度拉伸</h4><p>  利用两个点<span class="math inline">\((r_2,s_2), (r_1,s_1)\)</span>的位置来控制函数的形状，从而对三个不同区域的灰度值进行扩展/压缩。<strong>我们需要保证函数是单调递增的，避免在处理后的图像中产生人为错误的灰度值</strong>。下图右下是极限的情况，结果是二值化图像，该函数称为<em>Thresholding function</em>，即阈值处理函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307174118049.png" alt="image-20220307174118049" style="zoom:67%;" /></p><h4 id="灰度级分层">灰度级分层</h4><p>  在某些功能性的图像中，我们可能对某种特定灰度值区域的特征感兴趣，因此可以通过突出该区域的pixel来实现增强效果，这在医学成像中是很有用的手段。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307175039192.png" alt="image-20220307175039192" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307175101353.png" alt="image-20220307175101353" style="zoom:67%;" /></p><h4 id="比特平面分层">比特平面分层</h4><p>  在256级灰度图像中，一个像素的大小是1个字节（byte）或8个比特（bits）。这个处理过程稍微有点tricky，如果对概念理解不到位，容易处理成参考链接<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/iwuqing/p/11297280.html">[3]</span></a></sup>中的这种，可以看到结果并没有书上案例的噪声。出现这样结果的原因，是该作者错误理解了根据bit阈值进行划分的方式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://www.manongjc.com/article/29152.html">[2]</span></a></sup>，正确的结果如这个链接<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_42505705/article/details/86769995">[1]</span></a></sup>所示。实际上，对于8-bit，划分为2组，即<span class="math inline">\([0,127], [128,255]\)</span>；对于7-bit，划分为4组，即<span class="math inline">\([0,63],[64,128],[128,191],[192,255]\)</span>，以此类推；对于1-bit，划分为255组，因此才显示像噪声的结果。</p><p>  我自己代码实现了一下，可以看到：<strong>在bit级低的时候，噪声越多（实际上是更精细的灰度细节），类似高频部分；在bit级高的时候，贡献的图像数据更加重要，类似低频部分</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16466576449451.png" alt="output" style="zoom:72%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs python">img = cv2.cvtColor(cv2.imread(<span class="hljs-string">&quot;./Yileina.png&quot;</span>), cv2.COLOR_BGR2GRAY)<br>h,w = img.shape[<span class="hljs-number">0</span>],img.shape[<span class="hljs-number">1</span>]<br><br>new_img = np.zeros((h,w,<span class="hljs-number">8</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w):<br>        n = <span class="hljs-built_in">str</span>(np.binary_repr(img[i,j],<span class="hljs-number">8</span>))<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>            new_img[i,j,k] = n[k]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output.png" alt="output" style="zoom:72%;" /></p><p>  这个技术经常用在图像压缩上，然后根据部分比特平面尝试重建图像，<strong>使用第n个平面的像素乘以常数<span class="math inline">\(2^{n-1}\)</span></strong>，将二值化的图像转变为十进制。例如下图，左侧只有4种灰度值，而右侧细节则丰富多了，重建结果有8种灰度值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">reconstruct = new_img[:, :, <span class="hljs-number">0</span>] * <span class="hljs-number">2</span> ** <span class="hljs-number">7</span> + new_img[:, :, <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> ** <span class="hljs-number">6</span> <span class="hljs-comment"># 8+7 bit</span><br>reconstruct += new_img[:, :, <span class="hljs-number">2</span>] * <span class="hljs-number">2</span> ** <span class="hljs-number">5</span> <span class="hljs-comment"># 8+7+6 bit</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16466590580992.png" alt="output" style="zoom:72%;" /></p><h2 id="直方图处理">直方图处理</h2><p>  灰度级范围为<span class="math inline">\([0,L-1]\)</span>的数字图像的直方图是离散函数<span class="math inline">\(h(r_k)=n_k\)</span>，其中<span class="math inline">\(r_k\)</span>是第k级灰度值，<span class="math inline">\(n_k\)</span>是图像中灰度为<span class="math inline">\(r_k\)</span>的像素个数。实际上，一般常用的是归一化后的直方图（histograms），其中<span class="math inline">\(p(r_k)\)</span>是灰度值<span class="math inline">\(r_k\)</span>在图像中出现的概率： <span class="math display">\[p(r_k)=n_k/MN \quad\quad k=0,1,...,L-1 \\\sum^{L-1}_{k=0}p(r_k)=1\]</span></p><blockquote><p>Histograms are simple to compute and are also suitable for fast hardware implementations, thus making histogram-based techniques a popular tool for real-time image processing.</p></blockquote><ul><li><strong>亮度</strong>：低亮度图像的直方图的分量集中在灰度级的暗端，高亮度图像则集中在亮端</li><li><strong>对比度</strong>：低对比度图像的直方图分布密集集中于一块区域，高对比度则倾向于均匀分布并占据整个可能的灰度级。能够使用一种变换函数来实现灰度级均匀化，最终的效果是一幅<strong>灰度细节丰富且动态范围较大的图像</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220307223810523.png" alt="image-20220307223810523" style="zoom:67%;" /></p><h3 id="直方图均衡">直方图均衡</h3><p>  简单解释，就是<strong>通过概率分布函数将过于集中的直方图在灰度级坐标轴上铺开</strong>，同时保留原本图像的特征，即<strong>原本图像相同灰度值的部分在新图像中仍然是相同灰度值，特征保持不变</strong>。因此，图像的明暗对比度会加大，但图像的分布特点和细节特征却基本保留。</p><p>  核心公式以及证明如下（变限积分求导参考该链接<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/376629429">[4]</span></a></sup>）： <span class="math display">\[\begin{aligned}s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw \\prove \ how \ &amp; it \ works: \\  &amp; \left\{\begin{aligned}p_s(s) &amp; =p_r(r)|\frac{dr}{ds}| \\s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw\end{aligned}\right. \\\\\Rightarrow\frac{ds}{dr} &amp; =\frac{dT(r)}{dr}=(L-1)\frac{d}{dr}[\int^r_0p_r(w)dw]=(L-1)p_r(r) \\\Rightarrow p_s(s) &amp;=p_r(r)|\frac{dr}{ds}|=p_r(r)|\frac{1}{(L-1)p_r(r)}|=\frac{1}{L-1} \quad 0\leq s\leq L-1\end{aligned}\]</span>   关于<span class="math inline">\(s=T(r)\)</span>很重要的一点是单调性的讨论，在直方图均衡中没有用到反变换<span class="math inline">\(r_k=T^{-1}(s_k)\)</span>，但是在直方图匹配中有用到。如下图，如果不能保证<span class="math inline">\(T(r)\)</span>在区间<span class="math inline">\([0,L-1]\)</span>上严格单调递增，则在进行反映射从s的值获取r时可能会出现二义性，即多对一的映射。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220308001824926.png" alt="image-20220308001824926" style="zoom:67%;" /></p><p>  离散时<strong>使用求和代替积分</strong>，处理是类似的。下面是课本中一个具体计算的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220308003017728.png" alt="image-20220308003017728" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220308003218070.png" alt="image-20220308003218070" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220308003239625.png" alt="image-20220308003239625" style="zoom:67%;" /></p><p>  因为直方图是PDF的近似，而且在处理中不允许造成新的灰度级，所以离散的直方图均衡不会产生均匀的新直方图（后续会介绍一种解决该限制的方法）。我这里仍然用伊雷娜来进行实验，我先用gamma变换将图像整体变暗（<span class="math inline">\(\gamma=3\)</span>时），然后再使用直方图均衡调整分布，结果还不错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># gamma transform</span><br>gamma = <span class="hljs-number">3</span><br>gamma_img = (np.power(img / <span class="hljs-number">255.0</span>, gamma) * <span class="hljs-number">255</span>).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># hist equalization</span><br>origin_hist = plt.hist(gamma_img.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>origin_hist_arr = np.array(origin_hist[<span class="hljs-number">0</span>])<br>r_pdf = origin_hist_arr / np.<span class="hljs-built_in">sum</span>(origin_hist_arr)<br>r_cumsum = np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> * np.cumsum(r_pdf)).astype(<span class="hljs-built_in">int</span>)<br>equalized = np.copy(gamma_img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>    equalized[gamma_img == i] = r_cumsum[i]<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-164681540338011.png" alt="output" style="zoom:60%;" /></p><p>  由实验结果能看到有意思的是：<strong>直方图原本数值高的区域在重新分配之后变得稀疏，因此可以猜测，将灰度值分布在坐标轴上的拉伸过程，实际上以数值大小作为拉伸程度的权重</strong>。</p><h3 id="直方图匹配">直方图匹配</h3><p>  直方图均衡能够自动的去寻找合适的变换函数，其变换方式是依赖于输入数据的。<strong>但是直方图均衡不能产生新的数据，当有大量的点处于暗端时，均衡后的图像会产生”冲淡”的外观“</strong>。例如下图，是<span class="math inline">\(\gamma=10\)</span>进行均衡的结果，明显出现“冲淡”。因此我们希望处理后的图像能够具有规定的直方图形状，这种方法就是<em>直方图匹配</em>。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16467969282658.png" alt="output" style="zoom:60%;" /></p><p>  仍然先考虑连续的情况，<span class="math inline">\(p_r(r),p_z(z)\)</span>分别表示输入图像和输出（已处理）图像的连续概率密度函数，<span class="math inline">\(p_z(z)\)</span>是我们希望输出图像所具有的指定PDF。我们希望得到单一变换<span class="math inline">\(z=\hat{T}(s)\)</span>，引入一个均衡变换和一个反变换过程（得到最终变换公式后，中间过渡步骤可以合并，<strong>实际计算付出的代价与均衡操作相同</strong>），推导如下： <span class="math display">\[s=T(r)=(L-1)\int_0^rp_r(w)dw \\G(z)=(L-1)\int^r_0p_z(t)dt=s \\\Rightarrowz=G^{-1}[T(r)]=G^{-1}(s)\]</span>   离散情况类似，但是我们实际上不需要计算<span class="math inline">\(G^{-1}\)</span>的解析式，由<span class="math inline">\(s_k=G(z_q)\)</span>能得到一个整数映射关系（通过四舍五入将计算结果近似为整数），当我们需要求<span class="math inline">\(s_k\)</span>对应的<span class="math inline">\(z_q\)</span>时，查表即可： <span class="math display">\[s_k=T(r_k)=(L-1)\sum^k_{j=0}p_r(r_j)=\frac{L-1}{MN}\sum^k_{j=0}n_j \\G(z_q)=(L-1)\sum^q_{i=0}p_z(z_i)=s_k \\\Rightarrowz_q=G^{-1}(s_k)=G^{-1}[T(r_k)]\]</span>   保持<span class="math inline">\(\gamma=10\)</span>，现在做直方图匹配，将结果进行比较。下面是直方图匹配的实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># origin_hist_arr still use result of &#x27;gamma=10&#x27;, do equalization</span><br>s_k = np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> / np.<span class="hljs-built_in">sum</span>(origin_hist_arr) * np.cumsum(origin_hist_arr)).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># design PDF(z_q)</span><br>z_q = np.zeros_like(origin_hist_arr)<br><span class="hljs-comment"># first</span><br>z_q[:<span class="hljs-number">50</span>] = <span class="hljs-number">250</span> / <span class="hljs-number">50</span> * np.arange(<span class="hljs-number">50</span>)<br>z_q[<span class="hljs-number">50</span>:] = <span class="hljs-number">250</span> - <span class="hljs-number">250</span> / <span class="hljs-number">205</span> * np.arange(<span class="hljs-number">206</span>)<br>z_q = z_q / np.<span class="hljs-built_in">sum</span>(z_q)<br><span class="hljs-comment"># second</span><br>z_q[:<span class="hljs-number">20</span>] = <span class="hljs-number">8</span> * np.arange(<span class="hljs-number">20</span>)<br>z_q[<span class="hljs-number">20</span>:<span class="hljs-number">50</span>] = <span class="hljs-number">160</span> + <span class="hljs-number">2</span> * np.arange(<span class="hljs-number">30</span>)<br>z_q[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>] = <span class="hljs-number">220</span> - <span class="hljs-number">4</span> * np.arange(<span class="hljs-number">50</span>)<br>z_q[<span class="hljs-number">100</span>:<span class="hljs-number">140</span>] = <span class="hljs-number">20</span> - <span class="hljs-number">0.5</span> * np.arange(<span class="hljs-number">40</span>)<br>z_q[<span class="hljs-number">140</span>:<span class="hljs-number">200</span>] = <span class="hljs-number">0.5</span> * np.arange(<span class="hljs-number">60</span>)<br>z_q[<span class="hljs-number">200</span>:] = <span class="hljs-number">30</span> - <span class="hljs-number">0.5</span> * np.arange(<span class="hljs-number">56</span>)<br>z_q = z_q / np.<span class="hljs-built_in">sum</span>(z_q)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-164679744541910.png" alt="output" style="zoom: 40%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># calculate function &#x27;s_k=G(z_q)&#x27;, z_q is the left ranging col </span><br>z_q2s_k = np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> * np.cumsum(z_q)).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># matching s_k and z_q</span><br>last = <span class="hljs-number">0</span><br>matched = np.zeros_like(img)<br>r2z = np.zeros_like(s_k)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):  <span class="hljs-comment"># r -&gt; s</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(last, <span class="hljs-number">256</span>):  <span class="hljs-comment"># z -&gt; s</span><br>        <span class="hljs-keyword">if</span> s_k[i] &lt; z_q2s_k[j]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rk:&#x27;</span>, i, <span class="hljs-string">&#x27;sk:&#x27;</span>, s_k[i], <span class="hljs-string">&#x27;zq2sk:&#x27;</span>, z_q2s_k[j - <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;zq:&#x27;</span>, j - <span class="hljs-number">1</span>)<br>            matched[gamma_img == i] = j - <span class="hljs-number">1</span><br>            last = j - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">rk: <span class="hljs-number">0</span> sk: <span class="hljs-number">147</span> zq2sk: <span class="hljs-number">145</span> zq: <span class="hljs-number">57</span><br>rk: <span class="hljs-number">1</span> sk: <span class="hljs-number">155</span> zq2sk: <span class="hljs-number">155</span> zq: <span class="hljs-number">60</span><br>rk: <span class="hljs-number">2</span> sk: <span class="hljs-number">163</span> zq2sk: <span class="hljs-number">163</span> zq: <span class="hljs-number">63</span><br>rk: <span class="hljs-number">3</span> sk: <span class="hljs-number">166</span> zq2sk: <span class="hljs-number">166</span> zq: <span class="hljs-number">64</span><br>rk: <span class="hljs-number">4</span> sk: <span class="hljs-number">171</span> zq2sk: <span class="hljs-number">171</span> zq: <span class="hljs-number">66</span><br>rk: <span class="hljs-number">5</span> sk: <span class="hljs-number">175</span> zq2sk: <span class="hljs-number">173</span> zq: <span class="hljs-number">67</span><br>rk: <span class="hljs-number">6</span> sk: <span class="hljs-number">180</span> zq2sk: <span class="hljs-number">178</span> zq: <span class="hljs-number">69</span><br>rk: <span class="hljs-number">7</span> sk: <span class="hljs-number">184</span> zq2sk: <span class="hljs-number">183</span> zq: <span class="hljs-number">71</span><br>rk: <span class="hljs-number">8</span> sk: <span class="hljs-number">186</span> zq2sk: <span class="hljs-number">185</span> zq: <span class="hljs-number">72</span><br>...<br></code></pre></td></tr></table></figure><p>  下面的结果分别对应设计的first和second两个<span class="math inline">\(p(z_q)\)</span>函数，可以看出结果较直接进行直方图均衡有很大改善，尤其是设计的第二个函数很好的将原本处于暗部灰度级的像素保持在暗部区域，缓解了冲淡的效果。但是匹配的不能像均衡一样自动进行调整，而需要用户设计目标函数。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16467968565887.png" alt="output" style="zoom:60%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16467970522889.png" alt="output" style="zoom:60%;" /></p><h3 id="局部直方图处理">局部直方图处理</h3><p>  直方图均衡是全局性的，所以会忽略对局部细节的增强，解决方法是<strong>可以用图像中每个像素的邻域中的灰度分布为基础设计变换函数</strong>。即，<em>定义一个邻域，并把该区域的中心按一定stride移动。在原图像每个点的位置，计算邻域中所有点的直方图，并得到局部的直方图均衡化或规定化函数，这个函数最终用于映射邻域中心像素的灰度值。</em>也就是说，通过这种方式进行的直方图均衡化充分考虑了一个点的邻域内的细节特征，虽然这会极大的增大运算量。下面是直接利用前面均衡化函数进行计算的代码<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_43309286/article/details/103036475">[5]</span></a></sup>：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16469207782101.png" alt="output" style="zoom:60%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_equalization</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Do histogram equalization for the input array(image)</span><br><span class="hljs-string">    :param arr: input M x N sized image</span><br><span class="hljs-string">    :return: M x N sized equalized array(image)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    hist = np.histogram(arr.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>    pdf = np.array(hist[<span class="hljs-number">0</span>]) / np.<span class="hljs-built_in">sum</span>(hist[<span class="hljs-number">0</span>])<br>    cdf = np.uint8(np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> * np.cumsum(pdf)))<br>    equal = np.zeros_like(arr)<br>    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>        equal[arr == idx] = cdf[idx]<br>    <span class="hljs-keyword">return</span> equal<br><br>img = cv2.cvtColor(cv2.imread(<span class="hljs-string">&#x27;Fig0326.tif&#x27;</span>), cv2.COLOR_RGB2GRAY)<br>H = img.shape[<span class="hljs-number">0</span>]<br>W = img.shape[<span class="hljs-number">1</span>]<br><br>kernel_size = <span class="hljs-number">3</span><br>stride = <span class="hljs-number">1</span><br>s_half = kernel_size // <span class="hljs-number">2</span><br>l_half = kernel_size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>padded_img = ndarray = np.pad(img, (s_half, s_half))<br><br>local_equalized = np.zeros_like(img)<br>_H = H + <span class="hljs-number">1</span><br>_W = W + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_half, _H, stride):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_half, _W, stride):<br>        local_equalized[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] = hist_equalization(padded_img[i - s_half:i + l_half, j - s_half:j + l_half])[s_half, s_half]<br></code></pre></td></tr></table></figure><table><tr><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/buffer2.png" alt="buffer2" style="zoom:80%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/buffer_size5.png" alt="buffer_size5" style="zoom:80%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/buffer_size7.png" alt="buffer_size7" style="zoom:80%;" /></td><td><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/buffer3.png" alt="buffer3" style="zoom:80%;" /></td></tr></table><p>  上面的结果，从左到右依次为“<code>kernel_size = 3</code>”，“<code>kernel_size = 5</code>”，“<code>kernel_size = 7</code>”，“<code>kernel_size = 3, stride = 2</code>”的情况，从结果中可以猜测：<strong>当kernel size越大，说明每个点参考的邻域范围（周围细节信息）越大，因此效果越好，但是相应的计算量也会增大</strong>。另外，如书本所说，使用非重叠的区域计算也能减少很多的计算量，但是这会导致上图最后的结果，即所谓“棋盘”效应。</p><p>  局部直方图的概念本身比较简单，但如何去优化运算比较tricky。下面是书中的参考思路：</p><ol type="1"><li>建立一个数据结构储存当前邻域的PDF，随着中心位置移动动态更新对应的灰度级数值；</li><li>使用非重叠区域，但是会导致“棋盘”效应；</li></ol><p>  第一个思路的证明在课本习题中给出了，这里可以作为参考。其中<span class="math inline">\(p_r(r_k)\)</span>是邻域内<span class="math inline">\(K\)</span>个点中，对应<span class="math inline">\(r_k\)</span>灰度级的概率密度，<span class="math inline">\(n_{L_k}, n_{R_k}\)</span>是左边删除和右边更新的<span class="math inline">\(k\)</span>灰度级的点的数量： <span class="math display">\[p_r(r_k)=\frac{n_k}{n} \quad\quad k=0, 1, ..., K-1\\\hat{p_r}(r_k)=\frac{1}{n}[n_k-n_{L_k}+n_{R_k}]=p_r(r_k)+\frac{1}{n}[n_{R_k}-n_{L_k}]\]</span></p><h3 id="图像增强中的直方图统计">图像增强中的直方图统计</h3><p>  可以用直方图的统计数据进行图像增强，与前面相同，<span class="math inline">\(p(r_i)\)</span>是直方图中灰度<span class="math inline">\(r_i\)</span>出现的概率估计，下面分别对其二阶矩（方差）、均值进行表示，以及直接用取值方式表示： <span class="math display">\[\begin{aligned}\mu_2(r)&amp; =\sigma^2=\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\m&amp; =\sum^{L-1}_{i=0}r_ip(r_i) \\\sigma^2&amp; = \frac{1}{MN}\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}[f(x,y)-m]^2 \\m&amp; = \frac{1}{MN}\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)\end{aligned}\]</span>   <strong>在局部增强中，局部均值和方差是根据图像中每个像素的邻域内的图像特征进行改变的基础</strong>，这种调整方式是非常灵活且简单的。下面是一种增强的思路，<span class="math inline">\(E,k_0,k_1,k_2,k_3\)</span>是需要设计的参数。现在来考虑四个参数的作用，首先明确目的：<em>我们希望暗部细节增强，也就是从一堆低灰度级中增强略高的灰度级</em>。<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/qq_43800752/article/details/108802520">[6]</span></a></sup></p><ul><li>增强暗部细节，就是将暗部乘上因子<span class="math inline">\(E\)</span>，同时保证明亮区域不变</li><li>设置一个较小的<span class="math inline">\(k_0\)</span>可以限制区域内至少有非0的灰度级，或者是有较亮的点</li><li><span class="math inline">\(k_1\)</span>是一个小于1的参数，如果<span class="math inline">\(m_{S_{xy}}\leq k_1m_G\)</span>时，则将该点作为增强的候选</li><li><span class="math inline">\(k_2\)</span>一般设置为0，因为暗部细节也可能有方差为零的情况，不能漏掉</li><li><span class="math inline">\(k_3\)</span>也可以先设一个较小的数来尝试，因为细节地方并不是很突出</li></ul><p><span class="math display">\[\begin{aligned}m_{S_{xy}} &amp; =\sum^{L-1}_{i=0}r_ip_{S_{xy}}(r_i) \\\sigma^2_{S_{xy}} &amp; =\sum^{L-1}_{i=0}(r_i-m_{S_{xy}})^2p_{S_{xy}}(r_i) \\g(x,y) &amp; =\left\{\begin{aligned}&amp; E \cdot f(x,y), \quad k_0m_G\leq m_{S_{xy}} \leq k_1m_G , \ k_2\sigma_G\leq \sigma_{S_{xy}} \leq k_3\sigma_G\\&amp; f(x,y), \quad otherwise\end{aligned}\right.\end{aligned}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># design</span><br>k0 = <span class="hljs-number">0.02</span><br>k1 = <span class="hljs-number">0.5</span><br>k2 = <span class="hljs-number">0</span><br>k3 = <span class="hljs-number">0.5</span><br>E = <span class="hljs-number">30</span><br><br><span class="hljs-comment"># factor for judgement</span><br>mG = np.average(img)<br>varG = np.var(img)<br>k0mG = k0 * mG<br>k1mG = k1 * mG<br>k2varG = k2 * varG<br>k3varG = k3 * varG<br><br>_kernel_size = <span class="hljs-number">3</span><br><span class="hljs-keyword">assert</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>_s_half = _kernel_size // <span class="hljs-number">2</span><br>_l_half = _kernel_size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>padded = np.pad(img, (_s_half, _s_half))<br><br><span class="hljs-comment"># statistic analysis</span><br>_H = H + <span class="hljs-number">1</span><br>_W = W + <span class="hljs-number">1</span><br>statistic_res = np.copy(img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _H):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _W):<br>        Sxy = padded[i - _s_half:i + _l_half, j - _s_half:j + _l_half]<br>        mSxy = np.average(Sxy)<br>        varSxy = np.var(Sxy)<br>        <span class="hljs-keyword">if</span> k0mG &lt;= mSxy &lt;= k1mG <span class="hljs-keyword">and</span> k2varG &lt;= varSxy &lt;= k3varG:<br>            statistic_res[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>] *= E<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16470132500205.png" alt="output" style="zoom:60%;" /></p><h2 id="空间滤波">空间滤波</h2><p>  空间滤波的机理就是由一个滤波器（或kernel）对图像像素进行某种预定义的操作，然后在邻域中心产生一个新的像素值。空间滤波器有线性与非线性的，非线性的空间滤波器是很强大的工具，也是频域处理所不能实现的功能。通常滤波器尺寸为奇数，这样方便计算也更加直观。例如一个线性滤波器能够写为： <span class="math display">\[g(x,y)=\sum^{a}_{s=-a}\sum^{b}_{s=-b}w(s,t)f(x+s,y+t)=w^Tz(vector\ form)\]</span>   上述也就是所谓相关操作；而卷积表示为： <span class="math display">\[g(x,y)=\sum^{a}_{s=-a}\sum^{b}_{s=-b}w(s,t)f(x-s,y-t)\]</span>   需要能够区分相关与卷积这两个概念：<strong>相关是滤波器模板通过位移计算每个位置乘积之和的处理，而卷积需要将滤波器先旋转180°</strong>。接下来用二维的离散单元冲激来说明：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220310235731977.png" alt="image-20220310235731977" style="zoom:65%;" /></p><ol type="1"><li>一个函数与单位冲激相关，会在该冲激的位置产生该函数的一个翻转版本</li><li><strong>卷积得到的结果和预先进行滤波器翻转得到的结果相同</strong></li><li>从图中能看到padding的大小<code>pad = kernel_size - 1</code>，且除了补零也有其他方法。例如常数填充，镜像填充（用反方向边角的值），重复填充（将边界像素进行扩展）</li><li><strong>相关可以用于寻找图像中的匹配</strong>，假设上述<span class="math inline">\(f\)</span>中包含一个与<span class="math inline">\(w\)</span>完全相等的区域，当<span class="math inline">\(w\)</span>位于该区域中心时，<strong>相关函数（归一化后）的值将是最大的</strong>，这也就是神经网络的应用</li></ol><h3 id="平滑空间滤波器">平滑空间滤波器</h3><p>  平滑滤波器用于模糊处理和降低噪声，模糊处理可以用于一些图像的预处理操作。例如做图像识别之前，可以先用模糊处理去除一些琐碎的细节，提高识别成功率。</p><h4 id="平滑线性滤波器">平滑线性滤波器</h4><p>  也称均值滤波器，从频域观点看可以归类为低通滤波器。实际上是<strong>使用邻域内像素的平均灰度值来替代图像中每个像素的值，这种处理会降低图像灰度的“尖锐”变化，例如噪声</strong>，但也会导致边缘模糊。盒状滤波器是所有系数都相等的均值滤波器，而一般更常用的是加权平均（能够通过增加离中心距离近的点的权重来减少边缘模糊效应）。两种归一化后的均值滤波器公式： <span class="math display">\[R=\frac{1}{9}\sum^{9}_{i=1}z_i \\g(x,y)=\frac{\sum^{a}_{s=-a}\sum^{b}_{s=-b}w(s,t)f(x+s,y+t)}{\sum^{a}_{s=-a}\sum^{b}_{s=-b}w(s,t)}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220311083803766.png" alt="image-20220311083803766" style="zoom:50%;" /></p><p>  下面是使用<code>numpy</code>的实现，查了一圈，好像<code>numpy</code>没有提供二维的卷积或相关操作（图像点乘），所以只能用numpy的矩阵点乘叠两个for循环了。在C++里可以考虑用一个矩阵把kernel的点乘变成矩阵乘法，虽然时间复杂度并没有下降，但在程序设计上能实现内存优化，对于<code>numpy</code>不确定这种操作是否能达到优化效果（测试了有加速，应该是numpy有优化效果）。矩阵点乘优化的证明如下： <span class="math display">\[Image \ A ,\ \ Kernel \ K \\A = \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; ... &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; a_{23} &amp; ... &amp; a_{2n} \\a_{31} &amp; a_{32} &amp; a_{33} &amp; ... &amp; a_{3n} \\... &amp; ... &amp; ... &amp; ... &amp; ... \\a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; ... &amp; a_{mn} \\\end{bmatrix} \quadK = \begin{bmatrix}k_1 &amp; k_2 &amp; k_3 \\ k_4 &amp; k_5 &amp; k_6 \\ k_7 &amp; k_8 &amp; k_9 \\ \end{bmatrix} \\\\Mat = \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{31} &amp; a_{32} &amp; a_{33} \\a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{32} &amp; a_{33} &amp; a_{34}\\ &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp; \\ a_{(m-2)(n-2)} &amp; a_{(m-2)(n-1)} &amp; a_{(m-2)n} &amp; a_{(m-1)(n-2)} &amp; a_{(m-1)(n-1)} &amp; a_{(m-1)n} &amp; a_{m(n-2)} &amp; a_{m(n-1)} &amp; a_{mn}\\\end{bmatrix} \\\\\hat{k} = \begin{bmatrix}k_1 &amp; k_2 &amp; k_3 &amp; k_4 &amp; k_5 &amp; k_6 &amp; k_7 &amp; k_8 &amp; k_9\end{bmatrix}^{T} \\Conv2d(A,K) = (Mat \cdot \hat{k}).Reshape(H, W) \\\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#input image</span><br>img = cv2.cvtColor(cv2.imread(<span class="hljs-string">&quot;./Q3_4.tif&quot;</span>), cv2.COLOR_BGR2GRAY)<br>H = img.shape[<span class="hljs-number">0</span>]<br>W = img.shape[<span class="hljs-number">1</span>]<br>_H = H + <span class="hljs-number">1</span><br>_W = W + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># kernel design</span><br>kernel = <span class="hljs-number">1</span> / <span class="hljs-number">7</span>**<span class="hljs-number">2</span> * np.ones((<span class="hljs-number">7</span>, <span class="hljs-number">7</span>)) <span class="hljs-comment"># box filter</span><br>_kernel_size = kernel.shape[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># pad</span><br><span class="hljs-keyword">assert</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>  <span class="hljs-comment"># only handel odd kernel</span><br>_s_half = _kernel_size // <span class="hljs-number">2</span><br>_l_half = _kernel_size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>padded = np.pad(img, (_s_half, _s_half))<br><br><span class="hljs-comment"># filtering</span><br>box_filtered = np.zeros_like(img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _H):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _W):<br>        box_filtered[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] = np.uint8(<br>            np.<span class="hljs-built_in">round</span>(np.<span class="hljs-built_in">sum</span>(kernel * padded[i - _s_half:i + _l_half, j - _s_half:j + _l_half])))<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16469819718213.png" alt="output" style="zoom:80%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># optimize matrix multiplication</span><br>box_filtered = np.zeros_like(img)<br>big_mat = np.zeros((H * W, _kernel_size * _kernel_size))<br>cnt = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _H):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _W):<br>        big_mat[cnt] = padded[i - _s_half:i + _l_half, j - _s_half:j + _l_half].ravel()<br>        cnt += <span class="hljs-number">1</span><br>box_filtered = (big_mat @ kernel.ravel()).reshape(H, W)<br></code></pre></td></tr></table></figure><h4 id="低通高斯滤波器">低通高斯滤波器</h4><p>  实际上，在上面提到的加权形式的线性滤波器有一般的设计方法，也就是所谓的<em>高斯低通滤波器</em>。我们可以通过下面的公式来设计高斯核，其中<span class="math inline">\(r\)</span>是离中心的距离，符合下图分布： <span class="math display">\[w(s,t)=G(s,t)=Ke^{-\frac{s^2+t^2}{2\sigma^2}}=Ke^{-\frac{r^2}{2\sigma^2}}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220311154055980.png" alt="image-20220311154055980" style="zoom:67%;" /></p><p>  如何设计kernel的大小，可以从高斯分布的3<span class="math inline">\(\sigma\)</span>原理进行理解，即超过该大小之后的kernel并没有实际的效果。因此从isotropy和symmetry的角度考量，<strong>高斯核的大小应该是<span class="math inline">\([6\sigma,6\sigma]\)</span>（注意要取ceil到最近奇数），由标准差决定</strong>。因此，从公式中也能看出，我们设计高斯核所需要的所有参数只有两个:<span class="math inline">\(K,\sigma\)</span>，下面是通过公式sample得到的3x3高斯核：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220311161554849.png" alt="image-20220311161554849" style="zoom:67%;" /></p><p>下面的code是design高斯核的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># design parameter</span><br>K = <span class="hljs-number">1</span><br>sigma = <span class="hljs-number">1</span><br>_kernel_size = np.ceil(<span class="hljs-number">6</span> * sigma).astype(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">if</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    _kernel_size += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># get the distance matrix (might have better way)</span><br>R_gen_size = <span class="hljs-number">3</span> * sigma<br>R_gen_row = np.arange(<span class="hljs-number">1</span>, R_gen_size + <span class="hljs-number">1</span>) ** <span class="hljs-number">2</span><br>R_gen = np.zeros((R_gen_size, R_gen_size))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, R_gen_size + <span class="hljs-number">1</span>):<br>    R_gen[i - <span class="hljs-number">1</span>] = R_gen_row + R_gen_row[i - <span class="hljs-number">1</span>]<br>R_right = np.vstack((np.flipud(R_gen), R_gen_row, R_gen))<br>R_mid = np.r_[np.flip(R_gen_row), [<span class="hljs-number">0</span>], R_gen_row]<br>R_left = np.fliplr(R_right)<br>R = np.hstack((R_left, R_mid.reshape(_kernel_size, <span class="hljs-number">1</span>), R_right))<br><br><span class="hljs-comment"># generate coefficient w</span><br>G = K * np.exp(-R / (<span class="hljs-number">2</span> * sigma ** <span class="hljs-number">2</span>))<br><br><span class="hljs-comment"># generate kernel</span><br>kernel = <span class="hljs-number">1</span> / np.<span class="hljs-built_in">sum</span>(G) * G<br><span class="hljs-keyword">assert</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>  <span class="hljs-comment"># only handel odd kernel</span><br><br>_s_half = _kernel_size // <span class="hljs-number">2</span><br>_l_half = _kernel_size // <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>padded = np.pad(img, (_s_half, _s_half))<br><br><span class="hljs-comment"># filtering</span><br>box_filtered = np.zeros_like(img)<br>big_mat = np.zeros((H * W, _kernel_size * _kernel_size))<br>_H = H + _s_half<br>_W = W + _s_half<br>cnt = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _H):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _W):<br>        big_mat[cnt] = padded[i - _s_half:i + _l_half, j - _s_half:j + _l_half].ravel()<br>        cnt += <span class="hljs-number">1</span><br>box_filtered = (big_mat @ kernel.ravel()).reshape(H, W)<br></code></pre></td></tr></table></figure><h4 id="统计排序滤波器">统计排序滤波器</h4><p>  一种非线性空间滤波器，通过对邻域的像素进行排序来选择中心像素的值。例如，<strong>中值滤波器就是用邻域内灰度的中值来代替该像素</strong>。相比线性均值滤波，中值滤波的边缘模糊更小，并且对<em>椒盐噪声</em>这种随机噪声的效果很好。类似的，统计排序滤波还包括最大值和最小值等类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220311084843302.png" alt="image-20220311084843302" style="zoom:67%;" /></p><p>  实现起来和前面类似，个人感觉算法本身上也没有太多优化的余地，主要是内存和code design方面能够进行优化。下图是3x3的邻域做中值滤波的结果，效果非常好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _H):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_s_half, _W):<br>        order_filtered[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] = np.median(padded[i - _s_half:i + _l_half, j - _s_half:j + _l_half])<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16469931623134.png" alt="output" style="zoom:80%;" /></p><h3 id="锐化空间滤波器">锐化空间滤波器</h3><p>  锐化的本质就是强化边缘的特征，因此直觉上我们会通过微分来处理。本部分和平滑处理对应，主要介绍了各种锐化算子的设计原理。首先回顾一阶和二阶微分在数字图像中的基本知识： <span class="math display">\[\begin{aligned}\mbox{1st order:}\quad &amp;\frac{\partial f}{\partial x}=f(x+1)-f(x) \\\mbox{2st order:} \quad&amp;\frac{\partial^2 f}{\partial x^2}=f(x+1)+f(x-1)-2f(x) \\\end{aligned}\]</span>   下图很好的验证了上面我们对微分的定义。从结果中，我们认为<strong>二阶微分比一阶在增强细节方面更加合适</strong>，因为一阶在坡度变化处的数值非零，因此会产生较粗的边缘。另外，二阶微分会在台阶的过渡部分产生零交叉，这对边缘定位是非常有用的。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220319222255347.png" alt="image-20220319222255347" style="zoom:67%;" /></p><h4 id="拉普拉斯算子">拉普拉斯算子</h4><p>  本质上就是和之前讨论的线性滤波器类似的3 x 3核，特点是符合isotropic的特性： <span class="math display">\[\begin{aligned}\nabla^2&amp;=\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2} \\&amp;=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y) \\\end{aligned}\]</span>   提取系数得到下图中的第一个滤波器，第二个滤波器加上了对角线方向的边缘信息。注意到，中心值是负值意味着我们需要用原图减去滤波的结果，即<span class="math inline">\(g(x,y)=f(x.y)+c[\nabla^2f(x,y)]\)</span>。使用下图后面两种滤波器做加法（乘上因子<code>c=1</code>），在实际中更加常用。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220319230402954.png" alt="image-20220319230402954" style="zoom:67%;" /></p><p>  下面是对一副模糊图像使用lapace算子进行锐化的结果，最后一幅是做了标定之后的结果。可以看到对角线lapace算子对边缘高频的提取确实效果要更好，但是标定感觉会导致图片变灰，可能是标定的方式需要改进。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477501692221.png" alt="output" style="zoom: 33%;" /></p><p>  下面是对一副带噪声的图像进行处理，感觉像是高斯噪声。从结果看出，laplace算子对噪声的放大还是比较明显的（尤其是对角线Laplace算子），因此我后面使用高斯滤波对得到的边缘信息进行一次滤波，再加上原图像，噪声就没有那么明显了。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477504470072.png" alt="output" style="zoom: 33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477506645383.png" alt="output" style="zoom:33%;" /></p><p>  这是对边缘提取结果做了<span class="math inline">\(sigma=2\)</span>的高斯滤波之后，加上原图像的结果，其实看起来还不错，但肉眼可见的还是有噪声增强。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477507140864.png" alt="output" style="zoom: 40%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laplace_sharpen</span>(<span class="hljs-params">arr, method=<span class="hljs-string">&#x27;diag_laplace&#x27;</span>, calibrate=<span class="hljs-literal">False</span>, return_enhanced=<span class="hljs-literal">False</span></span>):</span><br>    kernel = np.array([[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]])<br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;laplace&#x27;</span>:<br>        kernel = np.array([[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><br>    _H = arr.shape[<span class="hljs-number">0</span>]<br>    _W = arr.shape[<span class="hljs-number">1</span>]<br>    _kernel_size = kernel.shape[<span class="hljs-number">0</span>]<br>    _half = _kernel_size // <span class="hljs-number">2</span><br>    _l_half = _half + <span class="hljs-number">1</span><br>    _, arr_big = img2big_mat(arr, _kernel_size) <span class="hljs-comment"># 这个优化方法详见上次空域滤波的lab</span><br>    enhanced = (arr_big @ kernel.ravel()).reshape(_H, _W)<br>    sharpened = arr + enhanced<br>    sharpened[sharpened &gt; <span class="hljs-number">255</span>] = <span class="hljs-number">255</span><br>    <span class="hljs-keyword">if</span> calibrate:<br>        sharpened = (<span class="hljs-number">255</span> * (sharpened - np.<span class="hljs-built_in">min</span>(sharpened)) / np.<span class="hljs-built_in">max</span>(sharpened)).astype(<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">return</span> sharpened <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> return_enhanced <span class="hljs-keyword">else</span> enhanced<br></code></pre></td></tr></table></figure><h4 id="提升滤波">提升滤波</h4><p>  使用unsharp masking的方式，即用原图减去模糊处理后的图像得到mask，再将结果加上原图。下图从频域上解释了非锐化掩蔽的工作原理，使用<span class="math inline">\(k&gt;1\)</span>的权重系数强调了mask的贡献，称为highboost filtering。 <span class="math display">\[\begin{aligned}g_{mask}(x,y)&amp;=f(x,y)-\overline{f}(x,y) \\g(x,y)&amp;=f(x,y)+k*g_{mask}(x,y)\end{aligned}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220320133158266.png" alt="image-20220320133158266" style="zoom: 50%;" /></p><p>  使用k值较大时，会出现下图中部分边缘的pixel超过255，因此边缘对比度明显增强的情况，所以我们要调参k值，保证边缘灰度值的权重刚好合适。总体来说，这种方式效果还是不错的，尤其是对噪声的增强并不明显。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477531722366.png" alt="output" style="zoom:33%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">high_boost</span>(<span class="hljs-params">arr, k=<span class="hljs-number">1</span>, sigma=<span class="hljs-number">3</span>, return_mask=<span class="hljs-literal">False</span></span>):</span><br>    unsharp_mask = arr - gaussian_filter(arr, sigma, <span class="hljs-number">1</span>)<br>    sharpened = (arr + k * unsharp_mask).astype(<span class="hljs-built_in">int</span>)<br>    sharpened[sharpened &gt; <span class="hljs-number">255</span>] = <span class="hljs-number">255</span><br>    <span class="hljs-keyword">return</span> sharpened <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> return_mask <span class="hljs-keyword">else</span> unsharp_mask<br></code></pre></td></tr></table></figure><h4 id="一阶微分锐化">一阶微分锐化</h4><p>  图像中的一阶微分是用梯度幅值实现的。<strong>对于函数<span class="math inline">\(f(x,y)\)</span>，梯度指出了函数<span class="math inline">\(f\)</span>在该处的最大变化率方向，而梯度幅值<span class="math inline">\(M(x,y)\)</span>表示了梯度变化量的值，绘制可得梯度图像</strong>。微分操作不是isotropic的，而使用平方根的方式得到幅值是isotropic的。很多情况下，我们使用L1范数来获取norm，而不是L2，即使L1不是isotropic的。 <span class="math display">\[\begin{aligned}\nabla f &amp;\equiv grad(f) \equiv\begin{bmatrix}g_x \\ g_y\end{bmatrix}\equiv\begin{bmatrix}\frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y}\end{bmatrix}\\M(x,y)&amp;=mag(\nabla f)=\sqrt{g_x^2+g_y^2}\\M(x,y)&amp; \approx|g_x|+|g_y|\\\end{aligned}\]</span>   关于Roberts算子（下图第二行）这里就不实现了，毕竟是二维的算子，我们真正感兴趣的是3 x 3的算子。对x轴和y轴分别定义如下的微分方式，带入上式中得到梯度幅值的Sobel算子。中心系数为2是为了突出中心点的作用，而模板加和为0表明灰度恒定区域的响应为0。 <span class="math display">\[\begin{aligned}g_x&amp;=\frac{\partial f}{\partial x}=(z_7+2z_8+z_9)-(z_1+2z_2+z_3) \\g_y&amp;=\frac{\partial f}{\partial y}=(z_3+2z_6+z_9)-(z_1+2z_4+z_7) \\M(x,y)&amp;\approx |(z_7+2z_8+z_9)-(z_1+2z_2+z_3)|+|(z_3+2z_6+z_9)-(z_1+2z_4+z_7)|\end{aligned}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/image-20220320140820035.png" alt="image-20220320140820035" style="zoom: 67%;" /></p><p>  从结果来看，和之前讨论一阶和二阶的区别相符合，一阶微分会导致较粗的边缘，不过相对而言对噪声的敏感都更低。该结果对<span class="math inline">\(M(x,y)\)</span>乘上了一个因子<code>stretch_k</code>，调整了边缘亮度。使用下图是带噪声的图像使用sobel算子进行锐化的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/output-16477654522518.png" alt="output" style="zoom:33%;" /></p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://blog.csdn.net/qq_42505705/article/details/86769995 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>http://www.manongjc.com/article/29152.html <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>https://www.cnblogs.com/iwuqing/p/11297280.html <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>https://zhuanlan.zhihu.com/p/376629429 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>https://blog.csdn.net/qq_43309286/article/details/103036475 <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>https://blog.csdn.net/qq_43800752/article/details/108802520 <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>滤波</tag>
      
      <tag>NumPy</tag>
      
      <tag>Histogram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git workspace and stage</title>
    <link href="/2022/03/27/2022-3-27-git-workspace-and-stage/"/>
    <url>/2022/03/27/2022-3-27-git-workspace-and-stage/</url>
    
    <content type="html"><![CDATA[<p>  其实git虽然用的很多，不过自己对它的原理和简单的<code>commit</code>、<code>push</code>、<code>pull</code>以外的其他功能并不熟悉，因此在这里做个笔记。</p><span id="more"></span><p>  首先给出下面这张速查<a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf">cheat sheet</a>，不过仅作参考，里面有些实现我自己更习惯用别的指令（后面详说）：</p><figure><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/git-cheat-sheet.png" alt="git-cheat-sheet" /><figcaption aria-hidden="true">git-cheat-sheet</figcaption></figure><h2 id="工作区与暂存区">工作区与暂存区</h2><p>  首先说一下Git版本管理的原理，Git的特点是分布式管理，即每个人电脑上有一份完整的代码，因此不需要联网也能本地工作。因此，<strong>Git的核心技术与功能就在于其智能的merge手段上</strong>。</p><p>  Git的工作流如下图所示，当前本地仓库目录是工作区，有一个隐藏目录<code>.git</code>文件夹，需要在Windows或Linux的资源管理器打开显示选项才能看到。当<code>add</code>之后，文件就添加到暂存区stage里，而通过<code>commit</code>能够将暂存区内的文件提交到History版本库中。版本库中的HEAD指针指向当前分支，如下图的<code>master</code>分支。<strong>个人理解：暂存区相当告诉用户Git在跟踪某个文件的最新修改，因此可以使用随意一点，一般不会使用<code>rm --cached</code>这种命令来撤销跟踪；相对而言，<code>commit</code>的使用需要小心谨慎，提交前最好稍微检查一下代码，尽量不要commit错误代码</strong>。这个问题可以参考这个<a href="https://www.jianshu.com/p/c9f131e22a60">删除 commit 的三种方法</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/0.jpeg" alt="git-repo" style="zoom: 80%;" /></p><p>  首先是add阶段，如果我们希望某个文件不要被Git跟踪，那么将其添加到<code>.gitignore</code>中，针对特定项目的<code>.gitignore</code>模板可以在<a href="https://github.com/github/gitignore">官方仓库</a>中找到。下图左边箭头的意义是，<strong>用上游的最后版本，覆盖下游的修改</strong>。</p><blockquote><p><code>git reset -- files</code> 撤销最后一次<code>git add files</code>，你也可以用<code>git reset</code> 撤销所有暂存区域文件。这行代码作用要与下面的情况区分：当错误提交了某些代码到History库中了（或者提交了<code>&gt;2GB</code>大文件），那么就可以使用<code>git reset HEAD^</code>来退回到上一次commit，<strong>使用<code>git reset -- files</code>对版本库中的文件是不会有任何作用的</strong></p><p><code>git checkout -- files</code> 把文件从暂存区域复制到工作目录，用来丢弃本地修改。<strong>注意作用是从暂存区复制内容来覆盖本地工作区，而不是从暂存区删除内容</strong>，这种情况要用<code>git rm --cached file</code>或<code>git rm --cached -r ./</code>来取消暂存区中对该文件的track</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/basic-usage.svg" alt="img" style="zoom:67%;" /></p><p>  另一个用于解决版本库中<code>commit</code>错误的方式是使用<code>-- amend</code>参数，Git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。这样目测也可以解决大文件上传问题和版本库错误代码问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/commit-amend.svg" alt="img" style="zoom:67%;" /></p><h2 id="其他图示">其他图示</h2><p>  感谢<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html#checkout">Git图解</a>这个网站浅显易懂的说明和非常棒的图示，下面是网页中一些我觉得对理解有帮助的图：</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/conventions.svg" alt="img" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/diff.svg" alt="img" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/checkout-files.svg" alt="img" style="zoom:67%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/reset-commit.svg" alt="img" style="zoom:67%;" /></p><h2 id="举例说明">举例说明</h2><p>  久违的把我一年前刚用Git时创建的仓库拿来练习一下，首先<code>clone</code>到本地。这时候可能会有<code>Permission denied (publickey)</code>的错误，<strong>这可能是由于<code>ssh</code>配置有问题，也有可能是地址打错了</strong>，也有可能再运行一次就成功了（doge</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:Judera9/GitLearning.git<br>Cloning into <span class="hljs-string">&#x27;GitLearning&#x27;</span>...<br>remote: Enumerating objects: 61, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (61/61), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (29/29), <span class="hljs-keyword">done</span>.<br>remote: Total 61 (delta 34), reused 54 (delta 27), pack-reused 0<br>Receiving objects: 100% (61/61), 5.16 KiB | 1.29 MiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (34/34), <span class="hljs-keyword">done</span>.<br><br></code></pre></td></tr></table></figure><p>  看了一下，有个之前创建的<code>dev</code>分支，不妨切换过去试试（其中的那个<code>v1.0</code>时tag，如果切换过去会显示为<code>detached branch</code>）。然后，现在添加一张<code>kiana.png</code>的图片到工作区进行测试。<strong>现在这个图片的状态是<code>Untracked files</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout<br>dev             master          origin/HEAD     v1.0<br>HEAD            origin/dev      origin/master<br><br>$ git checkout dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br>Branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;dev&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br><br>$ git status<br>On branch dev<br>Your branch is up to date with <span class="hljs-string">&#x27;origin/dev&#x27;</span>.<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        kiana.png<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br></code></pre></td></tr></table></figure><p>  接下来按顺序进行如下操作：<em>添加到暂存区、添加到版本库、从版本库中删除并恢复至工作区</em>，试了一下用<code>git reset -- files</code>并没有work，然后发现是我理解错了（这个的作用只是覆盖暂存区修改，相当于撤销最后一次<code>add</code>），需要指定操作类型（<code>git reset [--soft | --mixed | --hard] [HEAD]</code>），试了一下<code>hard</code>，果然直接把之前的commit全部撤销了，<strong>将暂存区和工作区都恢复到上一次commit之前的时间点</strong>。那么这个用来解决经常碰到的“<code>push</code>到一半，由于上传文件大于2GB无法继续”的问题是OK的，只是<strong>注意在<code>commit</code>之后的做了任何修改的话最好备份一下</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add kiana.png<br><br>$ git commit -m <span class="hljs-string">&#x27;update a picture named kiana.png&#x27;</span><br>[dev 3782fd7] update a picture named kiana.png<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 kiana.png<br> <br>$ git lg<br>* 3782fd7 (HEAD -&gt; dev) update a picture named kiana.png<br>*   28c639f (origin/dev) solve the conflict<br>|\<br>| * 2892887 yousa lyrics <span class="hljs-keyword">in</span> English<br>* | e935669 泠鸢中文歌曲-大喜<br>|/<br>* 14dea89 yousa lyrics added<br>* 54e37cb commit a no bug dev<br>... <span class="hljs-comment"># 省略</span><br><br>$ git status<br>On branch dev<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/dev&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>nothing to commit, working tree clean<br><br>$ git reset -- kiana.png<br><br>$ git checkout -- kiana.png<br><br>$ git status<br>On branch dev<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/dev&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>nothing to commit, working tree clean<br><br>$ git reset --hard<br>HEAD is now at 3782fd7 update a picture named kiana.png<br><br>$ git status<br>On branch dev<br>Your branch is behind <span class="hljs-string">&#x27;origin/dev&#x27;</span> by 1 commit, and can be fast-forwarded.<br>  (use <span class="hljs-string">&quot;git pull&quot;</span> to update your <span class="hljs-built_in">local</span> branch)<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        kiana.png<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br></code></pre></td></tr></table></figure><p>  上面这个问题如果换用<code>-soft</code>选项可能是更好的选项，因为相对来说更加安全。从结果看来只是单纯的回退到了之前的版本，内容拷贝到暂存区中了。感觉和<code>--mixed</code>差别不大，后者是默认参数，即<strong>用上一次的commit覆盖当前暂存区</strong>。如果要继续取消track这个文件，可以用<code>rm --cached file</code>（虽然没啥意义）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --soft HEAD^<br><br>$ git status<br>On branch dev<br>Your branch is behind <span class="hljs-string">&#x27;origin/dev&#x27;</span> by 1 commit, and can be fast-forwarded.<br>  (use <span class="hljs-string">&quot;git pull&quot;</span> to update your <span class="hljs-built_in">local</span> branch)<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        new file:   kiana.png<br><br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.runoob.com/git/git-reset.html">git reset 命令</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html#checkout">图解Git</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md">CS-note-Git</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.jianshu.com/p/c9f131e22a60">删除 commit 的三种方法</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>解决报错</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CondaHTTPError解决方法</title>
    <link href="/2022/03/27/2022-3-27-CondaHTTPError-Solution/"/>
    <url>/2022/03/27/2022-3-27-CondaHTTPError-Solution/</url>
    
    <content type="html"><![CDATA[<p>  前段时间终于苦不堪言混乱的pip管理，同时原本C盘下的存储空间也快告吹了，所以投降了anaconda，发现确实好用。之前在Ubuntu下用正常，不过今天在Windows用的时候疯狂报连接错误。我下载的是在Pycharm里部署MicroPython开发环境用到的<code>adafruit-ampy[version='&gt;=1.0.5,&lt;1.1']</code>，但是install的时候一直报下面的错，科学上网也没用：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">CondaHTTPError: HTTP 000 CONNECTION FAILED <span class="hljs-keyword">for</span> url &lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json&gt;<br>Elapsed: -<br><br>An HTTP error occurred when trying to retrieve this URL.<br>HTTP errors are often intermittent, and a simple retry will get you on your way.<br></code></pre></td></tr></table></figure><p>  查了一下，果然是源的问题，我换成了清华源之后就能正常install了。不过用<code>pip install adafruit-ampy</code>默认安装的是1.1.0的版本，因此需要指定<code>pip install adafruit-ampy==1.0.7</code>，因为pycharm目前只支持<code>[version='&gt;=1.0.5,&lt;1.1']</code>。换源的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; conda config --add channels https://mirrors.tuna.tsinghua.<br>edu.cn/anaconda/cloud/conda-forge/<br>&gt; conda config --add channels https://mirrors.tuna.tsinghua.<br>edu.cn/anaconda/pkgs/free/<br>&gt; conda config --<span class="hljs-built_in">set</span> show_channel_urls yes<br>&gt; conda create -n jackko-regression python=2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs bash">Collecting package metadata (current_repodata.json): failed<br>CondaHTTPError: HTTP 000 CONNECTION FAILED <span class="hljs-keyword">for</span> url &lt;https://mirrors.tuna.tsinghua.edu.cn<br>/anaconda/pkgs/free/win-64/current_repodata.json&gt;<br>Elapsed: -<br><br>An HTTP error occurred when trying to retrieve this URL.<br>HTTP errors are often intermittent, and a simple retry will get you on your way.        <br><span class="hljs-string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64&#x27;</span><br><br><br>PS E:\Learning\pythonProject&gt; conda create -n jackko-regression python=2<br>Collecting package metadata (current_repodata.json): <span class="hljs-keyword">done</span><br>Solving environment: <span class="hljs-keyword">done</span><br><br><span class="hljs-comment">## Package Plan ##</span><br><br>  environment location: E:\Applications\Anaconda3-2021-11\envs\jackko-regression        <br><br>  added / updated specs:<br>    - python=2<br><br><br>The following packages will be downloaded:<br><br>    package                    |            build<br>    ---------------------------|-----------------<br>    certifi-2016.2.28          |           py27_0         213 KB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    pip-9.0.1                  |           py27_1         1.6 MB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    python-2.7.13              |                1        23.8 MB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    setuptools-36.4.0          |           py27_1         525 KB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    vc-9                       |       h2eaa2aa_6           5 KB  defaults<br>    vs2008_runtime-9.00.30729.5054|                0        1016 KB  https://mirrors.tun<br>a.tsinghua.edu.cn/anaconda/pkgs/free<br>    wheel-0.29.0               |           py27_0         121 KB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    wincertstore-0.2           |           py27_0          14 KB  https://mirrors.tuna.t<br>singhua.edu.cn/anaconda/pkgs/free<br>    ------------------------------------------------------------<br>                                           Total:        27.3 MB<br><br>The following NEW packages will be INSTALLED:<br><br>  certifi            anaconda/pkgs/free/win-64::certifi-2016.2.28-py27_0<br>  pip                anaconda/pkgs/free/win-64::pip-9.0.1-py27_1<br>  python             anaconda/pkgs/free/win-64::python-2.7.13-1<br>  setuptools         anaconda/pkgs/free/win-64::setuptools-36.4.0-py27_1<br>  vc                 pkgs/main/win-64::vc-9-h2eaa2aa_6<br>  vs2008_runtime     anaconda/pkgs/free/win-64::vs2008_runtime-9.00.30729.5054-0        <br>  wheel              anaconda/pkgs/free/win-64::wheel-0.29.0-py27_0<br>  wincertstore       anaconda/pkgs/free/win-64::wincertstore-0.2-py27_0<br><br><br>Proceed ([y]/n)? y<br><br><br>Downloading and Extracting Packages<br>setuptools-36.4.0    | 525 KB    | <span class="hljs-comment">############################################ | 100%  </span><br>python-2.7.13        | 23.8 MB   | <span class="hljs-comment">############################################ | 100%  </span><br>wincertstore-0.2     | 14 KB     | <span class="hljs-comment">############################################ | 100%  </span><br>certifi-2016.2.28    | 213 KB    | <span class="hljs-comment">############################################ | 100%  </span><br>vs2008_runtime-9.00. | 1016 KB   | <span class="hljs-comment">############################################ | 100%  </span><br>wheel-0.29.0         | 121 KB    | <span class="hljs-comment">############################################ | 100%  </span><br>pip-9.0.1            | 1.6 MB    | <span class="hljs-comment">############################################ | 100%  </span><br>vc-9                 | 5 KB      | <span class="hljs-comment">############################################ | 100%  </span><br>Preparing transaction: <span class="hljs-keyword">done</span><br>Verifying transaction: <span class="hljs-keyword">done</span><br>Executing transaction: <span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To activate this environment, use</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#     $ conda activate jackko-regression</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To deactivate an active environment, use</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#     $ conda deactivate</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
      <tag>解决报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Image Spatial Operations and Filtering</title>
    <link href="/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/"/>
    <url>/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/</url>
    
    <content type="html"><![CDATA[<p>Support <code>.ipynb</code> and images are <a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/spatial%20operation%20and%20filtering">here</a></p><span id="more"></span><h1 id="spatial-transforms-and-filtering">Spatial Transforms and Filtering</h1><ul><li><a href="#spatial-transforms-and-filtering">Spatial Transforms and Filtering</a><ul><li><a href="#introduction">Introduction</a></li><li><a href="#task-1">Task 1</a><ul><li><a href="#histogram-equalization">Histogram Equalization</a><ul><li><a href="#principle">Principle</a></li><li><a href="#pseudo-code">Pseudo Code</a></li><li><a href="#implementation">Implementation</a></li></ul></li></ul></li><li><a href="#task-2">Task 2</a><ul><li><a href="#histogram-match">Histogram Match</a><ul><li><a href="#principle-1">Principle</a></li><li><a href="#pseudo-code-1">Pseudo Code</a></li><li><a href="#implementation-1">Implementation</a></li></ul></li><li><a href="#gamma-transform">Gamma Transform</a></li><li><a href="#local-statistic-enhancement">Local Statistic Enhancement</a></li></ul></li><li><a href="#task-3">Task 3</a><ul><li><a href="#local-histogram-equalization">Local Histogram Equalization</a><ul><li><a href="#principle-2">Principle</a></li><li><a href="#pseudo-code-2">Pseudo Code</a></li><li><a href="#implementation-2">Implementation</a></li></ul></li><li><a href="#gamma-transform-1">Gamma Transform</a></li><li><a href="#local-statistic-enhancement-1">Local Statistic Enhancement</a></li></ul></li><li><a href="#task-4">Task 4</a><ul><li><a href="#box-filter">Box Filter</a><ul><li><a href="#principle-3">Principle</a></li><li><a href="#pseudo-code-3">Pseudo Code</a></li><li><a href="#implementation-3">Implementation</a></li></ul></li><li><a href="#median-filter">Median Filter</a><ul><li><a href="#principle-4">Principle</a></li><li><a href="#pseudo-code-4">Pseudo Code</a></li><li><a href="#implementation-4">Implementation</a></li></ul></li><li><a href="#gaussian-filter">Gaussian Filter</a><ul><li><a href="#principle-5">Principle</a></li><li><a href="#pseudo-code-5">Pseudo Code</a></li><li><a href="#implementation-5">Implementation</a></li></ul></li></ul></li><li><a href="#results">Results</a><ul><li><a href="#task-1-1">Task 1</a></li><li><a href="#task-2-1">Task 2</a></li><li><a href="#task-3-1">Task 3</a></li><li><a href="#task-4-1">Task 4</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></li></ul><h2 id="introduction">Introduction</h2><p>The spatial operations directly operate the pixels of an image, so they are usually efficient and low-resource-occupying. Besides, some spatial nonlinear filtering techniques, like the median filter discussed below, could achieve fantastic results in certain conditions (SAP) rather than other transform domain operations. Therefore, it is significant to learn and implement some classical image spatial operations.</p><p>Spatial operations are mainly divided into intensity transformations and spatial filtering. Intensity transformations usually operate with single pixels, such as gamma transform, which could generally be depicted by <span class="math inline">\(s=T[r]\)</span> (r is a 1 x 1 input pixel, s is the output pixel). Spatial filtering usually operates with the neighbor of pixels, such as linear box filtering.</p><p>The usage of spatial operations are extraordinarily wide, the image enhancement and denoising discussed in this lab are just one of them. Actually, some of the Neural Network and Deep Learning technologies also use spatial operations to extract image features.</p><p>The enhancement methods discussed in this report are listed below:</p><table><colgroup><col style="width: 44%" /><col style="width: 55%" /></colgroup><thead><tr class="header"><th>Enhancement Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>Basic intensity transformation (Gamma transform)</td><td>Gamma transform is the simplest method for implementation, and its result is pretty good after tuning the <span class="math inline">\(\gamma\)</span> factor</td></tr><tr class="even"><td>Histogram equalization</td><td>It can automatically redistribute the gray scales according to histogram, spread out the centralized histogram bins. However, it can not generate new gray scales and would sometimes cause "wash-out"</td></tr><tr class="odd"><td>Histogram matching (specification)</td><td>User need to design a probability distribution <span class="math inline">\(pdf(z_q)\)</span> as a desired histogram. This method could withstand the "wash-out" effect</td></tr><tr class="even"><td>Local Histogram Equalization</td><td>It iterate histogram equalization in small neighbors, the enhancement effect in local details is better, but the time-cost increases as well</td></tr><tr class="odd"><td>Histogram statistic filtering (mean and variance)</td><td>Need to put effort on tuning parameters, but it is more flexible to enhance certain areas or details. Prior knowledge might be essential</td></tr></tbody></table><p>The denoising (SAP) methods discussed in this report are also listed below:</p><table><colgroup><col style="width: 40%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>Denoising Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>Box filter (Linear filter)</td><td>Actually is calculating average in a neighbor. It could smooth some of the noise, but the edge blur are also apparent</td></tr><tr class="even"><td>Median filter</td><td>Might be the best choice for SAP, because it would not cause edge blur effect. But for many other kinds of noise, it might not be a good choice</td></tr><tr class="odd"><td>Gaussian low pass filter (Linear filter)</td><td>For gaussian noise it might be a good choice, but it also cause edge blur like box filter does (but less blur rather than box filter)</td></tr></tbody></table><h2 id="task-1">Task 1</h2><h3 id="histogram-equalization">Histogram Equalization</h3><h4 id="principle">Principle</h4><p><span class="math inline">\(s\)</span> is the processed pixel, <span class="math inline">\(r\)</span> is the input pixel and <span class="math inline">\(p_i(i)\)</span> is the corresponding PDF of gray scale. Note that this is the proof for continuous condition, discrete is similar, changing integral to sum, and the <span class="math inline">\(s=T(r)\)</span> step need to map <span class="math inline">\(s\)</span> to the nearest integer. <span class="math display">\[\begin{aligned}s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw \\prove \ how \ &amp; it \ works: \\  &amp; \left\{\begin{aligned}p_s(s) &amp; =p_r(r)|\frac{dr}{ds}| \\s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw\end{aligned}\right. \\\\\Rightarrow\frac{ds}{dr} &amp; =\frac{dT(r)}{dr}=(L-1)\frac{d}{dr}[\int^r_0p_r(w)dw]=(L-1)p_r(r) \\\Rightarrow p_s(s) &amp;=p_r(r)|\frac{dr}{ds}|=p_r(r)|\frac{1}{(L-1)p_r(r)}|=\frac{1}{L-1} \quad 0\leq s\leq L-1\end{aligned}\]</span></p><h4 id="pseudo-code">Pseudo Code</h4><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist</span>(<span class="hljs-params">arr</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">return the histogram of a given array (ravel or unravel are both fine)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>init histogram <span class="hljs-keyword">with</span> zeros<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> whole gray scale<br>        calculate the number of pixels that <span class="hljs-string">&#x27;value = i&#x27;</span><br>    <span class="hljs-keyword">return</span> histogram<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_equ</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Remap the gray scale of arr according to CDF(r)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    input_hist = hist(arr) <span class="hljs-comment"># `hist` is defined above</span><br>    calculate p(r) by normalizing -&gt; r_pdf<br>    calculate integral[p(r)] by accumulate p(r) -&gt; r_cdf<br>    init output <span class="hljs-keyword">with</span> zeros<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">256</span>:<br>    change pixels(arr) that <span class="hljs-string">&#x27;value = i&#x27;</span> into <span class="hljs-string">&#x27;value = r_cdf[i]&#x27;</span> -&gt; output<br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h4 id="implementation">Implementation</h4><p>Prove the correctness of my histogram method, I compare it with <code>np.histogram</code>, it turns out that they are the same. Note that I do not iterate the whole image with two <code>for</code> loops, because of two reason:</p><ol type="1"><li><code>numpy</code> is written by high quality C in bottom, it is much more efficient than row python codes</li><li>the tricky <code>np.sum</code> method has bottom acceleration supported by <code>numpy</code>, so I iterate all the possible gray values rather than iterate the (H, W) axis with two <code>for</code> loops (Although iterate gray scales has higher time complexity than iterate the image with two <code>for</code>, it is actually faster)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">// <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist</span></span><br><span class="hljs-function"><span class="hljs-title">_hist</span> = <span class="hljs-title">np</span>.<span class="hljs-title">zeros</span>(<span class="hljs-params">_max - _min + <span class="hljs-number">1</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-title">v</span> <span class="hljs-title">in</span> <span class="hljs-title">range</span>(<span class="hljs-params">_min, _max + <span class="hljs-number">1</span></span>):</span><br>    _hist[v] = np.<span class="hljs-built_in">sum</span>(arr == v)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471935845342.png" alt="output" style="zoom:60%;" /></p><p>Only use one <code>for</code> loop to implement this algorithm. Actually, the optimize methods for python is similar with <code>@matlab</code>, which is efficient with matrix operations. Therefore, the object of optimizing python code could be concluded as:</p><ol type="1"><li>use less <code>for</code> loops</li><li>use more <code>numpy</code> methods and matrix operations</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">// <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_equ</span></span><br><span class="hljs-function"><span class="hljs-title">input_hist</span> = <span class="hljs-title">hist</span>(<span class="hljs-params">arr.ravel(<span class="hljs-params"></span>)</span>)</span><br><span class="hljs-function"><span class="hljs-title">r_pdf</span> = <span class="hljs-title">np</span>.<span class="hljs-title">array</span>(<span class="hljs-params">input_hist</span>) / <span class="hljs-title">np</span>.<span class="hljs-title">sum</span>(<span class="hljs-params">input_hist</span>)</span><br><span class="hljs-function"><span class="hljs-title">r_cdf</span> = <span class="hljs-title">np</span>.<span class="hljs-title">round</span>(<span class="hljs-params"><span class="hljs-number">255</span> * np.cumsum(<span class="hljs-params">r_pdf</span>)</span>)</span><br><span class="hljs-function"><span class="hljs-title">output_image</span> = <span class="hljs-title">np</span>.<span class="hljs-title">zeros_like</span>(<span class="hljs-params">arr</span>)</span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-title">idx</span> <span class="hljs-title">in</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-number">256</span></span>):</span><br>    output_image[arr == idx] = r_cdf[idx]<br><span class="hljs-keyword">return</span> output_image<br></code></pre></td></tr></table></figure><h2 id="task-2">Task 2</h2><h3 id="histogram-match">Histogram Match</h3><h4 id="principle-1">Principle</h4><p>First consider the continuous condition, we want to get a transform of <span class="math inline">\(z=\hat{T}[r]\)</span>, <span class="math inline">\(p(z)\)</span> is the desired histogram designed. We introduce a variable <span class="math inline">\(s\)</span> for transition, and we get <span class="math inline">\(z=G^{-1}[T(r)]\)</span>: <span class="math display">\[\begin{aligned}s&amp;=T(r)=(L-1)\int_0^rp_r(w)dw \\G(z)&amp;=(L-1)\int^r_0p_z(t)dt=s \\&amp;\Rightarrowz=G^{-1}[T(r)]=G^{-1}(s)\end{aligned}\]</span> The discrete time condition is similar, we do not need to solve <span class="math inline">\(G^{-1}\)</span> any more, because we can get a integer mapping relationship (round) using <span class="math inline">\(s_k=G(z_q)\)</span>, if we want to know <span class="math inline">\(z_q\)</span>, just iterate the array of <span class="math inline">\(s_k\)</span>. Here is the proof: <span class="math display">\[\begin{aligned}s_k&amp;=T(r_k)=(L-1)\sum^k_{j=0}p_r(r_j)=\frac{L-1}{MN}\sum^k_{j=0}n_j \\G(z_q)&amp;=(L-1)\sum^q_{i=0}p_z(z_i)=s_k \\&amp;\Rightarrowz_q=G^{-1}(s_k)=G^{-1}[T(r_k)]\end{aligned}\]</span></p><h4 id="pseudo-code-1">Pseudo Code</h4><p>First we need to design a <code>z_q</code>, and pass its histogram</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_match</span>(<span class="hljs-params">arr, spec_hist</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Do histogram match according to given spec_hist</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>input_hist = hist(arr) <span class="hljs-comment"># `hist` is defined above</span><br>calculate CDF(s_k) <span class="hljs-keyword">as</span> we do <span class="hljs-keyword">in</span> histogram equalization -&gt; s_k<br>calculate CDF(z_q2s_k) <span class="hljs-keyword">from</span> the given histogram(spec_hist) -&gt; z_q2s_k<br>init output <span class="hljs-keyword">with</span> zeros<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">256</span>:<br>    find the indices that satisfy <span class="hljs-string">&#x27;s_k &lt;= z_q2s_k&#x27;</span> <span class="hljs-keyword">and</span> choose the smallest -&gt; idx<br>    change pixels(arr) that <span class="hljs-string">&#x27;value = i&#x27;</span> into idx -&gt; output<br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h4 id="implementation-1">Implementation</h4><p>I design two <span class="math inline">\(pdf(z_q)\)</span> here, the blue one is expected to be better for easing the "wash-out" effect.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471964888277.png" alt="output" style="zoom:65%;" /></p><p>Notice that I also only use one <code>for</code> loop, I use many <code>numpy</code> tricks to avoid using <code>for</code>. During the for loop, I cut some of the iteration values of all these variables, it works out correctly.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># def hist_match</span><br>input_hist = hist(arr.ravel())<br>s_k = np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> / np.<span class="hljs-built_in">sum</span>(input_hist) * np.cumsum(input_hist))<br>z_q2s_k = np.<span class="hljs-built_in">round</span>(<span class="hljs-number">255</span> * np.cumsum(spec_hist))<br>output_image = np.zeros_like(arr)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):  <span class="hljs-comment"># r -&gt; s</span><br>    idx = np.where(s_k[i] &lt;= z_q2s_k)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># s -&gt; z</span><br>    output_image[arr == i] = idx<br><span class="hljs-keyword">return</span> output_image<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">rk: <span class="hljs-number">0</span> sk: <span class="hljs-number">147</span> zq2sk: <span class="hljs-number">145</span> zq: <span class="hljs-number">57</span><br>rk: <span class="hljs-number">1</span> sk: <span class="hljs-number">155</span> zq2sk: <span class="hljs-number">155</span> zq: <span class="hljs-number">60</span><br>rk: <span class="hljs-number">2</span> sk: <span class="hljs-number">163</span> zq2sk: <span class="hljs-number">163</span> zq: <span class="hljs-number">63</span><br>rk: <span class="hljs-number">3</span> sk: <span class="hljs-number">166</span> zq2sk: <span class="hljs-number">166</span> zq: <span class="hljs-number">64</span><br>rk: <span class="hljs-number">4</span> sk: <span class="hljs-number">171</span> zq2sk: <span class="hljs-number">171</span> zq: <span class="hljs-number">66</span><br>rk: <span class="hljs-number">5</span> sk: <span class="hljs-number">175</span> zq2sk: <span class="hljs-number">173</span> zq: <span class="hljs-number">67</span><br>rk: <span class="hljs-number">6</span> sk: <span class="hljs-number">180</span> zq2sk: <span class="hljs-number">178</span> zq: <span class="hljs-number">69</span><br>rk: <span class="hljs-number">7</span> sk: <span class="hljs-number">184</span> zq2sk: <span class="hljs-number">183</span> zq: <span class="hljs-number">71</span><br>rk: <span class="hljs-number">8</span> sk: <span class="hljs-number">186</span> zq2sk: <span class="hljs-number">185</span> zq: <span class="hljs-number">72</span><br>...<br></code></pre></td></tr></table></figure><h3 id="gamma-transform">Gamma Transform</h3><p>The principle could not be simpler. It is one of the most widely used intensity transformation method, actually it has a pretty good effect on enhancing Q3_2.tif and Q3_3.tif. The time it costs is also very low: <span class="math display">\[s=cr^{\gamma}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gamma_transform</span>(<span class="hljs-params">arr, gamma</span>):</span><br>    gamma_img = np.<span class="hljs-built_in">round</span>(np.power(arr / <span class="hljs-number">255.0</span>, gamma) * <span class="hljs-number">255</span>).astype(<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">return</span> gamma_img<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output.png" alt="output" style="zoom:65%;" /></p><h3 id="local-statistic-enhancement">Local Statistic Enhancement</h3><p>The statistic property we are interested are mean and variance (secondary moment), here we can calculate the global mean <span class="math inline">\(m_G\)</span> and variance <span class="math inline">\(\sigma^2_G\)</span>, then get the standard variance <span class="math inline">\(\sigma_G\)</span>: <span class="math display">\[\begin{aligned}\mu_2(r)&amp; =\sigma^2=\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\m&amp; =\sum^{L-1}_{i=0}r_ip(r_i) \\\end{aligned}\]</span> During local enhancement, we calculate mean and variance of the neighbor, then use the last equation below to decide whether enhance the current pixel or not. <span class="math inline">\(E,k_0,k_1,k_2,k_3\)</span> are the parameters to design and tune. <span class="math display">\[\begin{aligned}m_{S_{xy}} &amp; =\sum^{L-1}_{i=0}r_ip_{S_{xy}}(r_i) \\\sigma^2_{S_{xy}} &amp; =\sum^{L-1}_{i=0}(r_i-m_{S_{xy}})^2p_{S_{xy}}(r_i) \\g(x,y) &amp; =\left\{\begin{aligned}&amp; E \cdot f(x,y), \quad k_0m_G\leq m_{S_{xy}} \leq k_1m_G , \ k_2\sigma_G\leq \sigma_{S_{xy}} \leq k_3\sigma_G\\&amp; f(x,y), \quad otherwise\end{aligned}\right.\end{aligned}\]</span> This method is <code>def local_statistic_adjust(arr, k0, k1, k2, k3, E, m_size=3)</code> in the code file submitted, I have not done many optimization, therefore this method runs more than 10 seconds for Q3_2.tif.</p><p>The result is not desirable, might because the parameter need to be tuned more carefully. However, this image is not suitable for using this method to enhance, because the details do not behave similarly. Another approach for utilizing histogram statistics should be designed.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719917401210.png" alt="output" style="zoom:65%;" /></p><h2 id="task-3">Task 3</h2><h3 id="local-histogram-equalization">Local Histogram Equalization</h3><h4 id="principle-2">Principle</h4><p>There is no equations and proof for this algorithm. Actually, we does histogram equalization for every neighbors. However, this is a very expensive process, therefore I think of another tricky way to implement this algorithm. Like we discussed above, we should use <code>numpy</code> as much as possible and try to reduce operations under <code>for</code> loops. Therefore, I re-organize the neighbors into a <code>Big_Mat</code> and done operations parallelly. <span class="math display">\[\begin{aligned}A &amp;= \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; ... &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; a_{23} &amp; ... &amp; a_{2n} \\a_{31} &amp; a_{32} &amp; a_{33} &amp; ... &amp; a_{3n} \\... &amp; ... &amp; ... &amp; ... &amp; ... \\a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; ... &amp; a_{mn} \\\end{bmatrix} \quad\\Big_Mat &amp;= \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{31} &amp; a_{32} &amp; a_{33} \\a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{32} &amp; a_{33} &amp; a_{34}\\ &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp; \\ a_{(m-2)(n-2)} &amp; a_{(m-2)(n-1)} &amp; a_{(m-2)n} &amp; a_{(m-1)(n-2)} &amp; a_{(m-1)(n-1)} &amp; a_{(m-1)n} &amp; a_{m(n-2)} &amp; a_{m(n-1)} &amp; a_{mn}\\\end{bmatrix} \\\end{aligned}\]</span> Another optimizing method is to maintain a global <span class="math inline">\(pdf\)</span>, then push and pop elements while iterating the neighbors, after judging by experience I think the first one could be more effective, so I just leave the proof here. <span class="math inline">\(n_{L_k}\)</span> is the deleted and <span class="math inline">\(n_{R_k}\)</span> is the new comer pixels: <span class="math display">\[\begin{aligned}p_r(r_k)&amp;=\frac{n_k}{n} \quad\quad k=0, 1, ..., K-1\\\hat{p_r}(r_k)&amp;=\frac{1}{n}[n_k-n_{L_k}+n_{R_k}]=p_r(r_k)+\frac{1}{n}[n_{R_k}-n_{L_k}]\end{aligned}\]</span></p><h4 id="pseudo-code-2">Pseudo Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist</span>(<span class="hljs-params">arr, parallel</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    the input is the (HW x m_size^2) Big_Mat, therefore in this method calculate histogram seperately for each row of Big_Mat. The return array is with size (HW, 256), and each row of it _hist[i] with size (1 , 256) is a single histogram for the (m_size x m_size) neighbor</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    init _hist <span class="hljs-keyword">as</span> zeros<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> whole gray scale<br>        calculate the number of pixels that <span class="hljs-string">&#x27;value = i&#x27;</span> <span class="hljs-keyword">for</span> each row seperately<br>    <span class="hljs-keyword">return</span> _hist<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">img2big_mat</span>(<span class="hljs-params">arr, m_size</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">change the image into the Big_Mat. For example, a (5 x 6) size gray image is the input `arr`. `m_size` is the scale of the neighborhood size, let it be 3. Therefore, the return Big_Mat would be (30 x 9), and each Big_Mat[i] correspond to a flatten neighborhood with 3 x 3 size.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>_H <span class="hljs-keyword">is</span> arr height<br>_W <span class="hljs-keyword">is</span> arr width<br><span class="hljs-keyword">assert</span> that _H, _W are large enough <span class="hljs-keyword">for</span> calculation<br>_half <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>/<span class="hljs-number">2</span> of neighbor scale <span class="hljs-comment"># m_size is odd, _half is the smaller half</span><br>_l_half  = _half + <span class="hljs-number">1</span> <span class="hljs-comment"># _l_half is the larger half</span><br>pad the original image -&gt; _padded<br>init Big_Mat <span class="hljs-keyword">as</span> zeros -&gt; big_mat<br>use cnt to record the count of neighbors (axis[<span class="hljs-number">0</span>] of Big_Mat) -&gt; cnt = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i start <span class="hljs-keyword">from</span> _half to (_H + _half)<br><span class="hljs-keyword">for</span> j start form _half to (_W + _half)<br>big_mat[cnt] <span class="hljs-keyword">is</span> the flattened No.cnt neighbor of _padded<br>cnt++<br><span class="hljs-keyword">return</span> _padded, big_mat<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_equ</span>(<span class="hljs-params">arr, local=<span class="hljs-literal">True</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    This equalization method deal with a different input, arr is not a (H, W) image any more but a (HW x m_size^2) Big_Mat.Actually this method is the core for local histogram equalization, because many core operations are packed here</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>get the total pixels number (H x W) -&gt; _parallel<br>    get the total neighbor pixel number (m_size x m_size) -&gt; _m2<br>    _half <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>/<span class="hljs-number">2</span> of neighbor scale <span class="hljs-comment"># m_size is odd, _half is the smaller half</span><br>    get hist(arr, _parallel) <span class="hljs-keyword">with</span> size of (_parallel x <span class="hljs-number">256</span>) -&gt; input_hist <span class="hljs-comment"># call from the `hist` method above, return histogram is with size (HW x 256)</span><br>    calculate p(r) by normalizing <span class="hljs-keyword">for</span> each row of input_hist -&gt; r_pdf <span class="hljs-comment"># size is (HW, 256)</span><br>    calculate integral[p(r)] by accumulate p(r) <span class="hljs-keyword">for</span> each row of r_pdf -&gt; r_cdf <span class="hljs-comment"># size is (HW, 256)</span><br>    init output <span class="hljs-keyword">with</span> zeros <span class="hljs-comment"># output is (, HW), can be reshape to (H, W), and that is the result of all the local histrogram equalization process</span><br>    find the center pixel values <span class="hljs-keyword">for</span> <span class="hljs-built_in">all</span> the neighborhoods -&gt; center_pixel <span class="hljs-comment"># this is because that we only care with the result of hisotgram equalization of the center pixel, therefore we have no need to calculate the other m_size^2 - 1 pixels </span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (H x W): <span class="hljs-comment"># itherate all the neighborhoods</span><br>    find the histogram equalization result <span class="hljs-keyword">for</span> the center_pixel of the No.i neighborhood -&gt; r_cdf[i, center_pixel[i]]<br>        then update this equalized value to output[i]<br>    <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">local_hist_equ</span>(<span class="hljs-params">arr, m_size</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Nearly all the local histogram equalization process are packed in above methods, here just call them to get the result!</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    call img2big_mat to get the Big_Mat -&gt; _big_mat<br>    call hist_equ to get the result <span class="hljs-keyword">with</span> size (, HW) -&gt;  output_image<br>    then reshape output_image to (H, W)<br>    <span class="hljs-keyword">return</span> output_image<br></code></pre></td></tr></table></figure><h4 id="implementation-2">Implementation</h4><p>I have done this method with only one <code>for</code> loop as well, therefore the speed is very fast compare to the first version of my code (which has two <code>for</code> loop and runs much slower). Here is my first version code, it call the <code>hist_equ(arr)</code> implemented for only one neighborhood, not the efficient <code>hist_equ(arr, _parallel)</code> used above:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># def local_hist_equ_deprecated</span><br>local_equalized = np.zeros_like(img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_half, _H, stride):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_half, _W, stride):<br>        local_equalized[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] = hist_equ(padded_img[i - s_half:i + l_half, j - s_half:j + l_half])[s_half, s_half]<br></code></pre></td></tr></table></figure><p>The implementation codes could be found in supplementary files, I do not list them here. Then I would compare the efficiency of the two strategy. I do local histogram equalization for <code>m_size = 3, 5, 7</code> and plot their running time below:</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722285939316.png" alt="output" style="zoom:65%;" /></p><h3 id="gamma-transform-1">Gamma Transform</h3><p>The gamma transform principle and codes are discussed above in <em>Task 1</em>, here I show the result of it. Surprisingly, the details could be enhanced perfectly as well. In my opinion, I believe that the other intensity transformation methods could enhance the details perfectly as well, like the <em>contrast stretching</em> method. Besides, these intensity transformation methods are usually simple and fast.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471925885981.png" alt="output" style="zoom:65%;" /></p><h3 id="local-statistic-enhancement-1">Local Statistic Enhancement</h3><p>The statistic distribution of Q3_3.tif is much simpler than Q3_2.tif, therefore using statistic method would complete the enhancement task, and the parameters I tuned for the effect shown below are: <code>k0 = 0.02, k1 = 0.5, k2 = 0, k3 = 0.5, E = 30</code>. However, the effect is not as good as gamma transform and local histogram equalization.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722229456914.png" alt="output" style="zoom:65%;" /></p><h2 id="task-4">Task 4</h2><h3 id="box-filter">Box Filter</h3><h4 id="principle-3">Principle</h4><p>Could also be named as <em>Mean Filter</em>, from a view of Frequency Domain, it is a kind of low pass filter. Therefore, some edge information are lost and cause blur effect. Below, <span class="math inline">\(n\)</span> is the kernel size: <span class="math display">\[R=\frac{1}{n^2}\sum^{n^2}_{i=1}z_i \\\]</span> For implementing all the filtering methods, I use the <code>Big_Mat</code> strategy discussed in task 3, here proves that this strategy is useful for all kinds of spatial operations associated with kernels (neighborhoods). It is actually a code design optimization method for changing image convolution (correlation) into matrix multiplication, which has many acceleration methods for different languages: <span class="math display">\[\begin{aligned}&amp;Image \ A ,\ \ Kernel \ K \\A &amp;= \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; ... &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; a_{23} &amp; ... &amp; a_{2n} \\a_{31} &amp; a_{32} &amp; a_{33} &amp; ... &amp; a_{3n} \\... &amp; ... &amp; ... &amp; ... &amp; ... \\a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; ... &amp; a_{mn} \\\end{bmatrix} \quadK = \begin{bmatrix}k_1 &amp; k_2 &amp; k_3 \\ k_4 &amp; k_5 &amp; k_6 \\ k_7 &amp; k_8 &amp; k_9 \\ \end{bmatrix} \\\\Mat &amp;= \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{31} &amp; a_{32} &amp; a_{33} \\a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{32} &amp; a_{33} &amp; a_{34}\\ &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp; \\ a_{(m-2)(n-2)} &amp; a_{(m-2)(n-1)} &amp; a_{(m-2)n} &amp; a_{(m-1)(n-2)} &amp; a_{(m-1)(n-1)} &amp; a_{(m-1)n} &amp; a_{m(n-2)} &amp; a_{m(n-1)} &amp; a_{mn}\\\end{bmatrix} \\\\\hat{k} &amp;= \begin{bmatrix}k_1 &amp; k_2 &amp; k_3 &amp; k_4 &amp; k_5 &amp; k_6 &amp; k_7 &amp; k_8 &amp; k_9\end{bmatrix}^{T} \\&amp; Conv2d(A,K) = (Mat \cdot \hat{k}).Reshape(H, W) \\\end{aligned}\]</span> Another reason for using this <em>Big Mat</em> strategy is that python has a smart memory allocating bottom logic, therefore, the <code>big_mat</code> created has a well-designed memory distribution in bottom, without <strong>hard copy</strong> (by <code>np.copy</code>) of anything.</p><h4 id="pseudo-code-3">Pseudo Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">linear_filter</span>(<span class="hljs-params">arr, box_size</span>):</span><br>    generate the box filtering kernel <span class="hljs-keyword">from</span> given box_size<br>    _H, _W are the shapes of <span class="hljs-built_in">input</span> image<br>_half <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>/<span class="hljs-number">2</span> of neighbor scale <span class="hljs-comment"># m_size is odd, _half is the smaller half</span><br>_l_half  = _half + <span class="hljs-number">1</span> <span class="hljs-comment"># _l_half is the larger half</span><br>    get the Big Mat by calling img2big_mat(arr) -&gt; arr_big<br>    <span class="hljs-keyword">return</span> arr_big @ kernel <span class="hljs-comment"># &#x27;@&#x27; of course is matrix multiplication</span><br></code></pre></td></tr></table></figure><h4 id="implementation-3">Implementation</h4><p>The implementation use the <code>img2big_mat</code> method discussed in Task 3, and <code>linear_filtered</code> is calculated by matrix multiplication, thus it runs very fast (without using any <code>for</code> loop)!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">linear_filter</span>(<span class="hljs-params">arr, box_size=<span class="hljs-number">0</span>, kernel=<span class="hljs-literal">None</span>, pad_mode=<span class="hljs-string">&#x27;constant&#x27;</span></span>):</span><br>    <span class="hljs-keyword">if</span> box_size != <span class="hljs-number">0</span>:<br>        kernel = <span class="hljs-number">1</span> / (box_size ** <span class="hljs-number">2</span>) * np.ones((box_size, box_size))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">assert</span> kernel <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><br>    _H = arr.shape[<span class="hljs-number">0</span>]<br>    _W = arr.shape[<span class="hljs-number">1</span>]<br>    _kernel_size = kernel.shape[<span class="hljs-number">0</span>]<br>    _half = _kernel_size // <span class="hljs-number">2</span><br>    _l_half = _half + <span class="hljs-number">1</span><br>    _, arr_big = img2big_mat(arr, _kernel_size, pad_mode=pad_mode)<br>    linear_filtered = (arr_big @ kernel.ravel()).reshape(_H, _W)<br>    <span class="hljs-keyword">return</span> linear_filtered<br></code></pre></td></tr></table></figure><h3 id="median-filter">Median Filter</h3><h4 id="principle-4">Principle</h4><p>This is a kind of nonlinear spatial filter, it chooses the statistic median value of a neighborhood as its center pixel value. The principle is simple so I do not put redundant equations here.</p><h4 id="pseudo-code-4">Pseudo Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order_filter</span>(<span class="hljs-params">arr, n_size</span>):</span><br>    _H, _W are the shapes of <span class="hljs-built_in">input</span> image<br>_half <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>/<span class="hljs-number">2</span> of neighbor scale <span class="hljs-comment"># m_size is odd, _half is the smaller half</span><br>_l_half  = _half + <span class="hljs-number">1</span> <span class="hljs-comment"># _l_half is the larger half</span><br>    pad the original image -&gt; _padded<br>    init order_filtered <span class="hljs-keyword">with</span> zeros<br>    <span class="hljs-keyword">for</span> i start <span class="hljs-keyword">from</span> _half to (_H + _half)<br><span class="hljs-keyword">for</span> j start form _half to (_W + _half)<br>find median of the correspond neighborhood -&gt; order_filtered[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span> order_filtered<br></code></pre></td></tr></table></figure><h4 id="implementation-4">Implementation</h4><p>Because this is a nonlinear operation, so I could not use <em>Big Mat</em> here for optimizing. As known, matrix multiplication is a linear math tool. However, I use <code>np.median</code> instead, and the speed turns out to be fast enough, even though I iterate using two <code>for</code> loops.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order_filter</span>(<span class="hljs-params">arr, n_size, pad_mode=<span class="hljs-string">&#x27;constant&#x27;</span></span>):</span><br>    <span class="hljs-keyword">assert</span> n_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>  <span class="hljs-comment"># only handel odd kernel</span><br>    _H = arr.shape[<span class="hljs-number">0</span>]<br>    _W = arr.shape[<span class="hljs-number">1</span>]<br>    _half = n_size // <span class="hljs-number">2</span><br>    _l_half = _half + <span class="hljs-number">1</span><br>    padded = np.pad(arr, (_half, _half), mode=pad_mode)<br>    order_filtered = np.zeros_like(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_half, _H):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_half, _W):<br>            order_filtered[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] = np.median(padded[i - _half:i + _l_half, j - _half:j + _l_half])<br>    <span class="hljs-keyword">return</span> order_filtered<br></code></pre></td></tr></table></figure><h3 id="gaussian-filter">Gaussian Filter</h3><h4 id="principle-5">Principle</h4><p>Actually, this is a weighted <em>Mean Filter</em>, and the weights are decided by gaussian distribution. The gaussian kernel could be designed by giving <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(K\)</span>, the standard deviation. Here is the proof: <span class="math display">\[w(s,t)=G(s,t)=Ke^{-\frac{s^2+t^2}{2\sigma^2}}=Ke^{-\frac{r^2}{2\sigma^2}}\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/image-20220314102642943.png" alt="image-20220314102642943" style="zoom:67%;" /></p><p>According to the <span class="math inline">\(3\sigma\)</span> principle, the size of a gaussian kernel should be <span class="math inline">\([6\sigma,6\sigma]\)</span>, and it should ceil to the nearest odd integer. For example, <span class="math inline">\(\sigma=1\)</span> would lead to a <span class="math inline">\([7,7]\)</span> kernel. Another important step for designing gaussian kernel is to get the Distance Matrix shown above.</p><h4 id="pseudo-code-5">Pseudo Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gaussian_filter</span>(<span class="hljs-params">arr, sigma, K</span>):</span><br>    calculate kernel size <span class="hljs-keyword">from</span> sigma -&gt; _kernel_size<br>    get _H, _W <span class="hljs-keyword">from</span> the shapes of arr -&gt; _H, _W<br>    design the Distance Matrix R<br>    genereate gaussian kernel <span class="hljs-keyword">from</span> the equation given <span class="hljs-keyword">in</span> proof -&gt; kernel<br>    do linear filtering just like box_filter does -&gt; gaussian_filtered<br>    <span class="hljs-keyword">return</span> gaussian_filtered<br></code></pre></td></tr></table></figure><h4 id="implementation-5">Implementation</h4><p>I haven't think a better way to get the distance matrix <code>R</code>, so as seen I use many <code>flip</code> methods to design it, they might be redundant and complex. However, the time cost is very low, because I do not use <code>for</code> loop for the filtering process. The core optimizing approach is as the above algorithms.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gaussian_filter</span>(<span class="hljs-params">arr, sigma, K, pad_mode=<span class="hljs-string">&#x27;constant&#x27;</span></span>):</span><br>    _kernel_size = np.ceil(<span class="hljs-number">6</span> * sigma).astype(<span class="hljs-built_in">int</span>)<br>    _H = arr.shape[<span class="hljs-number">0</span>]<br>    _W = arr.shape[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        _kernel_size += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># get the distance matrix</span><br>    R_gen_size = (_kernel_size - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    R_gen_row = np.arange(<span class="hljs-number">1</span>, R_gen_size + <span class="hljs-number">1</span>) ** <span class="hljs-number">2</span><br>    R_gen = np.zeros((R_gen_size, R_gen_size))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, R_gen_size + <span class="hljs-number">1</span>):<br>        R_gen[i - <span class="hljs-number">1</span>] = R_gen_row + R_gen_row[i - <span class="hljs-number">1</span>]<br>    R_right = np.vstack((np.flipud(R_gen), R_gen_row, R_gen))<br>    R_mid = np.r_[np.flip(R_gen_row), [<span class="hljs-number">0</span>], R_gen_row]<br>    R_left = np.fliplr(R_right)<br>    R = np.hstack((R_left, R_mid.reshape(_kernel_size, <span class="hljs-number">1</span>), R_right))<br><br>    <span class="hljs-comment"># generate coefficient w</span><br>    G = K * np.exp(-R / (<span class="hljs-number">2</span> * sigma ** <span class="hljs-number">2</span>))<br>    kernel = <span class="hljs-number">1</span> / np.<span class="hljs-built_in">sum</span>(G) * G<br><br>    <span class="hljs-keyword">assert</span> _kernel_size % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>  <span class="hljs-comment"># only handel odd kernel</span><br>    gaussian_filtered = linear_filter(arr, kernel=kernel, pad_mode=pad_mode)<br>    <span class="hljs-keyword">return</span> gaussian_filtered<br></code></pre></td></tr></table></figure><h2 id="results">Results</h2><p>Tasks for this lab are listed below:</p><ol type="1"><li>Implement the <strong>histogram equalization</strong> to the input images Q3_1_1.tif and Q3_1_2.tif</li><li>Specify a histogram for image Q3_2.tif and implement the <strong>specified histogram matching</strong> to the input image Q3_2.tif</li><li>Implement the <strong>local histogram equalization</strong> to the input images Q3_3.tif</li><li>Implement an algorithm to <strong>reduce the salt and pepper noise</strong> of an image</li></ol><h3 id="task-1-1">Task 1</h3><p>This is the result for Q3_1_1, the time used for my histogram equalization method is <code>0.22960257530212402</code> seconds. The result is the same as <code>opencv</code>, and the histogram are distributed as we expected. <strong>A very interesting phenomenon is that the gray scale with the most pixels would become sparse after redistribution, and on the contrary, the gray scale with only a few pixels tend to be dense after equalization</strong>. The explanation is simple and reasonable: the remapping process refers to <span class="math inline">\(cdf(r)\)</span> which of course would jump when the gray scale occupies a large amount of pixels (just name them <em>dominant gray scales</em>). These <em>dominant gray scales</em> need to be distributed far from each other to make the image have larger contrast, and they actually do.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471951140013.png" alt="output" style="zoom:65%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471951396674.png" alt="output" style="zoom:65%;" /></p><p>This is the result for Q3_1_2, the time used for my histogram equalization method is <code>0.23404693603515625</code> seconds. The histogram is also as expected.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471957811395.png" alt="output" style="zoom:65%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471957969016.png" alt="output" style="zoom:65%;" /></p><h3 id="task-2-1">Task 2</h3><p>The two designed <span class="math inline">\(pdf(z_q)\)</span> are plotted above, we could see that the first one is better as we expected. The following figures proved that using histogram matching could decrease the "wash-out" effect of histogram equalization. The time costed for <span class="math inline">\(z_{q1}\)</span> and <span class="math inline">\(z_{q2}\)</span> are <code>0.6347625255584717</code> and <code>0.62331223487854</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719941724311.png" alt="output" style="zoom:72%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719957060612.png" alt="output" style="zoom:65%;" /></p><p>However, it dramatically turns out that gamma transform might be the best solution for this enhancement task. As seen in the following, I just casually give a factor <span class="math inline">\(\gamma=0.35\)</span> and the details hidden in the right corner appear, and there is not any "wash-out" effect. By the way, the time cost of gamma transform is only <code>0.032987356185913086</code>. The result of local statistic is not good, its running times is <code>19.913657426834106</code> (no optimize, so there are 2 <code>for</code> loops).</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719971968113.png" alt="output" style="zoom:65%;" /></p><h3 id="task-3-1">Task 3</h3><p>If I just use the global histogram equalization method, the result is poor, and cannot extract the details hidden in the black blocks. Ironically, the SAP noise is enhanced as well apparently.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/image-20220314034344199.png" alt="image-20220314034344199" style="zoom:67%;" /></p><p>Here is all the results I get for Q3_3.tif. We could see that when using local equalization: when the <code>m_size</code> is increased from 3 to 7, the details (and noise) become much more clearer and we get better result. This could be explained: when <code>m_size</code> increases, it means that we use a larger neighborhood for deciding the value of center pixels, that is, more information are used. However, the trade-off is that the time cost increases, from <code>4.724057197570801</code> to <code>9.002043008804321</code> for <code>m_size = 3, 7</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722309058217.png" alt="output" style="zoom:65%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722312382318.png" alt="output" style="zoom:65%;" /></p><h3 id="task-4-1">Task 4</h3><p>All the results are plotted here. The running time of order filter is a little higher because it uses two <code>for</code> loops to iterate the image height and width, and time for <code>n_size = 3, 7</code> are <code>3.73285174369812</code> and <code>3.608351707458496</code> seconds. The box filter method time cost are <code>0.29807138442993164</code> and <code>0.4164392948150635</code>, for <code>n_size = 3, 7</code> as well. The corresponding time costs for gaussian filter are <code>0.4878067970275879</code> and <code>0.813880443572998</code>, which are higher than box filter, because it generally has larger kernel size.</p><p>The order filter (Median Filter) has the best denoising result. This is as our expectation, because it is suitable to deal with SAP noise. The other linear filtering methods all cause different level of blur effect. Besides, if I use <em>Zero Padding</em> for kernels that are large, it would cause black margins like the figure below using <span class="math inline">\(\sigma=3.5\)</span> for gaussian filter. Using the <em>Reflected</em> padding strategy would avoid this.</p><p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722624560219.png" alt="output" style="zoom:65%;" /></p><h2 id="conclusion">Conclusion</h2><p>In conclusion for the <em>Enhancement</em> tasks:</p><table><colgroup><col style="width: 43%" /><col style="width: 56%" /></colgroup><thead><tr class="header"><th>Methods</th><th>Conclusion</th></tr></thead><tbody><tr class="odd"><td>Intensity Transformation (like gamma transform)</td><td>The principle of these kinds of methods are really simple, and all we need to do is to design <span class="math inline">\(s=T(r)\)</span> for single pixels. It turns out that gamma transform performs very well for the task 2 &amp;3. Another advantage of Intensity transformation methods is that they could run fast.</td></tr><tr class="even"><td>Global Histogram Methods</td><td>Its core concept is to remap the different gray scales to larger distance with each other. The biggest advantage of Histogram equalization is that it works automatically. However, "wash-out" might occurs if most of the pixels are at the very dark gray scales, using a specification method with a designed histogram could relieve this effect.</td></tr><tr class="odd"><td>Local Histogram Methods</td><td>Local histogram equalization could extract details hidden in an image magically, but it is usually very time-consuming. Besides, all of the histogram methods might inflate the noise somehow, they could not differ noise from details. The histogram statistic methods are very flexible, I only implement one usage of it, but this always associate with heavy tuning works.</td></tr></tbody></table><p>In conclusion for the <em>Filtering</em> task:</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th>Methods</th><th>Conclusion</th></tr></thead><tbody><tr class="odd"><td>Linear Filtering</td><td>Linear filtering methods like box filter and weighted mean filters (gaussian filter) could weaken the SAP noise, but they also cause edge blur. This is because of their low-pass property. In my opinion, they might show their ability deal with some kinds of continuous noise, like gaussian noise.</td></tr><tr class="even"><td>Nonlinear Filtering (Median Filter)</td><td>The advantage of Median Filter for dealing with SAP noise shows the advantage of spatial filtering than frequency filtering. Using the statistic property of neighborhood, like median, might avoid filtering the edge information and cause blur.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>滤波</tag>
      
      <tag>NumPy</tag>
      
      <tag>Histogram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决proxy导致的Connection refused</title>
    <link href="/2022/03/16/2022-3-16-Connection-refused-error-for-proxy/"/>
    <url>/2022/03/16/2022-3-16-Connection-refused-error-for-proxy/</url>
    
    <content type="html"><![CDATA[<p>  这几天我用的科学上网工具更新配置，所以暂时关掉不用。但是在<em>Ubuntu-Network-Network Proxy</em>处关掉代理后发现用<code>wget</code>下载东西时一直报<code>Failed to connect to 127.0.0.1 port 7080: Connection refused</code>这样的错误，立刻就想到这可能是proxy并没有完全禁用，或者是ip和端口没有切换回来。因此，用下面的命令查看当前代理情况，并尝试取消代理设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ env|grep -I proxy <span class="hljs-comment"># find whether proxy is used</span><br><br>no_proxy=<br>https_proxy=http://127.0.0.1:7890/<br>http_proxy=http://127.0.0.1:7890/<br>all_proxy=socks://127.0.0.1:7891/<br><br><span class="hljs-comment"># try to reset proxy, I success on this</span><br>$ <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;&quot;</span><br>$ <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;&quot;</span><br>$ <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-string">&quot;&quot;</span><br>$ <span class="hljs-built_in">export</span> HTTPS_PROXY=<span class="hljs-string">&quot;&quot;</span><br><br>$ wget ... <span class="hljs-comment"># okay!</span><br></code></pre></td></tr></table></figure><p>  在网上看到有的人用<code>unset</code>指令也能关闭代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">unset</span> http_proxy<br>$ <span class="hljs-built_in">unset</span> ftp_proxy<br>$ <span class="hljs-built_in">unset</span> all_proxy<br>$ <span class="hljs-built_in">unset</span> https_proxy<br>$ <span class="hljs-built_in">unset</span> no_proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tricks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Proxy</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Image Interpolation</title>
    <link href="/2022/03/04/2022-3-4-Image-Interpolation/"/>
    <url>/2022/03/04/2022-3-4-Image-Interpolation/</url>
    
    <content type="html"><![CDATA[<p>Support <code>.ipynb</code> and images could be found <a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/interpolation">here</a></p><span id="more"></span><h1 id="image-interpolation">Image Interpolation</h1><ul><li><a href="#image-interpolation">Image Interpolation</a><ul><li><a href="#objectives">Objectives</a></li><li><a href="#principle">Principle</a><ul><li><a href="#geometric-center-alignment">Geometric Center Alignment</a></li><li><a href="#nearest-neighbor-interpolation">Nearest Neighbor Interpolation</a><ul><li><a href="#derivation">Derivation</a></li><li><a href="#pseudo-code">Pseudo Code</a></li></ul></li><li><a href="#bilinear-interpolation">Bilinear Interpolation</a><ul><li><a href="#derivation-1">Derivation</a></li><li><a href="#pseudo-code-1">Pseudo Code</a></li></ul></li><li><a href="#bicubic-interpolation">Bicubic Interpolation</a><ul><li><a href="#derivation-2">Derivation</a></li><li><a href="#pseudo-code-2">Pseudo Code</a></li></ul></li></ul></li><li><a href="#analysis">Analysis</a><ul><li><a href="#brief-results">Brief Results</a></li><li><a href="#nearest-neighbor-interpolation-1">Nearest Neighbor Interpolation</a></li><li><a href="#bilinear-interpolation-1">Bilinear Interpolation</a></li><li><a href="#time-complexity-analysis">Time Complexity Analysis</a><ul><li><a href="#enlarge">Enlarge</a></li><li><a href="#shrunk">Shrunk</a></li></ul></li></ul></li><li><a href="#reference">Reference</a></li></ul></li></ul><h2 id="objectives">Objectives</h2><p>The task of this lab homework is to understand and accomplish codes design for <em>nearest neighbor interpolation, bilinear interpolation and bicubic interpolation</em> in python. The specific implementation of these algorithms is packed in corresponding <code>.py</code> files, the report and test codes are embedded in the <code>.ipynb</code> file. The report contains the derivations, principles and Pseudo codes of the algorithms mentioned above, and then given some optimization, extension and analysis of the results.</p><p>Image Interpolation is a significant issue in DIP, we need it when resizing or distorting images from one pixel grid to another. Therefore, the effect and time consumed by varied interpolation algorithms are extraordinarily important. <strong>However, There is always trade-off between efficiency and effect</strong>.</p><h2 id="principle">Principle</h2><h3 id="geometric-center-alignment">Geometric Center Alignment</h3><p>Actually, during interpolation we view pixel positions not as integer, but as float values, this understanding helps when implementing those interpolation algorithms. The meaning of geometric center alignment is that the original figure and the new figure should be aligned based on the image center, not the left side. To achieve this, a coordinate transform is essential, here is an example as the figure shows (sampling from 4 to 5):</p><p><span class="math display">\[transform factor \ \alpha=\frac{src size}{dst size} \\src=(dst+0.5)\times\alpha-0.5\]</span> If I want to find the position of A' in float, or find the index of its neighbors. Here is the calculation:</p><p><span class="math display">\[\alpha=\frac{5}{4} \\A=(dst+0.5)\times\alpha \\idx_{left}=floor(A-0.5) \\idx_{right}=ceil(A-0.5)\]</span></p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure1.jpeg" height="175"></center><center>fig-1 example of center alignment</center><h3 id="nearest-neighbor-interpolation">Nearest Neighbor Interpolation</h3><h4 id="derivation">Derivation</h4><p>Nearest interpolation is a very simple interpolation method. For a new point of the resized figure, its value is the same with the nearest point of the original figure. The approach we find this nearest point is by using <code>round</code> operation after calculate the position of the new point in the original coordinate(multiply a factor of <span class="math inline">\(\frac{original dimension}{new dimension}\)</span>). Note that before all these operations, we need to transform the indices for center alignment.</p><p>For example, the following <em>fig-2</em> shows an original figure of size 2 x 2, we want to enlarge it to size 3 x 3. Assume <span class="math inline">\((x, y)\)</span> is a point of the resized figure, then its position in the original frame is <span class="math inline">\((2x/3, 2x/3)\)</span>. The result often is a float vector, then round it to integer, e.g., <span class="math inline">\((1, 2) \to (0.67, 1.33) \to (1, 1)\)</span>. Shrunk is similar with enlarging.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure2.jpeg" height="300"></center><center>fig-2 example of nearest neighbor</center><h4 id="pseudo-code">Pseudo Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">// nearest_11910206<br>begin with parameters input_file, [h_new, w_new]<br><br>    // get input array from filename or just array<br>    error handling<br>    array input_raw<br><br>    // get resize factor, the \alpha mentioned above<br>    float h_fac, w_fac<br>    compute h_fac = h_raw / h_new<br>    compute w_fac = w_raw / w_new<br><br>    // get bias values for center alignment<br>    array interpolated<br>    bias float h_bias, w_bias<br>    compute h_bias = 0.5 * h_fac - 0.5<br>    compute w_bias = 0.5 * w_fac - 0.5<br><br>    // two `for` loops to iterate all items in array interpolated<br>    for index i<br>        for index j<br><br>            // get the nearest neighbor&#x27;s index [h_idx, w_idx]<br>            integer h_idx, w_idx<br>            compute h_idx = round(h_bias + h_fac * i)<br>            compute w_idx = round(w_bias + w_fac * j)<br>            update interpolated[i, j]<br><br>    return interpolated<br>end<br></code></pre></td></tr></table></figure><h3 id="bilinear-interpolation">Bilinear Interpolation</h3><h4 id="derivation-1">Derivation</h4><p><strong>Using repeated linear interpolation:</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Bilinear_interpolation. https://en.wikipedia.org/wiki/Bilinear_interpolation.">[1]</span></a></sup></p><p>First consider a linear interpolation example in 1-D, like the following figure. The value of f(x) can be expressed by the two neighbor points: <span class="math inline">\(f(x)=\frac{x_2-x}{x_2-x_1}f(x_1)+\frac{x-x_1}{x_2-x_1}f(x_2)\)</span>. Therefore, f(x) can be seen as a weighted average of f(x_1) and f(x_2). <strong>Significantly, the border condition of bilinear interpolation can be regarded as linear condition during implementation</strong>. Besides, <span class="math inline">\(x_2-x_1\)</span> normally equal to one in image interpolation because the operation is down pixel by pixel.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure4.jpeg" height="150"></center><center>fig-3 linear interpolation</center><p>Then, extend the conclusion to 2-D. Actually, bilinear interpolation is not linear in the whole process but quadratic in the sample location <em>P</em>, it could be expressed in a bilinear polynomial form: <span class="math inline">\(f(x,y)=a_{00}+a_{10}x+a_{01}y+a_{11}xy\)</span>. The basic derivation is by repeat linear interpolation twice. As shown in the figure below, first sample along x-axis:</p><p><span class="math display">\[\begin{equation}\begin{aligned}f(x,y_1) &amp; =\frac{x_2-x}{x_2-x_1}f(Q_1)+\frac{x-x_1}{x_2-x_1}f(Q_2) \\         &amp; =(x_2-x)f(Q_1)+(x-x_1)f(Q_2) \\f(x,y_2) &amp; =\frac{x_2-x}{x_2-x_1}f(Q_3)+\frac{x-x_1}{x_2-x_1}f(Q_4) \\         &amp; =(x_2-x)f(Q_3)+(x-x_1)f(Q_4)\end{aligned}\end{equation}\]</span> Then sample along y-axis (the sequence of sampling along x and y axes can exchange), writing the equation of f(x, y) in matrix form:</p><p><span class="math display">\[\begin{equation}\begin{aligned}f(x,y) &amp; =\frac{y_2-y}{y_2-y_1}f(x,y_1)+\frac{y-y_1}{y_2-y_1}f(x,y_2) \\       &amp; =\frac{y_2-y}{y_2-y_1}[(x_2-x)f(Q_1)+(x-x_1)f(Q_2)]+\frac{y-y_1}{y_2-y_1}[(x_2-x)f(Q_3)+(x-x_1)f(Q_4)] \\       &amp; =\begin{bmatrix}          x_2-x &amp; x-x_1          \end{bmatrix}          \begin{bmatrix}          f(Q_3) &amp; f(Q_1) \\ f(Q_4) &amp; f(Q_2)          \end{bmatrix}          \begin{bmatrix}          y_2-y \\ y-y_1          \end{bmatrix}\end{aligned}\end{equation}\]</span> The points lie in the margin of the <strong>enlarged</strong> figure can be dealt with separately, because it only has 3 or 1 (in the corner) neighbors. Therefore, I do linear interpolation for the points in the margin.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure5.jpeg" height="225"></center><center>fig-4 bilinear interpolation</center><p><strong>Using Polynomial to fit:</strong></p><p>As mentioned above, f(x, y) could be written as a multilinear polynomial, therefore using the values of the 4 neighbor points, we can get: $$ <span class="math display">\[\begin{align}f(x, y) &amp; \approx a_{00}+a_{10}x+a_{01}y+a_{11}xy \\        &amp; \Rightarrow [f(Q_3) \ f(Q_1) \ f(Q_4) \ f(Q_2)]^T \\        \\\begin{pmatrix}f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)\end{pmatrix} &amp; = \begin{pmatrix}1 &amp; x_1 &amp; y_1 &amp; x_1y_1 \\1 &amp; x_1 &amp; y_2 &amp; x_1y_2 \\1 &amp; x_2 &amp; y_1 &amp; x_2y_1 \\1 &amp; x_2 &amp; y_2 &amp; x_2y_2 \\\end{pmatrix}\begin{pmatrix}a_{00} \\ a_{10} \\ a_{01} \\ a_{11}\end{pmatrix} \\\\\begin{pmatrix}a_{00} \\ a_{10} \\ a_{01} \\ a_{11}\end{pmatrix} &amp; = \frac{1}{(x_2-x_1)(y_2-y_1)}\begin{pmatrix}x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\1 &amp; -1 &amp; -1 &amp; 1 \\\end{pmatrix}\begin{pmatrix}f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)\end{pmatrix} \\\\              &amp; =\begin{pmatrix}x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\1 &amp; -1 &amp; -1 &amp; 1 \\\end{pmatrix}\begin{pmatrix}f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)\end{pmatrix} \\\\f(x,y) &amp; = \begin{pmatrix}1 &amp; x &amp; y &amp; xy\end{pmatrix}\begin{pmatrix}x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\1 &amp; -1 &amp; -1 &amp; 1 \\\end{pmatrix}\begin{pmatrix}f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)\end{pmatrix} \\\end{align}\]</span> $$ <strong>Using Weighted Mean</strong></p><p>In another view, as mentioned we can see the interpolation as weighted average over the 4 neighbor values, therefore we can a vector <span class="math inline">\(w\)</span> to denote the weights. <span class="math display">\[\begin{align}f(x, y) &amp; \approx w_{1}f(Q_{1})+w_{2}f(Q_{2})+w_{3}f(Q_{3})+w_{4}f(Q_{4}) \\        &amp; =\begin{pmatrix}f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)\end{pmatrix}\begin{pmatrix}w_3 \\ w_1 \\ w_4 \\ w_2\end{pmatrix}\end{align}\]</span> Substitute the knowledge of the former polynomial principle, we can get the following result. The weights must add up to 1 for different order of terms. Then extract the weights by do inversing, we get a new matrix form for bilinear interpolation. <span class="math display">\[\begin{align}\begin{pmatrix}1 \\ x \\ y \\ xy\end{pmatrix} &amp; =\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 \\x_1 &amp; x_1 &amp; x_2 &amp; x_2 \\y_1 &amp; y_2 &amp; y_1 &amp; y_2 \\x_1y_1 &amp; x_1y_2 &amp; x_2y_1 &amp; x_2y_2\end{pmatrix}\begin{pmatrix}w_3 \\ w_1 \\ w_4 \\ w_2\end{pmatrix} \\\\f(x,y) &amp; =\begin{pmatrix}f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)\end{pmatrix}\begin{pmatrix}w_3 \\ w_1 \\ w_4 \\ w_2\end{pmatrix} \\ &amp; = \frac{1}{(x_2-x_1)(y_2-y_1)}\begin{pmatrix}f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)\end{pmatrix}\begin{pmatrix}x_2y_2 &amp; -y_2 &amp; -x_2 &amp; 1 \\-x_2y_1 &amp; y_1 &amp; x_2 &amp; -1 \\-x_1y_2 &amp; y_2 &amp; x_1 &amp; -1 \\x_1y_1 &amp; -y_1 &amp; -x_1 &amp; 1\end{pmatrix}\begin{pmatrix}1 \\ x \\ y \\ xy\end{pmatrix} \\&amp; =\begin{pmatrix}f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)\end{pmatrix}\begin{pmatrix}x_2y_2 &amp; -y_2 &amp; -x_2 &amp; 1 \\-x_2y_1 &amp; y_1 &amp; x_2 &amp; -1 \\-x_1y_2 &amp; y_2 &amp; x_1 &amp; -1 \\x_1y_1 &amp; -y_1 &amp; -x_1 &amp; 1\end{pmatrix}\begin{pmatrix}1 \\ x \\ y \\ xy\end{pmatrix}\end{align}\]</span> However, it is easy to discover that this matrix form has strong similarity with the one derived from polynomial fitting. In my intuition this methods have the same time complexity with the last one, therefore I do not implement this method to codes.</p><h4 id="pseudo-code-1">Pseudo Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">// bilinear_11910206<br>begin with parameters input_file, [h_new, w_new]<br><br>    // get input array from filename or just array<br>    error handling<br>    array input_raw<br><br>    // get resize factor, the \alpha mentioned above<br>    float h_fac, w_fac<br>    compute h_fac = h_raw / h_new<br>    compute w_fac = w_raw / w_new<br><br>    // get bias values for center alignment<br>    array interpolated<br>    bias float h_bias, w_bias<br>    compute h_bias = 0.5 * h_fac - 0.5<br>    compute w_bias = 0.5 * w_fac - 0.5<br><br>    // get the indexes that represent margins<br>    integer h_max, w_max, h_margin, w_margin<br>    compute h_max = h_raw - 1<br>    compute w_raw = w_raw - 1<br>    compute h_margin = floor(0.5 / h_fac + 0.5)<br>    compute h_margin = floor(0.5 / w_fac + 0.5)<br><br>    // assign values for the 4 corners<br>    interpolated[left-top] = input_raw[0, 0]<br>    interpolated[right-top] = input_raw[0, w_raw]<br>    interpolated[left-down] = input_raw[h_max, 0]<br>    interpolated[right-down] = input_raw[h_max, w_raw]<br><br>    // assign values for the 4 borderline margins<br>    for index j<br><br>        // handle 2 horizontal borderline margins<br>        float y<br>        integer y1, y2<br>        compute y = w_bias + w_fac * j<br>        compute y1 = floor(y)<br>        compute y2 = ceil(y)<br><br>        // do linear intepolation in y direction<br>        interpolated[left-border] = (y2 - y) * input_raw[0, y1] + (y - y1) * input_raw[0, y2]<br>        interpolated[right-border] = (y2 - y) * input_raw[h_max, y1] + (y - y1) * input_raw[h_max, y2]<br><br>    for index i<br><br>        // handle 2 vertical borderline margins<br>        float x<br>        integer x1, x2<br>        compute x = h_bias + h_fac * i<br>        compute x1 = floor(x)<br>        compute x2 = ceil(x)<br><br>        // do linear intepolation in x direction<br>        interpolated[up-border] = (x2 - x) * input_raw[x1, 0] + (x - x1) * input_raw[x2, 0]<br>        interpolated[down-border] = (x2 - x) * input_raw[x1, w_max] + (x - x1) * input_raw[x2, x_max]<br><br>    // embedded 2 `for` loops to iterate all items in the center part<br>    for index i exclude margin<br>        for index j exclude margin<br>            float x, y<br>            integer x1, y1, x2, y2<br>            compute x = h_bias + h_fac * i<br>            compute y = w_bias + w_fac * j<br>            compute x1 = floor(x)<br>            compute y1 = floor(y)<br>            compute x2 = ceil(x)<br>            compute y2 = ceil(y)<br><br>            update interpolated[i, j]<br>            compute f(x, y) // equations are given above for different methods<br><br>    return interpolated<br>end<br></code></pre></td></tr></table></figure><h3 id="bicubic-interpolation">Bicubic Interpolation</h3><h4 id="derivation-2">Derivation</h4><p>According to the paper in IEEE, I learn this convolution method for bicubic interpolation (there are other approaches).<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Cubic convolution interpolation for digital image processing">[3]</span></a></sup> The strategy is like the polynomial and weight method of bilinear interpolation, but this time we have 16 coefficients rather than 4. The general function is: <span class="math display">\[\sum^{3}_{i=0}\sum^{3}_{j=0}a_{ij}x^iy^j\]</span> The crucial objective is to solve the <span class="math inline">\(a_{ij}\)</span> coefficients. The paper introduces a BiCubic function: <span class="math display">\[\begin{align}W(x) &amp; =\left\{\begin{aligned}&amp; (a+2)|x|^3-(a+3)|x|^2 +1 &amp;     &amp; {for \ |x|\leqslant1} \\&amp; a|x|^3-5a|x|^2+8a|x|-4a &amp;     &amp; {for \ 1&lt;|x|&lt;2} \\&amp; 0 &amp;     &amp; {otherwise} \end{aligned}\right. \\a &amp; = -0.5 \ or \ -0.75\end{align}\]</span> Let <span class="math inline">\(0&lt;x&lt;1\)</span>, therefore <span class="math inline">\(1&lt;x+1&lt;2\)</span>, <span class="math inline">\(-1&lt;x-1&lt;0\)</span>, <span class="math inline">\(-2&lt;x-2&lt;-1\)</span>, then we substitute to the 4 conditions to <span class="math inline">\(W(x)\)</span>, we could get corresponding equations. Substitute to the <span class="math inline">\(x_1\to x_4\)</span>, and <span class="math inline">\(y_1\to y_4\)</span> we get two 1 x 4 vectors <span class="math inline">\(\{w_x, w_y\}\)</span>. The final result could be: <span class="math display">\[\begin{align}f(x,y)=\begin{pmatrix}w_{x1} &amp; w_{x2} &amp; w_{x3} &amp; w_{x4}\end{pmatrix}\begin{pmatrix}Q_{11} &amp; Q_{12} &amp; Q_{13} &amp; Q_{14} \\Q_{21} &amp; Q_{22} &amp; Q_{23} &amp; Q_{24} \\Q_{31} &amp; Q_{32} &amp; Q_{33} &amp; Q_{34} \\Q_{41} &amp; Q_{42} &amp; Q_{43} &amp; Q_{44} \\\end{pmatrix}\begin{pmatrix}w_{y1} \\ w_{y2} \\ w_{y3} \\ w_{y4}\end{pmatrix}\end{align}\]</span> Because of time limit, I am still debugging this algorithm..., therefore I use <code>scipy</code> to accomplish it.</p><h4 id="pseudo-code-2">Pseudo Code</h4><p>I implement this by using <code>scipy</code>, according to the reference.<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="scipy.interpolate.interp2d. https://bbs.huaweicloud.com/blogs/329665.">[2]</span></a></sup></p><h2 id="analysis">Analysis</h2><p>Here I import some 3rd-party libraries permitted by teacher, and the <code>xxx_11910206</code> files are solutions of this homework:</p><ol type="1"><li><code>cv2</code>: the python-OpenCV package, used for reading images and comparison</li><li><code>numpy</code>: high efficiency calculating tool, written by C/C++ (using CPU)</li><li><code>matplotlib</code>: built-in image processing package, used for showing visualization of results</li><li><code>xxx_11910206</code>: self implemented algorithms</li><li><code>scipy</code>: contains many scientific math algorithms, like interpolation</li></ol><p>I use two other <code>ndarray test</code> and <code>ndarray test_3</code> for testing my algorithms, the reasons are listed below. Then I set <code>np.random.seed(0)</code> in order to control the result of random generated tests. The "seed" would help to make the results of my <code>ipynb</code> file repeatable:</p><ol type="1"><li>The size of the given image is a square, but my codes support rectangular input, therefore I would like to use a new test for showing the generalization capability. Besides, I want to show that my algorithms can handle RGB images as well.</li><li>The pixel image could better depict the difference of different algorithms, it could be helpful for analyzing. The change in visualization is much more obvious. However, I will still use the given figure for time complexity testing.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">from</span> nearest_11910206 <span class="hljs-keyword">import</span> nearest_11910206<br><span class="hljs-keyword">from</span> bilinear_11910206 <span class="hljs-keyword">import</span> bilinear_11910206<br><span class="hljs-keyword">from</span> bicubic_11910206 <span class="hljs-keyword">import</span> bicubic_11910206<br><br>%matplotlib inline<br><br>np.random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># repeatable</span><br>test = np.uint8(np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, size=(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)))<br>test_3 = np.uint8(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)))<br>raw_gray = cv2.cvtColor(cv2.imread(<span class="hljs-string">&#x27;rice.tif&#x27;</span>), cv2.COLOR_BGR2GRAY)<br></code></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_3_0.png" alt="png"  /></center><p>​</p><h3 id="brief-results">Brief Results</h3><p>Here is all the results that required of this homework.</p><p><strong>Nearest Neighbor Interpolation</strong>: According to analysis and the efficiency test in the last part, this is the fastest algorithms. The pay-off is that it would occur discontinuity and obvious serration.</p><p><strong>Bilinear Interpolation</strong>: It is more complex than Nearest Neighbor, but it do not have serration for the result gray image. Basically, the result is smooth and continuous, but this method would filter some high-frequency component, thus the image might be a little faintness.</p><p><strong>Bicubic Interpolation</strong>: The time complexity is the greatest, but the interpolation effect is the best. It is important to choose a proper weight policy, exactly choosing an appropriate kernel. The kernel value is usually set to -0.5 or -0.75 (OpenCV set as -0.75).</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_6_0.png" alt="png" style="zoom:80%;" /></center><h3 id="nearest-neighbor-interpolation-1">Nearest Neighbor Interpolation</h3><p>Comparing the result of OpenCV with self-implemented, they are the same when enlarging. Besides, the result shows that I can apply different resized factors in x and y axes.</p><p>During enlarging the figure, nearest neighbor algorithm cannot interpolate smoothly among the original pixels, the boundaries of color blocks is significantly clear.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_8_0.png" alt="png"  /></center><p>The results of OpenCV and self-implemented algorithms differ when operating shrunk, I look through the code of OpenCV and find that it uses <code>cvFloor</code> , which cutoff the integer part of a float number while I use <code>round</code> to get the neighbors, thus the down-sample result of OpenCV would lean to the left and top sides while mine is center aligned. The comparison of pixel values are also provided below:</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_9_0.png" alt="png"  /></center><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Raw:</span><br> [[<span class="hljs-number">172</span>  <span class="hljs-number">47</span> <span class="hljs-number">117</span> <span class="hljs-number">192</span>  <span class="hljs-number">67</span> <span class="hljs-number">251</span> <span class="hljs-number">195</span>]<br> [<span class="hljs-number">103</span>   <span class="hljs-number">9</span> <span class="hljs-number">211</span>  <span class="hljs-number">21</span> <span class="hljs-number">242</span>  <span class="hljs-number">36</span>  <span class="hljs-number">87</span>]<br> [ <span class="hljs-number">70</span> <span class="hljs-number">216</span>  <span class="hljs-number">88</span> <span class="hljs-number">140</span>  <span class="hljs-number">58</span> <span class="hljs-number">193</span> <span class="hljs-number">230</span>]<br> [ <span class="hljs-number">39</span>  <span class="hljs-number">87</span> <span class="hljs-number">174</span>  <span class="hljs-number">88</span>  <span class="hljs-number">81</span> <span class="hljs-number">165</span>  <span class="hljs-number">25</span>]<br> [ <span class="hljs-number">77</span>  <span class="hljs-number">72</span>   <span class="hljs-number">9</span> <span class="hljs-number">148</span> <span class="hljs-number">115</span> <span class="hljs-number">208</span> <span class="hljs-number">243</span>]]<br><span class="hljs-attr">OpenCV:</span><br> [[<span class="hljs-number">172</span> <span class="hljs-number">117</span>  <span class="hljs-number">67</span>]<br> [ <span class="hljs-number">70</span>  <span class="hljs-number">88</span>  <span class="hljs-number">58</span>]]<br><span class="hljs-attr">Mine:</span><br> [[  <span class="hljs-number">9</span>  <span class="hljs-number">21</span>  <span class="hljs-number">36</span>]<br> [ <span class="hljs-number">87</span>  <span class="hljs-number">88</span> <span class="hljs-number">165</span>]]<br></code></pre></td></tr></table></figure><p>I extend my codes for RGB images, actually, this is nearly the same as operating gray images, what's new is to do interpolation separately in 3 color channels. I use the following code to judge what shape of array should be returned: <code>interpolated = np.zeros(dim, dtype=int) if input_raw.ndim == 2 else np.zeros((dim[0], dim[1], 3), dtype=int)</code>. When updating the returned array <code>interpolated</code>, use the convenient numpy operator <code>:</code> (numpy is much more efficient than raw python codes), the RGB channels could be calculated within one line of code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> input_raw.ndim == <span class="hljs-number">2</span>:<br>    interpolated[i, j] = input_raw[r_idx, c_idx] <span class="hljs-comment"># calculate gray figure</span><br><span class="hljs-keyword">else</span>:<br>    interpolated[i, j, :] = input_raw[r_idx, c_idx, :] <span class="hljs-comment"># calculate RGB figure</span><br></code></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_11_0.png" alt="png"  /></center><h3 id="bilinear-interpolation-1">Bilinear Interpolation</h3><p>Below is to sample the "Random Raw" to 100 x 100, the result is similar with OpenCV. The figure with title "Self-linear2" uses repeated linear interpolation, and the one with "Self-polyfit" uses polynomial fit.</p><p>It also supports RGB figures just like <code>nearest_11910206</code> does. From the results, we could see that bilinear interpolation has better effect than nearest neighbor, it could compensate some transitional values between the original color blocks.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_13_0.png" alt="png"  /></center><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_14_0.png" alt="png" style="zoom:100%;" /></center><p>From the figure above with title "Inverse-Shrunk", it is down-sampled back to 5 x 5 from the image up-sampled to 100 x 100. It reveal that the bilinear process dramatically could be inverse! From wiki, I get the following proof for Inverse computation under special condition (if the point is inside any convex quadrilateral, which means 4-border-polygons that are convex, the "unit square coordinates" could be found).<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Bilinear_interpolation. https://en.wikipedia.org/wiki/Bilinear_interpolation.">[1]</span></a></sup></p><p>The <span class="math inline">\(\{a, b, c, d\}\)</span> could be seen as weights of current interpolation, the unit square are parameterized by <span class="math inline">\(\{\lambda,\mu\}\in[0, 1]\)</span> . The target is to solve these two parameters. <span class="math display">\[\begin{align}&amp; a + b\lambda+c\mu+d\lambda\mu=0 \\\\&amp; a = x_{00} - x \\&amp; b = x_{10} - x_{00} \\&amp; c = x_{01} - x_{00} \\&amp; d = x_{11} - x_{01} - x_{10} + x_{00} \\\end{align}\]</span> Take 2-d cross product of the system, reveals that: <span class="math display">\[\begin{align}&amp; (a+b\lambda+c\mu)\times d &amp; = 0 \\&amp; (a+b\lambda)\times (c+d\mu) &amp; = 0 \\&amp; (a+c\mu)\times (b+d\mu) &amp; = 0 \\&amp; \Rightarrow \\&amp; C+E\lambda+F\mu &amp; = 0 \\&amp; B+(C+D)\lambda +E\lambda^2 &amp; = 0 \\&amp; A+(C-D)\mu+F\mu^2 &amp; = 0 \\\\&amp; with \\&amp; A=a\times b \quad B=a\times c \quad C=a\times d \\&amp; D=b\times c \quad E=b\times d \quad F=c\times d\end{align}\]</span> Use quadratic formula to solve the equations, we get: <span class="math display">\[\mathbb{D}=(C+D)^2-4EB=(C-D)^2-4FA \\\Rightarrow \quad \lambda=\frac{-C-D\pm \sqrt{\mathbb{D}}}{2E} \quad \mu=\frac{-C+D\pm \sqrt{\mathbb{D}}}{2F}\]</span> This might explain the dramatic inverse property I found, actually I not sure I totally understand it...</p><h3 id="time-complexity-analysis">Time Complexity Analysis</h3><h4 id="enlarge">Enlarge</h4><p>I use the built-in <code>time</code> package in python to record running time in float seconds, and then use <code>matplotlib</code> to plot them, here shows the results. The time complexity of bilinear interpolation and nearest neighbor interpolation are both <span class="math inline">\(O(N^2)\)</span>, due to the embedded two for loops. Apparently, bilinear cost more time than nearest neighbor, because it does more calculation in the for loops, which also means that bilinear interpolation has larger coefficient for the 2nd-order term.</p><p>Compare the two bilinear methods, it turns out that when interpolated size is under 800 they hardly have difference. Therefore, it is reasonable to guess that using repeated linear interpolation and polynomial fitting occupy similar calculation.</p><p>OpenCV test is weird, I guess it might have down different optimization strategies for these 3 methods. By the way, when interpolated size is larger than 3000, the time cost of nearest neighbor method would increase horribly.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/buffer_time_result_2.png" alt="png" style="zoom:100%;" /></center><h4 id="shrunk">Shrunk</h4><p>The shrunk result is similar with enlarge, a interesting fact is that shrunk cost much less time than enlarge. This means that the limitation and challenge of interpolation problem is up-sample rather than down-sample. For example, recovering image and super-resolution task might be relevant to this, I guess.</p><p>The OpenCV result is still strange, might relate to its bottom optimization or it use other methods instead.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/buffer_time_result_3.png" alt="png" style="zoom:100%;" /></center><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Bilinear_interpolation. https://en.wikipedia.org/wiki/Bilinear_interpolation. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>scipy.interpolate.interp2d. https://bbs.huaweicloud.com/blogs/329665. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Cubic convolution interpolation for digital image processing <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>NumPy</tag>
      
      <tag>图像插值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讨论当代大学生日益尖锐的性别对立</title>
    <link href="/2022/02/20/2022-2-20-Origin-and-Develop-of-Male-Gaze/"/>
    <url>/2022/02/20/2022-2-20-Origin-and-Develop-of-Male-Gaze/</url>
    
    <content type="html"><![CDATA[<h2 id="概述与起因">概述与起因</h2><p>  这是个非常敏感的话题，我一直以来虽然身处其中但并不对此发表言论。不过最近看到一些相关的东西然后去了解了这方面的知识，并且考虑到这个博客应该没什么人看，就写这篇博客记录一下我自己的观察思考。</p><p>  首先起因要从新番《更衣人偶坠入爱河》说起，这是一部罕见的关于Cosplay题材的番剧，制作从目前看来也是很不错的。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“「その着せ替え人形は恋をする」放送は1月！アニメ映像初出しのPV公開、キャストも”. https://natalie.mu/comic/news/450709">[1]</span></a></sup>本来这是一个普及cos文化的很棒的机会，不过微博和网络上对此争议却意外的大（我自己手机里是不下载微博的，这是从群里看到的）。我随便选点相关反方言论<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="“被扣上“男权凝视”帽子的《更衣人偶》，折射出二次元的尴尬现状”. https://zhuanlan.zhihu.com/p/459764846">[4]</span></a></sup>：</p><blockquote><ol type="1"><li>狗肉下面刷残忍，川菜下面刷太辣，海鲜下面刷痛 风，宠物下面刷好吃，二次元下面刷媚宅<br></li><li>还有女生夏天穿很短的短裤，穿露骨的衣服，那也是迎合男性了？为什么我看到有种说法管这些叫穿衣自由？</li><li>笑了，做给宅男看的不媚宅媚谁？也没人天天逮着偶像剧说媚女啊[大笑]，怎么意见这么多呢</li></ol></blockquote><p>  没找到正方言论的原因是因为我不用微博（女权阵地），我个人到是觉得这个问题没有讨论的价值，就像部分反方言论说的：“讨论男性向番剧的媚宅问题没有价值”。而且这个番剧原作的漫画也是有很多女性观众群体的（因为也有爱好cos题材的女性观众，并且内容本身也是适合女性观看）<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="“今一番面白い漫画はこれ！「全国書店員が選んだおすすめコミック 2020」ランキング発表”. https://web.archive.org/web/20200131141434/https://hon-hikidashi.jp/enjoy/100863/">[2]</span></a></sup>，如下图1。但是另一方面，确实我们也要承认不论有没有女性观众，这个番剧确实是很多男性凝视的视角<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="“【試し読み】「住む世界が違う」2人を繋ぐ好きなもの『その着せ替え人形は恋をする』第1話【前半】”. https://web.archive.org/web/20200217112227/https://hon-hikidashi.jp/enjoy/99008/">[3]</span></a></sup>，而且作者还是女性。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220220210953.png" width="400"><center>图 1</center></center><p>  虽然这个话题的讨论没什么意思，但这件事本身的讨论是有意义的。本着探求态度我试图去了解并解释：为什么很多影视作品存在男性凝视？为什么当代性别矛盾激化？这究竟是男性的错还是女权主义者的错？</p><h2 id="了解与思考">了解与思考</h2><blockquote><p>  特洛伊国王和海伦的故事，海伦就是被凝视的那种人，各种英雄救美的电影小说也是一样的，‘女性的存在价值就是为了男性服务的’；那些小说，战争和电影，都浓墨重彩地去叙述英雄的故事，描写英雄的力量，英雄的历险，女性就是这些英雄的战利品，最后英雄把女性顺理成章地救走，女性也顺理成章的委身于他。</p></blockquote><p>  上面是我一个“哲学大师”同学的解释，另外想了解什么是“凝视”，也可以参考这个链接：<a href="https://zhuanlan.zhihu.com/p/267116286">男性凝视：给女性的自我表达缠一个死结？</a>。除此之外，体育运动中很多女性的服装上也能看到男性凝视的影子。在b站上找到了一个韩国作家对“男性凝视和逆向歧视”的讨论，播放量还是很高的。他的观点我是认同的，但是我觉得更多是解释和无奈，他并没有提出相应的解决策略，而是用“代价”的概念希望男性更好的去理解逆向歧视的原因。他的结论如果我没理解错的话，能够总结为如下几点：</p><ol type="1"><li>承认男性凝视是普遍存在的，并且男性享有更高的社会经济地位；</li><li>男性对女性的歧视来源于认为女性能力不足，无法承担更高的责任义务；</li><li>当下部分女性歧视男性可以理解为男性歧视女性而支付的代价；</li><li>父权社会本身对部分男性也是不公平的，竞争压力和责任义务大；</li><li>多数男性的观点是用社会和经济地位作为代价，支付女性的美貌；</li><li>逆向歧视更合适的词汇是“歧视的代价”；</li><li>最后，这种歧视和性别矛盾很难短时间内消失；</li></ol>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=98673985&bvid=BV1m7411m7GC&cid=168454692&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p>  我自己思考并总结了一下，把我的思路做了一张图（如下图2）：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/male_gaze_self_figure.jpeg" width="650"><center>图 2</center></center><p>  我自己思考的结论和上面的视频略有出入，或者说是他没有讨论到的：</p><ol type="1"><li>首先第一点，<strong>我认为女性的社会地位是在提高的，这是一个不可逆转的趋势</strong>。在古代与近代社会，劳动更多以体力为主，所以男性的地位很高（上古时期母系社会的时候女性是生育的主体，所以社会地位更高）。但是当代社会有两个重要的趋势，一是体力劳动在减少，脑力劳动在增加（我的专业就是机器人，未来要解放双手hhh）。虽然女性由于生育的原因可能在很多职位竞争的时候比不过男性，但是两性在生产能力上的差距确实在逐渐减小。事实是，现在确实有很多优秀的女性在一些相对性别中立的行业中崭露头角。</li><li>以第一点为基础，女性的地位提高，同时女性的消费能力也增强了。<strong>因此，女性凝视趋势的作品现在也是越来越多的，最典型的就是饭圈和偶像，另外在二次元中也有很多女性向的作品</strong>。我认为很多当下两性的矛盾激化就是集中在这里：女性观点是“男性享有更多社会资源，同时社会中存在大量男性凝视的产物，这是性别歧视与对女性的不公平”；男性观点是“女性消耗了很多男性生产的资源，但是自己的生产能力却不匹配消费能力，同时居然还逆向歧视男性”。</li></ol><h2 id="结论与方案">结论与方案</h2><p>  我觉得最重要的一点是不论男性还是女性，都需要进行独立思考，而不是跟随网络上的风向发言。下面是我自己思考，得出认为有助于缓和性别对立的一些想法：</p><ol type="1"><li>容易引起性别对立的侮辱性词汇要避免使用。例如“普信男”，“绿茶”，“裱”等等，有的时候由于没有人发声制止（“沉默的螺旋”），这些歧视性的词汇变成了大家习以为常的用词，甚至变成了幽默的段子；</li><li>普及平等的观念，老一代的观念始终是男尊女卑的，特别是在中国一些乡村县里这样的观念更甚。因此，需要通过教育和知识普及让男女平等的观念被新一代所接受，并籍此在未来希望能缓和性别矛盾；</li><li>接受现状，并努力提升女性能力和地位。我个人认为目前个别女权主义者行为是很过激的，在社交媒体上的发言容易引起性别对立与反感，这不是合理的方式（例如这次对新番的讨论）。首先我觉得不论男性还是女性，都要在接受“现状并不容易改变，不是简单的发言和争论就能解决问题”这个基础上去行动。不论男性凝视还是女性凝视都是资本迎合大众趣味的产物，如果在自己的圈子内自娱自乐，并不值得苛责。例如很多女生也在一些女性凝视的偶像圈子里，我虽然不喜欢偶像文化，但讨厌的是包括男性女性的整个偶像团体，并没有说厚此薄彼。而我也不会在公众媒体上去攻击偶像粉，反而觉得有这样的爱好和精神寄托也不是不好。说“凝视”是我们生来就要接受的，比如父母长辈的凝视（尽管有时会带来反感）。<strong>性别对立和相互歧视不是文化问题，更多是社会结构导致的社会问题，改变现状需要双方努力去优化不合理的社会结构，例如去提高女性的社会经济地位</strong>。</li></ol><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“「その着せ替え人形は恋をする」放送は1月！アニメ映像初出しのPV公開、キャストも”. https://natalie.mu/comic/news/450709 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>“今一番面白い漫画はこれ！「全国書店員が選んだおすすめコミック 2020」ランキング発表”. https://web.archive.org/web/20200131141434/https://hon-hikidashi.jp/enjoy/100863/ <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>“【試し読み】「住む世界が違う」2人を繋ぐ好きなもの『その着せ替え人形は恋をする』第1話【前半】”. https://web.archive.org/web/20200217112227/https://hon-hikidashi.jp/enjoy/99008/ <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>“被扣上“男权凝视”帽子的《更衣人偶》，折射出二次元的尴尬现状”. https://zhuanlan.zhihu.com/p/459764846 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>历史社会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧</tag>
      
      <tag>逆向歧视</tag>
      
      <tag>男性凝视</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python numpy and matplotlib</title>
    <link href="/2022/02/15/2022-2-15-Python-numpy-and-matplotlib/"/>
    <url>/2022/02/15/2022-2-15-Python-numpy-and-matplotlib/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>I adjust this file from the lab tutorial of my DIP course, actually I have used python for more than two semesters, this is not the first time for me to code with python and numpy. So what is the purpose of this blog? I want to record some details of using <code>numpy</code> and <code>matplotlib</code>, because I sometimes forget some of their usages (like find or remove by index and so on). ~Besides, I would record notes for <code>pandas</code> as well.~</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="numpy">Numpy</h2><p>I refer extensively to <a href="https://www.numpy.org.cn/en/user/quickstart.html#prerequisites">this site</a> for reviewing <code>numpy</code>. The reason why <code>numpy</code> is fast and welcome by programmers is because that it uses pre-compiled effective C code and give a convenient vectorized interface for users.</p><h3 id="primary">Primary</h3><ul><li>Some basic concepts and attributes of <code>numpy.ndarray</code></li><li>Create numpy arrays for different dimensions</li><li>print arrays</li></ul><h4 id="what-is-numpy.ndarray">What is <code>numpy.ndarray</code></h4><p>NumPy’s main object is the homogeneous multidimensional array. It is a table of elements(usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called axes. For example, the coordinates of a point in 3D space [1, 2, 1] has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example codes below, the array <code>a</code> has 2 axes. The first axis has a length of 2, the second axis has a length of 3.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[0 1 2] [3 4 5]]</code></pre></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ndim&#x27;</span>, a.ndim)  <span class="hljs-comment"># count of dimensions (axes)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;shape&#x27;</span>, a.shape)  <span class="hljs-comment"># a tuple of the length of each axes</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;size&#x27;</span>, a.size)  <span class="hljs-comment"># count of all elements</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;dtype&#x27;</span>, a.dtype)  <span class="hljs-comment"># datatype</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">ndim 2shape (2, 3)size 6dtype int64</code></pre></div><h4 id="how-to-create-numpy.ndarray">How to create <code>numpy.ndarray</code></h4><p>They could be created from <em>list, tuple, and built-in useful functions</em>. Besides, user could use <code>np.fromfunction</code> to customize an array with a give function. Here are some function examples: * array * zeros, ones, empty * zeros_like, ones_like, empty_like * arange, linspace * fromfunction, fromfile * random.random</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])  <span class="hljs-comment"># from list</span><br>b = np.array([(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)])  <span class="hljs-comment"># from tuple</span><br>c = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># np.arange(start, stop, step)</span><br>d = np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># create an array of zeros, similar with `c = np.ones((2, 3))`</span><br>e = np.zeros_like(<br>    a)  <span class="hljs-comment"># create an array of zeros with the same shape and type as a given array, similar with `c = np.ones_like((2, 3))`</span><br><span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[0 0 0] [0 0 0]]</code></pre></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span>(<span class="hljs-params">arg_x, arg_y</span>):</span>  <span class="hljs-comment"># user customized function</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> * arg_x + arg_y<br><br><br>f = np.fromfunction(f1, (<span class="hljs-number">5</span>, <span class="hljs-number">4</span>), dtype=<span class="hljs-built_in">int</span>)<br>f<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">array([[ 0,  1,  2,  3],       [10, 11, 12, 13],       [20, 21, 22, 23],       [30, 31, 32, 33],       [40, 41, 42, 43]])</code></pre></div><h4 id="print-arrays">Print arrays</h4><ul><li>Except for the last axis(printed from left to right), the other dimensions are all printed from top to down.</li><li>Use <code>set_printoptions</code> could change the settings of <code>print()</code></li><li>Basic operations and universal functions</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># import sys</span><br><span class="hljs-comment"># np.set_printoptions(threshold=sys.maxsize) # is used to print whole arrays (avoid hiding)</span><br>a = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(np.arange(<span class="hljs-number">10000</span>).reshape(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>))  <span class="hljs-comment"># print large matrix</span><br>a[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  <span class="hljs-comment"># visit the last element</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]][[   0    1    2 ...   97   98   99] [ 100  101  102 ...  197  198  199] [ 200  201  202 ...  297  298  299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]]23</code></pre></div><h4 id="operators-and-functions">Operators and functions</h4><ul><li>Support <code>+</code>, <code>-</code>, <code>*</code>, <code>**</code>, <code>+=</code>, <code>*=</code>, and so on, these operators all apply on corresponding single elements.</li><li>Note that <code>==</code>, <code>&lt;</code>, and <code>&gt;=</code> also work, it would return an array of bools.</li><li>Dot product is <code>@</code> or <code>arr1.dot(arr2)</code>, multiplication by elements is <code>*</code>.</li><li>Operating with arrays of different types corresponds to upcasting.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(np.sin(a) ** <span class="hljs-number">0.1</span>)  <span class="hljs-comment"># basic operators</span><br><span class="hljs-built_in">print</span>(a == <span class="hljs-number">2</span>)  <span class="hljs-comment"># return bools</span><br>a.resize(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># reshape() return a new array, resize() adjust the original array</span><br><span class="hljs-built_in">print</span>(a @ a)  <span class="hljs-comment"># dot product</span><br><span class="hljs-built_in">print</span>(a * a)  <span class="hljs-comment"># element multiply</span><br>b = a + <span class="hljs-number">0.1</span> * np.ones(<span class="hljs-number">4</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)) * <span class="hljs-number">1j</span><br><span class="hljs-built_in">print</span>(b.dtype)  <span class="hljs-comment"># upcasting to &#x27;float64&#x27;</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[0.         0.98288773 0.99053676 0.82216476][False False  True False][[ 2  3] [ 6 11]][[0 1] [4 9]]complex128</code></pre></div><p><strong>Some <code>ufunc</code></strong>: * There are many universal functions, like <code>sin</code>, <code>cos</code>, <code>exp</code>, they all apply to <code>ndarray</code> by elements. * The universal functions <code>ufunc</code> could apply on certain axes when specify them. * There are many <a href="https://numpy.org/devdocs/reference/routines.logic.html">logic functions</a>, like some <code>isxxx</code> functions(<code>isinf</code>, <code>isnan</code>, and so on), <code>all</code> and <code>any</code> are also logic functions. * <code>apply_along_axis</code> might be a useful function (?) <a href="https://numpy.org/devdocs/reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis">refer to this</a> * <code>argmax</code>, <code>argsort</code> is very useful! <a href="https://numpy.org/devdocs/reference/generated/numpy.argsort.html#numpy.argsort">refer to this</a> * Some other <code>ufunc</code> are listed below in the figure</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">c = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(c.<span class="hljs-built_in">max</span>(axis=<span class="hljs-number">1</span>))  <span class="hljs-comment"># max of each row</span><br><span class="hljs-built_in">print</span>(c.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>))  <span class="hljs-comment"># sum of each column</span><br><span class="hljs-built_in">print</span>(c.cumsum(axis=<span class="hljs-number">0</span>))  <span class="hljs-comment"># cumulative sum along each column</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">all</span>(np.array([-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) == np.array([<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])))  <span class="hljs-comment"># logic function `all`</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span>(<span class="hljs-params">arr_arg</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Average first and last element of a 1-D array&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> (arr_arg[<span class="hljs-number">0</span>] + arr_arg[-<span class="hljs-number">1</span>]) * <span class="hljs-number">0.5</span><br><br><br>d = np.array([[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(d)<br><span class="hljs-built_in">print</span>(np.apply_along_axis(f2, <span class="hljs-number">0</span>, d))  <span class="hljs-comment"># apply along column</span><br><span class="hljs-built_in">print</span>(np.argsort(d, axis=<span class="hljs-number">0</span>))  <span class="hljs-comment"># return the argument of sorted array along columns</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[ 3  7 11][12 15 18 21][[ 0  1  2  3] [ 4  6  8 10] [12 15 18 21]]False[[7 8 9] [1 2 3] [4 5 6]][5.5 6.5 7.5][[1 1 1] [2 2 2] [0 0 0]]</code></pre></div><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220216231312.png" width="700"></center><h4 id="indexing-and-slicing">Indexing and Slicing</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># original</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])  <span class="hljs-comment"># indexing, the sequence of start from axis 0</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])  <span class="hljs-comment"># slicing, missing indices are considered complete slices</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>])  <span class="hljs-comment"># -1 correspond to the last elements</span><br><span class="hljs-built_in">print</span>(a[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>:<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># the magic form from Dr. Zhang, hahaha~</span><br><span class="hljs-built_in">print</span>(a[..., <span class="hljs-number">0</span>])  <span class="hljs-comment"># &#x27;...&#x27; is an alternative for multiple &#x27;:&#x27;</span><br>a[:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># equivalent to a[0:6:2] = -1; from start to position 4, exclusive, set every 2nd element to -1</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15] [16 17 18 19]]4[[ 4  5  6  7] [ 8  9 10 11]][ 7 11][19 18 17][ 0  4  8 12 16][[-1 -1 -1 -1] [ 4  5  6  7] [-1 -1 -1 -1] [12 13 14 15] [16 17 18 19]]</code></pre></div><h3 id="advanced">Advanced</h3><h4 id="change-the-shape-of-arrays">Change the shape of arrays</h4><ul><li><code>a.ravel()</code> return the flattened array, but not change the array itself</li><li><code>a.reshape()</code> return the reshaped array, <code>a.resize()</code> change the shape of array</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.floor(<span class="hljs-number">10</span> * np.random.random((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))  <span class="hljs-comment"># similar with `np.ceil`</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># range from [0, 10)</span><br><span class="hljs-built_in">print</span>(a.ravel())  <span class="hljs-comment"># return the flattened array</span><br><span class="hljs-built_in">print</span>(a.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment"># return the array with modified shape</span><br><span class="hljs-built_in">print</span>(a.T.shape)  <span class="hljs-comment"># return the transposed array(shape)</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[0. 4. 8. 8.] [9. 3. 3. 5.] [0. 2. 5. 5.]][0. 4. 8. 8. 9. 3. 3. 5. 0. 2. 5. 5.][[0. 4. 8. 8. 9. 3.] [3. 5. 0. 2. 5. 5.]](4, 3)</code></pre></div><h4 id="stacking-arrays-together">Stacking arrays together</h4><p>Refer to the tutorial <a href="https://www.numpy.org.cn/user/quickstart.html#%E5%B0%86%E4%B8%8D%E5%90%8C%E6%95%B0%E7%BB%84%E5%A0%86%E5%8F%A0%E5%9C%A8%E4%B8%80%E8%B5%B7">here</a>, besides some concatenate and splitting functions are <a href="https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate">here</a>. * <code>vstack</code> vertical appending * <code>hstack</code> horizontal appending * <code>column_stack</code> and <code>concatenate</code>also are useful * <code>np.c_</code> translates slice objects to concatenation along the second axis, this is short-hand for <code>np.r_['-1,2,0', index expression]</code>, more about <code>np.r_</code> is <a href="https://numpy.org/devdocs/reference/generated/numpy.r_.html#numpy.r_">here</a>. The dimension upgrade rule of <code>np.r_</code> can refer to <a href="https://blog.csdn.net/huhu0769/article/details/52742395">here</a>. * <code>hsplit</code> and <code>vsplit</code> can split arrays</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>b = np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(np.vstack((a, b)))  <span class="hljs-comment"># vertical</span><br><span class="hljs-built_in">print</span>(np.hstack((a, b)))  <span class="hljs-comment"># horizontal</span><br><span class="hljs-built_in">print</span>(np.r_[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">5j</span>, <span class="hljs-number">0</span>, [<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>, np.array([<span class="hljs-number">2</span>,<br>                                          <span class="hljs-number">3</span>])])  <span class="hljs-comment"># 5j means using np.linspace(start, stop, step, endpoint=1), if not an imaginary number, using np.arange(start, stop, step)</span><br><span class="hljs-built_in">print</span>(np.r_[<span class="hljs-string">&#x27;0,3,2&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])  <span class="hljs-comment"># the last two integers &#x27;3, 1&#x27; are about dimension upgrading</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[1. 1.] [1. 1.] [0. 0.] [0. 0.]][[1. 1. 0. 0.] [1. 1. 0. 0.]][2.   2.75 3.5  4.25 5.   0.   1.   1.   2.   3.  ][[[1 2 3]] [[4 5 6]]]</code></pre></div><h4 id="copies-and-views">Copies and Views</h4><p>When operating and calculating arrays, sometimes the interpreter would copy the data into a new array and return it, sometimes not. <strong>Python is an advanced language, therefore usually it operates by reference, not by value(can be checked by <code>id()</code>)</strong>. There are 3 methods of operating <code>ndarray</code>, which are <code>=</code>, <code>view</code> and <code>copy</code>.</p><h5 id="no-copy-at-all">No Copy at All</h5><p><strong>Pass by reference, actually is another name of the original array</strong>. This is useful when passing by function parameters, but python interpreter helps us do this, usually we do not do this.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;No Copy at All&quot;&quot;&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f3</span>(<span class="hljs-params">arg_arr</span>):</span>  <span class="hljs-comment"># pass by reference</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span>(arg_arr)<br><br><br>a = np.arange(<span class="hljs-number">4</span>)<br>b = a  <span class="hljs-comment"># do assignment &#x27;=&#x27; by reference(just different names)</span><br>b.shape = <span class="hljs-number">2</span>, <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a) == f3(a))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(b))<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">TrueTrue</code></pre></div><h5 id="view-or-shallow-copy">View or Shallow Copy</h5><p><strong>This is like the feature of ROI in CV and matrix operation</strong>. This is useful when the matrix data do not need to change when operating. For example, extracting kernel is this kind of operation, slicing itself also returns a <em>view</em>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">c = a.view()  <span class="hljs-comment"># `view` create a new array object share the same data</span><br><span class="hljs-built_in">print</span>(c <span class="hljs-keyword">is</span> a)<br><span class="hljs-built_in">print</span>(c.base <span class="hljs-keyword">is</span> a)<br>c.shape = <span class="hljs-number">4</span>, <span class="hljs-number">1</span>  <span class="hljs-comment"># c&#x27;s property could be changed</span><br><span class="hljs-built_in">print</span>(a.shape)  <span class="hljs-comment"># a&#x27;s data do not change</span><br><span class="hljs-built_in">print</span>(c.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(c))  <span class="hljs-comment"># this is reference, is shallow copy(like ROI)</span><br>a *= <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># a and c both change</span><br><span class="hljs-keyword">del</span> a  <span class="hljs-comment"># this is like the principle of reference count</span><br><span class="hljs-built_in">print</span>(c)  <span class="hljs-comment"># c still work</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">FalseTrue(2, 2)(4, 1)False[[0 2] [4 6]][[0] [2] [4] [6]]</code></pre></div><h5 id="deep-copy">Deep Copy</h5><p><strong>This creat a full copy of the original data</strong>. Sometimes copy should be called after slicing if the original array is not required anymore. For example, suppose a is a huge intermediate result and the final result b only contains a small fraction of a, a deep copy should be made when constructing b with slicing.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">d = c.copy()  <span class="hljs-comment"># a new array object with new data is created</span><br><span class="hljs-built_in">print</span>(d.base <span class="hljs-keyword">is</span> c)  <span class="hljs-comment"># d doesn&#x27;t share anything with a</span><br><br>a = np.arange(<span class="hljs-built_in">int</span>(<span class="hljs-number">1e8</span>))  <span class="hljs-comment"># very large array</span><br>b = a[:<span class="hljs-number">100</span>].copy()  <span class="hljs-comment"># create a copy and delete</span><br><span class="hljs-keyword">del</span> a  <span class="hljs-comment"># the memory of ``a`` can be released.</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">False</code></pre></div><h4 id="common-function-api">Common Function API</h4><p>refer to <a href="https://www.numpy.org.cn/reference/routines/">here</a></p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220218211635.png" width="700"></center><h4 id="broadcasting">Broadcasting</h4><p>refer to <a href="https://www.numpy.org.cn/user/basics/broadcasting.html#%E4%B8%80%E8%88%AC%E5%B9%BF%E6%92%AD%E8%A7%84%E5%88%99">here</a>, below is one example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">0.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>])<br>b = np.array([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>])<br><span class="hljs-built_in">print</span>(a[:, np.newaxis] + b)  <span class="hljs-comment"># `newaxis` insert a new axis, so a become a 4x1 array</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[ 1.  2.  3.] [11. 12. 13.] [21. 22. 23.] [31. 32. 33.]]</code></pre></div><h4 id="more-about-indexing">More about indexing</h4><p>refer to <a href="https://www.numpy.org.cn/user/quickstart.html#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E6%8A%80%E5%B7%A7">here</a></p><h5 id="indexing-with-arrays-of-indices">Indexing with Arrays of Indices</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a)<br>i = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>              [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])  <span class="hljs-comment"># indices for the first dim of a</span><br>j = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>              [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]])  <span class="hljs-comment"># indices for the second dim</span><br><span class="hljs-built_in">print</span>(a[i,j])<br>l = (i, j) <span class="hljs-comment"># another way is using a tuple for indexing</span><br><span class="hljs-built_in">print</span>(a[l]) <span class="hljs-comment"># result is the same</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]][[ 2  5] [ 7 11]][[ 2  5] [ 7 11]]</code></pre></div><ul><li>Another usage example is about <code>argmax</code>, which is also in the tutorial.</li><li>Use array indices to allocate data is also a good usage.</li></ul><h5 id="indexing-with-boolean-arrays">Indexing with Boolean Arrays</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a[a &gt; <span class="hljs-number">4</span>]) <span class="hljs-comment"># 1d array with the selected elements</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">[ 5  6  7  8  9 10 11]</code></pre></div><h5 id="ix_-function">ix_() function</h5><p>refer to <a href="https://www.numpy.org.cn/user/quickstart.html#ix-%E5%87%BD%E6%95%B0">here</a>, it is useful when doing some array operation (?)</p><h2 id="matplotlib">Matplotlib</h2><h3 id="magic-in-jupyter">Magic in jupyter</h3><p>I refer to <a href="https://scipy-lectures.org/intro/matplotlib/index.html">this site</a> for learning <code>Matplotlib</code>. There are some magic in Jupyter Notebook, like <code>%matplotlib inline</code>, to let user work with <code>matplotlib</code> interactively. Use the below code could set which figure formats are enabled(more refer to <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-matplotlib">this</a>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> set_matplotlib_formats<br>set_matplotlib_formats(<span class="hljs-string">&#x27;pdf&#x27;</span>, <span class="hljs-string">&#x27;svg&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="using-pyplot">Using <code>pyplot</code></h3><p><code>from matplotlib import pyplot as plt</code> or <code>import matplotlib.pyplot as plt</code> might be the first python code in your study. The majority of plotting commands in <code>pyplot</code> have Matlab™ analogs with similar arguments. Important commands are explained with interactive examples.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># Create a figure of size 8x6 inches, 80 dots per inch</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>), dpi=<span class="hljs-number">80</span>)<br>    <br><span class="hljs-comment"># Create a new subplot from a grid of 1x1</span><br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br>X = np.linspace(-np.pi, np.pi, <span class="hljs-number">256</span>)<br>C, S = np.cos(X), np.sin(X)<br><br><span class="hljs-comment"># Plot cosine with a blue continuous line of width 1 (pixels)</span><br>plt.plot(X, C, color=<span class="hljs-string">&quot;blue&quot;</span>, linewidth=<span class="hljs-number">1.0</span>, linestyle=<span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;cosine&quot;</span>)<br><br><span class="hljs-comment"># Plot sine with a green continuous line of width 1 (pixels)</span><br>plt.plot(X, S, color=<span class="hljs-string">&quot;green&quot;</span>, linewidth=<span class="hljs-number">1.0</span>, linestyle=<span class="hljs-string">&quot;-&quot;</span>, label=<span class="hljs-string">&quot;sine&quot;</span>)<br><br><span class="hljs-comment"># Set x limits</span><br>plt.xlim(-<span class="hljs-number">4.0</span>, <span class="hljs-number">4.0</span>)<br><br><span class="hljs-comment"># Set x ticks</span><br>plt.xticks(np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>))<br><br><span class="hljs-comment"># Set y limits</span><br>plt.ylim(-<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># Set y ticks</span><br>plt.yticks(np.linspace(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># Save figure using 72 dots per inch</span><br><span class="hljs-comment"># plt.savefig(&quot;exercise_2.png&quot;, dpi=72)</span><br><br>plt.legend(loc=<span class="hljs-string">&#x27;upper left&#x27;</span>)<br><br><span class="hljs-comment"># Show result on screen</span><br>plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.gca()  <span class="hljs-comment"># gca stands for &#x27;get current axis&#x27;</span><br>ax.spines[<span class="hljs-string">&#x27;right&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;top&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>ax.xaxis.set_ticks_position(<span class="hljs-string">&#x27;bottom&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;bottom&#x27;</span>].set_position((<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-number">0</span>))<br>ax.yaxis.set_ticks_position(<span class="hljs-string">&#x27;left&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;left&#x27;</span>].set_position((<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">t = <span class="hljs-number">2</span> * np.pi / <span class="hljs-number">3</span><br>plt.plot([t, t], [<span class="hljs-number">0</span>, np.cos(t)], color=<span class="hljs-string">&#x27;blue&#x27;</span>, linewidth=<span class="hljs-number">2.5</span>, linestyle=<span class="hljs-string">&quot;--&quot;</span>)<br>plt.scatter([t, ], [np.cos(t), ], <span class="hljs-number">50</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)<br><br>plt.annotate(<span class="hljs-string">r&#x27;$cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$&#x27;</span>,<br>             xy=(t, np.cos(t)), xycoords=<span class="hljs-string">&#x27;data&#x27;</span>,<br>             xytext=(-<span class="hljs-number">90</span>, -<span class="hljs-number">50</span>), textcoords=<span class="hljs-string">&#x27;offset points&#x27;</span>, fontsize=<span class="hljs-number">16</span>,<br>             arrowprops=<span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&quot;-&gt;&quot;</span>, connectionstyle=<span class="hljs-string">&quot;arc3,rad=.2&quot;</span>))<br><br>plt.plot([t, t],[<span class="hljs-number">0</span>, np.sin(t)], color=<span class="hljs-string">&#x27;red&#x27;</span>, linewidth=<span class="hljs-number">2.5</span>, linestyle=<span class="hljs-string">&quot;--&quot;</span>)<br>plt.scatter([t, ],[np.sin(t), ], <span class="hljs-number">50</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br><br>plt.annotate(<span class="hljs-string">r&#x27;$sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#x27;</span>,<br>             xy=(t, np.sin(t)), xycoords=<span class="hljs-string">&#x27;data&#x27;</span>,<br>             xytext=(+<span class="hljs-number">10</span>, +<span class="hljs-number">30</span>), textcoords=<span class="hljs-string">&#x27;offset points&#x27;</span>, fontsize=<span class="hljs-number">16</span>,<br>             arrowprops=<span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&quot;-&gt;&quot;</span>, connectionstyle=<span class="hljs-string">&quot;arc3,rad=.2&quot;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> ax.get_xticklabels() + ax.get_yticklabels():<br>    label.set_fontsize(<span class="hljs-number">16</span>)<br>    label.set_bbox(<span class="hljs-built_in">dict</span>(facecolor=<span class="hljs-string">&#x27;white&#x27;</span>, edgecolor=<span class="hljs-string">&#x27;None&#x27;</span>, alpha=<span class="hljs-number">0.65</span>))<br></code></pre></td></tr></table></figure><table border="0" class="docutils"><colgroup><col width="17%" /><col width="28%" /><col width="54%" /></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">Argument</th><th class="head">Default</th><th class="head">Description</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">num</span></code></td><td><code class="docutils literal notranslate"><span class="pre">1</span></code></td><td>number of figure</td></tr><tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">figsize</span></code></td><td><code class="docutils literal notranslate"><span class="pre">figure.figsize</span></code></td><td>figure size in inches (width, height)</td></tr><tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">dpi</span></code></td><td><code class="docutils literal notranslate"><span class="pre">figure.dpi</span></code></td><td>resolution in dots per inch</td></tr><tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">facecolor</span></code></td><td><code class="docutils literal notranslate"><span class="pre">figure.facecolor</span></code></td><td>color of the drawing background</td></tr><tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">edgecolor</span></code></td><td><code class="docutils literal notranslate"><span class="pre">figure.edgecolor</span></code></td><td>color of edge around the drawing background</td></tr><tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">frameon</span></code></td><td><code class="docutils literal notranslate"><span class="pre">True</span></code></td><td>draw figure frame or not</td></tr></tbody></table><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/python/sphx_glr_plot_linestyles_001.png" height="250"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/python/20220221145220.png" height="250"></div></div></div>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>DIP</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
      <tag>NumPy</tag>
      
      <tag>Matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Note of Modern Control 2021</title>
    <link href="/2022/02/14/2022-2-14-Note-Of-Modern-Control-2021/"/>
    <url>/2022/02/14/2022-2-14-Note-Of-Modern-Control-2021/</url>
    
    <content type="html"><![CDATA[<h2 id="course">Course</h2><p>  欢迎大家关注我们实验室b站账号，这个课程录像的质量还是很高的，可以作为入门Modern Control的课程资料，下半学期学了一部分最优估计的内容，包括Kalman Filter和Dynamic Programming，主要是前者。很遗憾MPC没有时间讲了，所以这一部分只能等下次开课老师讲的时候来补。<em>本课程有提供github仓库。</em></p><ul><li><a href="https://space.bilibili.com/474380277?from=search&amp;seid=9415905800355105743&amp;spm_id_from=333.337.0.0">CLEAR_LAB</a></li><li><a href="https://space.bilibili.com/474380277/channel/collectiondetail?sid=111390">ME424 现代控制与最优估计</a></li></ul><h2 id="note">Note</h2><p>  这是自己的期末复习Note，因为博客显示有size限制，放的版本不是很清晰，提供<a href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/NoteOfModernControl.pdf">下载链接</a>：</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/期末复习笔记3.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制</tag>
      
      <tag>机器人</tag>
      
      <tag>b站</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda in PyCharm</title>
    <link href="/2022/02/13/2022-2-13-Anaconda-in-PyCharm/"/>
    <url>/2022/02/13/2022-2-13-Anaconda-in-PyCharm/</url>
    
    <content type="html"><![CDATA[<h2 id="what-is-anaconda">What is Anaconda</h2><p>Anaconda is a powerful package management tool, it solves some weakness when using python. For example, the inconvenience of switching among different versions of python interpreters and many site-packages. It is similar to the function of <code>pip</code> and <code>pip3</code>, but it is more powerful.</p><h2 id="install-anaconda">Install Anaconda</h2><p>Follow the instruction in 在 <a href="https://anaconda.org.cn/anaconda/install/linux/">Linux 上安装</a>, which supports chinese. First, you would be asked to download some dependence by the following code (my OS is Ubuntu20.04):</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6<br></code></pre></td></tr></table></figure><p>Then you would get a <code>.sh</code> file, give it executable permission. Run the <code>.sh</code> file to install Anaconda just like in Windows. Press <code>Enter</code> all through the progress, you better install Anaconda in the default location, which is under the <code>/home/</code> directory. Mention that do not put it under <code>/usr</code>, the official site give a warning about this!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x filename.sh<br>./Anaconda3-2021.11-Linux-x86_64.sh <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Anaconda3 will now be installed into this location:<br>/home/name/anaconda3<br><br>  - Press ENTER to confirm the location<br>  - Press CTRL-C to abort the installation<br>  - Or specify a different location below<br><br>[/home/name/anaconda3] &gt;&gt;&gt; <br></code></pre></td></tr></table></figure><p>After that you would be asked to init the environment, which is actually adjusting the <code>.bashrc</code> file, like using <code>source &lt;path to conda&gt;/bin/activateconda init</code>. After all the steps, you would get a respond "Thank you for installing Anaconda3!"</p><h2 id="anaconda-navigator">Anaconda-navigator</h2><p>Anaconda-navigator is a GUI application provided by Anaconda, you could use it to manage virtual environments without using terminal. Switch to the "Environments" Tab, choose the env that you are interesting. There are 5 types of selections: <em>Installed, Not installed, Updatable, Selected, All</em>. If you want to install a new package, one method is to choose <em>Not installed</em>, and then search the package you want and download it.</p><h2 id="config-pycharm">Config PyCharm</h2><p>If you haven't got PyCharm, go to <a href="https://www.anaconda.com/pycharm">this link</a> to download it! Then in the <em>New Project</em> page, choose Conda to manage the new environment.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220213232131.png" width="600"></center><p>In the <em>Settings</em> Tab, you could add and remove packages.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220213235222.png" width="600"></center>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PyCharm</tag>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和弦基础</title>
    <link href="/2022/02/12/2022-2-12-Music-Chord/"/>
    <url>/2022/02/12/2022-2-12-Music-Chord/</url>
    
    <content type="html"><![CDATA[<h2 id="和弦标记">和弦标记</h2><p>  每种和弦都会有多种表示方法，最常用的总结如下：</p><table><thead><tr class="header"><th style="text-align: center;">三和弦</th><th style="text-align: center;">符号</th><th style="text-align: center;">七和弦</th><th style="text-align: center;">符号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">大三和弦</td><td style="text-align: center;">C</td><td style="text-align: center;">大七和弦</td><td style="text-align: center;">CM7</td></tr><tr class="even"><td style="text-align: center;">小三和弦</td><td style="text-align: center;">Cm</td><td style="text-align: center;">小七和弦</td><td style="text-align: center;">Cm7</td></tr><tr class="odd"><td style="text-align: center;">挂四和弦</td><td style="text-align: center;">Csus</td><td style="text-align: center;">属七和弦</td><td style="text-align: center;">C7</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">半减七和弦</td><td style="text-align: center;">C∅7</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">减七和弦</td><td style="text-align: center;">Co7</td></tr></tbody></table><h3 id="大和弦-major">大和弦 Major</h3><ul><li><strong>三和弦</strong>：例如，CEG（大三+小三=大三和弦），可以记为<strong>Cmaj、CM、CΔ、C</strong>；</li><li><strong>七和弦</strong>：例如，CEGB（大三和弦+大三=大七和弦），可以记为<strong>Cmaj7、CM7、CΔ7</strong>（不是C7）；</li></ul><h3 id="小和弦-minor">小和弦 Minor</h3><ul><li><strong>三和弦</strong>：例如，ACE（小三+大三=小三和弦），可以记为<strong>Amin、Am、A-</strong>；</li><li><strong>七和弦</strong>：例如，ACEG（小三和弦+小三=小七和弦），可以记为<strong>Amin7、Am7、A-7</strong>；</li></ul><h3 id="减和弦-diminish">减和弦 Diminish</h3><ul><li><strong>三和弦</strong>：例如，BDF（小三+小三=减三和弦），可以记为<strong>Bdim、Bo</strong>；</li><li><strong>七和弦</strong>：例如，BDF♭A（减三和弦+小三=减七和弦），可以记为<strong>Bdim7、Bo7</strong>；</li></ul><h3 id="增三和弦-augmented">增三和弦 Augmented</h3><ul><li><strong>三和弦</strong>：这个和弦用的少，例如，CE♯G（大三+大三=增三和弦），可以记为<strong>Caug</strong>；</li></ul><h3 id="属七和弦-dominant-7th">属七和弦 Dominant 7th</h3><ul><li><strong>七和弦</strong>：例如，CEG♭B（大三和弦+小三=属七和弦），可以记为<strong>C7</strong>；</li><li>    例如，GBDF（大三和弦+小三=属七和弦），可以记为<strong>G7</strong>；</li></ul><h3 id="半减七和弦-half-diminished-7th">半减七和弦 Half Diminished 7th</h3><ul><li><strong>七和弦</strong>：例如，BDFA（减三和弦+大三=半减七和弦），可以记为<strong>Bm7b5、Bm7-5、B∅7</strong>（如果我没理解错的话，Bm7b5的含义是在B小七和弦的基础上将♭G，即七和弦的5音降低，其他半减七可写为Xm-5）；</li></ul><h3 id="sus和弦挂">SUS和弦（挂）</h3><ul><li><strong>三和弦</strong>：以大三和弦C（即CEG）为例，它的<strong>挂二和弦Csus2就是CDG，即将3音变成2音</strong>，它的<strong>挂四和弦Csus4就是CFG，即将3音变成4音</strong>，如果<strong>Xsus后面没有任何数字，默认为挂四和弦</strong>；</li></ul><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213000058.png" width="650"><center>图 1</center></center><h2 id="和弦功能">和弦功能</h2><ul><li><strong>主和弦</strong>：音乐开始或者结束，给人稳定的感觉（家）。不能整首曲子都是主和弦，这样会给人一种单调乏味的感觉；</li><li><strong>属和弦</strong>：一种听起来不稳定的和弦（在外面，想要回家），<strong>在和声学里，从不稳定到稳定的过程叫“解决”</strong>；</li><li><strong>下属和弦</strong>：相对属和弦比较轻松，但是除了主和弦的其他和弦都有不稳定的感觉（也在外面，但没有急着回家）。整体来说，乐曲的发展是<strong>主和弦 &gt; 下属和弦 &gt; 属和弦 &gt; 主和弦</strong>这样的顺序，也可以如图2其他顺序（但是不能从属和弦到下属和弦）：</li></ul><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213104608.png" width="500"><center>图 2</center></center><h2 id="大调leading-bass">大调Leading Bass</h2><p>  首先要知道，很多的流行歌曲并不是用心编配和弦写出来的，而是有固定的套路的，例如这个Leading Bass就是一种固定的套路。不同的曲子可能以一个或两个和弦为一小节去编排，但最后转个调都能够用这一套和弦去伴奏。</p><p>  <strong>Leading Base（顺阶和弦）是一组和声进行，之所以叫这个名字是因为它的低音是顺着音阶下行的（CBAGFEDG）</strong>。C大调的和弦记号如下：C - G/B - Am - C/G - F - C/E - Dm - G7。大约30%的流行歌曲用的是Leading Base的和声进行，可以看看下面这个视频：</p>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=14452311&bvid=BV14x411s7KZ&cid=335407887&page=28" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p><strong>II-V-I进行</strong>：在流行乐中，例如大调Leading Base的结尾，就是II-V-I进行（即对于C大调来说是DGC）。这种进行是非常重要的，并且用的非常多。继续观察，<strong>II-V-I其实就是“小七-属七-主”这样的和弦进行方式，这也是旋律小调为什么降低VI音和VII音的原因</strong>。</p><h2 id="大调四度圈">大调四度圈</h2><p>  大约30%的华语流行歌曲就是用四度圈写出来的，四度圈在C大调上的记号如下：F - G/F - Em - Am - Dm - G7 - C - C7。大七和弦具有让乐曲开始和结束的功能，因此对于大调来说，音乐开始的第一个和弦要么是第I级，要么是第IV级，如图3：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213124411.png" width="550"><center>图 3</center></center>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=14452311&bvid=BV14x411s7KZ&cid=335408040&page=29" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><h2 id="小调leading-base和小调四度圈">小调Leading Base和小调四度圈</h2><p>  小调的这两种和声在流行乐中用的较少，在华语流行歌曲中也就大概5%左右。回忆之前学的大调，结尾是II-V-I进行（“小七-属七-主”）。<strong>注意到在小调Leading Base中，以A小调ABCDEFGA为例，其II-V-I和弦进行对应的是“半减七（BDFG）-小七（EGBD）-小七（ACEG）”，所以需要将六音和七音（F和G）进行升音，得到“小七（BD♯FG）-属七（E♯GBD）-小大七（ACE♯G</strong>）**</p><blockquote><p>不知道是我算错了还是不理解，这个小大七和弦（小三和弦+大三）听起来也不像个稳定的和弦，为啥能够作为主和弦。目前这个地方不太明白，虽然小调Leading Base用的不多，但希望以后能搞懂。</p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213181143.png" width="600"><center>图 4</center></center><p><strong>这几个常用华语流行和声进行记录的有些草率，后续再单独记篇博客吧⊙▽⊙</strong></p>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
      <tag>乐理</tag>
      
      <tag>和弦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL入门与Iterator失效</title>
    <link href="/2022/02/12/2022-2-12-Cpp-Iterator/"/>
    <url>/2022/02/12/2022-2-12-Cpp-Iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="stl六大组件">STL六大组件</h2><p>  因为于老师没讲STL，所以补一下课。STL的六大部件是下面这些：容器（Container）、算法（Algorithm）、迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配置器（allocator）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup>下面分别简单介绍一下：</p><h3 id="容器-container">容器 Container</h3><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td valign="center" width="170"><center><p>容器</p></center></td><td valign="center" width="700"><center><p>特性</p></center></td><td valign="center" width="130"><center><p>所在头文件</p></center></td></tr><tr><td valign="center" width="170"><center><p>向量vector</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;可以用常数时间访问和修改任意元素，</span>在序列尾部进行插入和删除时，具有常数时间复杂度，对任意项的插入和删除就有的时间复杂度与到末尾的距离成正比，尤其对向量头的添加和删除的代价是惊人的高的</p></td><td valign="center" width="130"><center><p>&lt;vector&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>双端队列deque</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;基本上与向量相同，</span>唯一的不同是，其在序列头部插入和删除操作也具有常量时间复杂度</span></p></td><td valign="center" width="130"><center><p>&lt;deque&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>表list</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;对任意元素的访问与对两端的距离成正比，但对某个位置上插入和删除一个项的花费为常数时间。</span></p></td><td valign="center" width="130"><center><p>&lt;list&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>队列queue</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;插入只可以在尾部进行，删除、检索和修改只允许从头部进行。按照先进先出的原则。</span></p></td><td valign="center" width="130"><center><p>&lt;queue&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>堆栈stack</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;堆栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项。即按照后进先出的</span>原则</p></td><td valign="center" width="130"><center><p>&lt;stack&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>集合set</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序，具有快速查找的功能</span>。但是它是以牺牲插入删除操作的效率为代价的</p></td><td valign="center" width="130"><center><p>&lt;set&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>多重集合multiset</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;和集合基本相同，但可以支持重复元素具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;set&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>映射map</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;由{键，值}对组成的集合，以某种作用于键对上的谓词排列。具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;map&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>多重集合multimap</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;比起映射，一个键可以对应多了值。具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;map&gt;</p></center></td></tr></tbody></table><h3 id="算法-algorithm">算法 Algorithm</h3><p>  由头文件<code>&lt;algorithm&gt;</code>，<code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成，<code>&lt;algorithm&gt;</code>是STL头文件中最大的一个，由一大堆模板函数组成，其中常用到的功能范 围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等。。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup></p><h3 id="迭代器-iterator">迭代器 Iterator</h3><p>  实现位于<code>&lt;itertator&gt;</code>中，在某种程度上，可以理解为指针来使用。容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。另外，有的Iterator能够使用<code>++p</code>，<code>p++</code>，<code>*p</code>操作，还可以被复制或赋值，以及用<code>==</code>和<code>!=</code>等比较运算符。具体的每种Iterator的用法是不一样的，需要查手册。一般迭代器都会有对应的常量迭代器，能够避免用户修改指向的内容（类似const void*的指针）。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://c.biancheng.net/view/6675.html">[3]</span></a></sup></p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td colspan="3" valign="center"><p align="center">迭代器功能</p></center></td></tr><tr><td valign="center" width="350"><p>输入迭代器 Input iterator</p></td><td valign="center" width="350"><center><p>Reads forward</p></center></td><td valign="center" width="300"><center><p>istream</p></center></td></tr><tr><td valign="center" width="350"><p>输出迭代器 Output iterator</p></td><td valign="center" width="350"><center><p>Writes forward</p></center></td><td valign="center" width="300"><center><p>ostream, inserter</p></center></td></tr><tr><td valign="center" width="350"><p>前向迭代器 Forward iterator</p></td><td valign="center" width="350"><center><p>Read and Writes forward</p></center></td><td valign="center" width="300"><center><p> </p></center></td></tr><tr><td valign="center" width="350"><p>双向迭代器 Bidirectional iterator</p></td><td valign="center" width="350"><center><p>Read and Writes forward and backward</span></p></center></td><td valign="center" width="300"><center><p>list, set, multiset, map, mul, timap</span></p></center></td></tr><tr><td valign="center" width="350"><p>随机迭代器 Random access iterator</p></td><td valign="center" width="350"><center><p>Read and Write with random access</p></center></td><td valign="center" width="300"><center><p>vector, deque, array, string</p></center></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 举个例子，如何使用Iterator</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-comment">// use for loop to iterate</span><br>        cout &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator i; <span class="hljs-comment">// declare iterator</span><br>    <span class="hljs-keyword">for</span> (i = v.<span class="hljs-built_in">begin</span>(); i != v.<span class="hljs-built_in">end</span>(); ++i) <span class="hljs-comment">// use `i &lt; v.end()` is also fine</span><br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="仿函数-functor">仿函数 Functor</h3><p>  仿函数(functor)又称之为函数对象（function object），其实就是重载了()操作符的struct或者class，使一个类的使用看上去象一个函数。这些仿函数可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理。C语言使用函数指针和回调函数来实现仿函数；在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象，而不是一个普通函数。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/K346K346/article/details/82818801">[2]</span></a></sup></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在C语言中，例如一个用来排序的函数可以这样使用仿函数</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/* Callback function */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_ints_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* A, <span class="hljs-keyword">void</span>* B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">int</span>*)(A)) &lt; *((<span class="hljs-keyword">int</span>*)(B));<br>&#125;<br><br><span class="hljs-comment">/* Declaration of C sorting function */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* first_item, <span class="hljs-keyword">size_t</span> item_size, <span class="hljs-keyword">void</span>* last_item, <span class="hljs-keyword">int</span>(*cmpfunc)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*))</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> items[]=&#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    sort((<span class="hljs-keyword">void</span>*)(items), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), (<span class="hljs-keyword">void</span>*)(items +<span class="hljs-number">3</span>), compare_ints_function);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在C++中，重载括号运算符实现仿函数</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsGreaterThanThresholdFunctor</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsGreaterThanThresholdFunctor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> : threshold(t) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-comment">// 可以用户design这一部分</span><br>        <span class="hljs-keyword">return</span> num &gt; threshold;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// 利用成员变量的特性，避免全局变量</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RecallFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end, IsGreaterThanThresholdFunctor myFunctor)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> *i = start; i != end + <span class="hljs-number">1</span>; i++) &#123;<br>        count = <span class="hljs-built_in">myFunctor</span>(*i) ? count + <span class="hljs-number">1</span> : count; <span class="hljs-comment">// 传参给operator()函数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">RecallFunc</span>(a, a + <span class="hljs-number">4</span>, <span class="hljs-built_in">IsGreaterThanThresholdFunctor</span>(<span class="hljs-number">10</span>));<br>    cout &lt;&lt; result &lt;&lt; endl; <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适配器-adaptor-空间配置器-allocator">适配器 Adaptor &amp; 空间配置器 Allocator</h3><p>  适配器是用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。</p><ul><li><p><strong>容器适配器</strong>：包括栈（stack）、队列(queue)、优先(priority_queue)。使用容器适配器，stack就可以被实现为基本容器类型（vector,dequeue,list）的适配。可以把stack看作是某种特殊的vctor,deque或者list容器，只是其操作仍然受到stack本身属性的限制。queue和priority_queue与之类似。容器适配器的接口更为简单，只是受限比一般容器要多。</p></li><li><p><strong>迭代器适配器</strong>：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。</p></li><li><p><strong>函数适配器</strong>：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器有否定器（相当于"非"操作）、绑定器、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或是将多参数的函数对象转化为少参数的函数对象。</p></li></ul><p>  STL内存配置器为容器分配并管理内存，统一的内存管理使得STL库的可用性、可移植行、以及效率都有了很大的提升。SGI-STL的空间配置器有2种，一种仅仅对c语言的malloc和free进行了简单的封装，而另一个设计到小块内存的管理等，运用了内存池技术等。在SGI-STL中默认的空间配置器是第二级的配置器。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup></p><h2 id="具体学习iterator">具体学习Iterator</h2><h3 id="自增操作">自增操作</h3><p>  注意<code>A(i++);</code>是先执行<code>A(i)</code>，再执行<code>i++;</code>，后者相反。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; i++ &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="迭代器失效">迭代器失效</h3><p>可以参考<a href="https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2">第四个Reference</a>，讲的很细致。关键的点基本都在下面：<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2">[4]</span></a></sup></p><ul><li>C++标准中，<strong>顺序容器的erase函数会返回iterator，但关联容器的erase函数不返回iterator</strong>；</li><li>对于顺序容器vector、deque，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector、deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。erase方法可以返回下一个有效的iterator；</li><li>对于关联容器map、set、multimap、multiset，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响；</li><li>对于顺序容器list，erase方法可以返回下一个有效的iterator。由于list是一个链表，删除当前的iterator，仅仅会使当前的iterator失效，所以也 可以在erase时，递增当前的iterator。</li><li>erase函数返回被删除元素的下一个元素的迭代器。<strong>在STL中，不能以指针来看待迭代器，指针是与内存绑定的，而 迭代器是与容器里的元素绑定的</strong>。</li></ul><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://www.cnblogs.com/welen/articles/3533008.html <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://blog.csdn.net/K346K346/article/details/82818801 <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>http://c.biancheng.net/view/6675.html <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2 <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Iterator</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍树莓派Pico | MicroPython插件</title>
    <link href="/2022/02/12/2022-2-12-Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/"/>
    <url>/2022/02/12/2022-2-12-Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/</url>
    
    <content type="html"><![CDATA[<h2 id="raspberry-pico">Raspberry Pico</h2><p>推荐网页：<a href="https://pico.org.cn/">树莓派 Pico 中文站</a></p><blockquote><p>上面的站点提供了树莓派 Pico 开发板的说明文档，以及完备的 RP2040 芯片资料，本文也有参考上面的内容。</p></blockquote><h3 id="pico-规格参数">Pico 规格参数</h3><p>  这里涉及了很多嵌入式方面的知识，这一块我学的不是很好，有一些看得不是很明白的以后用到再来学吧。看了看相关的评测<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup>，ESP32不仅比Pico便宜而且外设还丰富的多，而且也支持MicroPython。不过我自己也只是买着玩玩，不用在意这些，个人感觉主要树莓派学习门槛更低吧。</p><ul><li>双核 Arm Cortex-M0 + @ 133MHz</li><li>芯片内置 264KB SRAM 和 2MB 的板载闪存</li><li>通过专用 QSPI 总线支持最高 16MB 的片外闪存</li><li>DMA 控制器</li><li>30 个 GPIO 引脚，其中 4 个可用作模拟输入</li><li>2 个 UART、2 个 SPI 控制器和 2 个 I2C 控制器</li><li>16 个 PWM 通道</li><li>USB 1.1 主机和设备支持</li><li>8 个树莓派可编程 I/O（PIO）状态机，用于自定义外围设备支持</li><li>支持 UF2 的 USB 大容量存储启动模式，用于拖放式编程</li></ul><blockquote><p><strong>SRAM是什么</strong>：SRAM (static RAM) is random access memory (RAM) that retains data bits in its memory as long as power is being supplied. Unlike dynamic RAM (DRAM), which stores bits in cells consisting of a capacitor and a transistor, SRAM does not have to be periodically refreshed. Static RAM provides faster access to data and is more expensive than DRAM. SRAM is used for a computer's cache memory and as part of the random access memory digital-to-analog converter on a video card.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://whatis.techtarget.com/definition/SRAM-static-random-access-memory">[1]</span></a></sup></p></blockquote><blockquote><p><strong>QSPI是什么</strong>：QSPI是Queued SPI的简写，是Motorola公司推出的SPI接口的扩展，比SPI应用更加广泛。在SPI协议的基础上，Motorola公司对其功能进行了增强，增加了队列传输机制，推出了队列串行外围接口协议（即QSPI协议）。片外闪存顾名思义就是外接的Flash存储空间。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.cnblogs.com/firege/p/9435349.html">[2]</span></a></sup></p></blockquote><blockquote><p><strong>PIO是什么</strong>：这是应该是Pico最大的亮点，我没有看得很明白官方的说明。大概就是说能够使用PIO来实现硬件接口，相对于软件模拟的方式，可以达到更高的时钟精度、高得多的I/O吞吐量，还能分担一点CPU的计算工作，比如奇偶校验、和校验等。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup></p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/pico/20220212190432.png" width="1000"><center>Pico原理图</center></center><h3 id="pico提供的开发工具">Pico提供的开发工具</h3><p>  有一个C++的SDK，是专门给Pico设计的，感觉没有必要，用这套SDK不如用STM32系列的SDK。除了C++之外还有一个MicroPython的SDK，我是打算用这个来做点小东西，顺便学习一下各种嵌入式常见的外设。除此之外，学一些MicroPython也挺好的，主要看这个文档<a href="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf">Pico Python SDK</a>。除此之外还有<a href="https://datasheets.raspberrypi.com/rp2040/hardware-design-with-rp2040.pdf">RP2040 硬件设计</a>、<a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040 Datasheet</a>和<a href="https://datasheets.raspberrypi.com/pico/pico-datasheet.pdf">树莓派 Pico Datasheet</a>这三个文档也可以作为学习过程的参考，主要和RP2040和Pico的硬件外设有关。</p><h2 id="pycharm-micropython-插件">PyCharm MicroPython 插件</h2><p>  直接在PyCharm的Settings-Plugins中去搜索“MicroPython”插件然后安装，完成后需要在Project中进行配置，在Settings-Languages &amp; Frameworks-MicroPython对开启该插件进行勾选，然后选择对应的Device type和Device path（我是在linux ubuntu下所以是dev/ttyACM0）。完成配置后使用如下程序进行测试，如果LED灯闪烁说明配置成功（REPL显示对应输出）：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin<br><span class="hljs-keyword">import</span> time<br><br>led = Pin(<span class="hljs-number">25</span>, Pin.OUT)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    led.value(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light on&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    led.value(<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light off&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/pico/20220212200558.png" width="600"><center>Pico原理图</center></center><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>https://whatis.techtarget.com/definition/SRAM-static-random-access-memory <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>https://www.cnblogs.com/firege/p/9435349.html <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>https://www.zhihu.com/question/440677296 <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>学习笔记</category>
      
      <category>Raspberry Pico</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raspberry</tag>
      
      <tag>Pico</tag>
      
      <tag>MicroPython</tag>
      
      <tag>嵌入式</tag>
      
      <tag>Python</tag>
      
      <tag>PyCharm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编曲笔记目录</title>
    <link href="/2022/02/04/2022-2-4-Music-Arrangment-Content/"/>
    <url>/2022/02/04/2022-2-4-Music-Arrangment-Content/</url>
    
    <content type="html"><![CDATA[<p>  除了理论方面的学习笔记，另外还会在这里更新一些关于宿主和midi折腾的记录。btw，我自己大出血买了个去年最火的Oxygen pro mini，然后目前主力在用的宿主软件是Ableton 11 suite。</p><h2 id="参考教程链接">参考教程链接</h2><ul><li><a href="https://space.bilibili.com/13639412">乐球网b站主页</a></li><li><a href="https://space.bilibili.com/13887335?spm_id_from=333.788.b_765f7570696e666f.1">b站Up： 一切为了专辑</a></li><li><a href="https://www.bilibili.com/video/BV14x411s7KZ?p=15&amp;spm_id_from=pageDriver">B站乐球网最全从零开始的完整的编曲教程『301P更新完毕』【你还不会编曲吗？】</a></li><li><a href="https://www.bilibili.com/video/BV1bx411s7A5?spm_id_from=333.999.0.0">FL Studio使用教程【乐球网】</a></li><li><a href="https://www.bilibili.com/video/BV1CE411g7Wz/?spm_id_from=333.788.recommend_more_video.7">如何在B站自学音乐制作，从零开始系统全面引导向教程 教你作曲编曲混音母带直到成为一名制作人</a></li><li><a href="https://www.bilibili.com/video/BV1Mg411A7b3?p=7">《Ableton Live11使用与操作教程》正式发布！电音制作学习必备教程|蝙蝠电音</a></li><li><a href="https://www.bilibili.com/video/BV1Wb4y1X76D?p=1">【官方正版】Ableton Live11 中文教程</a></li><li><a href="https://www.bilibili.com/video/BV1Tb4y1y7dg">高颜值的智能MIDI键盘OXYGEN PRO MINI评测</a></li><li><a href="https://www.bilibili.com/video/BV1qB4y1T7dQ">【附50种热门分支】一个视频听懂音乐风格</a></li><li><a href="https://space.bilibili.com/285766656?spm_id_from=333.788.b_765f7570696e666f.1">来玩吉他b站主页</a></li><li><a href="http://www.fhdq.net/ts/96.html">音符符号</a></li></ul><h2 id="笔记目录">笔记目录</h2><ol type="1"><li><a href="https://judera9.github.io/2022/01/30/2022-1-30-Music-Theory/">乐理基础</a></li><li><a href="">和声基础</a></li><li><a href="">音乐风格</a></li><li><a href="">Oxygen pro mini使用记录</a></li><li><a href="">Ableton 11 suite使用记录</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》0 导读</title>
    <link href="/2022/02/02/2022-2-2-Effective-Cpp-Introduction/"/>
    <url>/2022/02/02/2022-2-2-Effective-Cpp-Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="terminology">Terminology</h2><h3 id="声明-declaration">声明-declaration</h3><p>在《C++ Primer》中提到：</p><blockquote><p>变量声明：用于向程序表明变量的类型和名字。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> x; <span class="hljs-comment">// declare an object</span><br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">numDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>; <span class="hljs-comment">// declare a function</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span> <span class="hljs-comment">// declare a class</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// declare a template</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span>;</span><br></code></pre></td></tr></table></figure><h4 id="extern关键字">extern关键字</h4><p>  通过使用extern关键字能够声明变量名而不定义它，使用extern编译器不会给变量分配存储空间。所以<code>extern int x;</code>是声明而不是定义，而<code>int x;</code>是声明也是定义。但是如果对声明进行了initialization，如<code>extern int x = 1;</code>，则一定是定义。</p><p>  对函数来说如果加了<code>&#123;&#125;</code>就是定义，如果没有就是声明。<strong>在一个程序中，变量或函数可以声明多次（如下会提示<code>Clang-Tidy: Redundant 'foo' declaration</code>），但是定义只能有一次</strong>，如下代码能够编译成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// redundant declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123; <span class="hljs-comment">// definition</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用std">使用std</h4><p>  为了方便，作者在后面章节的代码中省略了C++标准程序库的命名空间<code>std::</code>的书写，但是在实际编译时是不能省略的。另外，<code>use namespace std;</code>并不是一个好选择，因为会引入很多不必要的名称，这可能会导致灾难性的结果。在《C++ Primer Plus》的“第九章-内存模型和名称空间”中，提到：</p><blockquote><p>  一般说来，使用using命令比 使用using编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。<strong>如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。</strong>另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><h4 id="为什么使用size_t">为什么使用size_t</h4><p>  上面提到的标准库中的size_t，是很多C++ Programmer知道但是很多时候不敢用的一个typedef的unsigned integer类型。使用size_t能够使得代码更加便于在不同系统间移植（如IP16L32和I16PL32），同时增加移植性和可读性，可以参考给出的链接<a href="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?">Why size_t matters</a>。</p><h4 id="函数签名-signature">函数签名-signature</h4><p>  官方定义的C++ signature只包括函数的参数，不包括返回类型。编译器在检查函数signature是否重复时，如果两个函数声明只有返回类型不同，编译器同样会报错，因为它不知道调用的是哪个函数。但是本书为了帮助理解将返回类型视为signature的一部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>  上面的declaration我使用C++14标准会报<em>“Functions that differ only in their return type cannot be overloaded”</em>。如下的代码是可以编译通过的（对于C89来说这两种都不行，C只检查函数名，而不会将参数类型和返回值加到signature中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="定义-definition">定义-definition</h3><p>  书中描述是<em>“definition的任务是提供编译器一些声明式所遗漏的细节“</em>，个人感觉说的不够清楚。在《C++ Primer》中提到：</p><blockquote><p>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义（定义也是声明）。</p></blockquote><h4 id="关于声明与定义的程序设计风格">关于声明与定义的程序设计风格</h4><p>  参考博客<a href="https://blog.csdn.net/sjxbf/article/details/6310150">C++定义与声明 区别</a>，我觉得有几点很值得注意：</p><ol type="1"><li>不要把变量定义放入.h文件，这样容易导致重复定义错误。</li><li>但是值在编译时就已知的const变量的定义、类的定义、inline 函数的定义可以放到头文件中。</li><li>尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。</li><li>可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。</li></ol><h3 id="初始化-initialization">初始化-initialization</h3><p>  初始化是“给予对象初值”的过程，通常由构造函数constructor完成。需要注意如下三个特别的构造函数：default构造函数、copy构造函数、以及copy assignment操作符。</p><h4 id="default构造函数">default构造函数</h4><p>  default构造函数的要求是<em>“一个可被调用而不带任何实参者”</em>，也可以是每个参数都有缺省值。<strong>通常来说，建议构造函数被声明为explicit，这样能够阻止implicit type conversions。</strong></p><h4 id="copy构造函数和copy-assignment操作符">copy构造函数和copy assignment操作符</h4><p>  copy构造函数被用来<em>“以同型对象初始化自我对象”</em>，而copy assignment操作符被用来<em>“从另一个同型对象中拷贝其值到自我对象”</em>。copy构造和copy赋值的区别在于是否有新的对象被创建。<strong>这两个都是典型的pass-by-value的方式，而一般更好的方式是pass-by-reference-to-const。</strong>书中的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(); <span class="hljs-comment">// default构造函数</span><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy构造函数</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy assignment操作符</span><br>    ...<br>&#125;;<br>Widget w1; <span class="hljs-comment">// 调用default构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">(w1)</span></span>; <span class="hljs-comment">// 调用copy构造函数</span><br>w1 = w2; <span class="hljs-comment">// 调用copy assignment操作符</span><br></code></pre></td></tr></table></figure><h3 id="standard-template-library-stl">Standard Template Library-STL</h3><p>  是C++标准程序库的一部分，内含容器（vector、list、set、map等），迭代器（iterator、set<string>::iterator等），算法（for_each、find、sort等）及其相关机能。作者说STL是非常有用的，不过我基本没用过（因为我C++课的老师主要让我们搞速度优化，用STL肯定卷不过别人了）。</p><h3 id="不明确行为-undefined-behavior">不明确行为-undefined behavior</h3><p>  带有undefined behavior的程序通常是令人崩溃的，这样的程序即使能够编译成功，在执行过程中可能有时正常执行，有时造成崩坏，有时产生不正确的结果。因此，使用C++编程时要能够自己处理异常并小心避免undefined behavior。下面程序的返回值就是一个随机的结果，因为数组name的大小为6，发生了越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> name[] = <span class="hljs-string">&quot;Darla&quot;</span>;<br><span class="hljs-keyword">char</span> c = name[<span class="hljs-number">10</span>];<br>std::cout &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h2 id="tr1和boost">TR1和Boost</h2><p>TR1是描述C++许多新机能的一份规范，而Boost是一个相关的开源平台。关于这方面，下面提供了一些可能有帮助的C++学习相关资源链接。</p><ul><li><a href="https://www.runoob.com/cplusplus/cpp-useful-resources.html">C++ 有用的资源</a></li><li><a href="https://en.cppreference.com/w/cpp/header">C++ Standard Library headers</a></li><li><a href="https://en.wikibooks.org/wiki/C++_Programming">C++ Programming（书）</a></li><li><a href="http://www.sunistudio.com/cppfaq/">C++ FAQ LITE — Frequently Asked Questions</a></li><li><a href="https://www.thefreecountry.com/sourcecode/cpp.shtml">Free C / C++ Libraries, Source Code and Frameworks</a></li><li><a href="https://www.boost.org/">boost</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》阅读笔记目录</title>
    <link href="/2022/02/02/2022-2-2-Effective-Cpp-Content/"/>
    <url>/2022/02/02/2022-2-2-Effective-Cpp-Content/</url>
    
    <content type="html"><![CDATA[<p>  《Effective C++ 第三版》这本书给出了55条使用C++编程时需要注意的要点，帮助程序员写出更加优雅合理的程序。如导读里所说，<em>“学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是另一回事”</em>，在这方面C++是代表。因此，本书的目的不是教你学会C++，而是学习如何写出Effective的C++程序。</p><p>  我记录这篇笔记的目的是为了提取我自己认为重要，或是需要的条款，方便以后写代码时随时能够查看使用。因此，有些地方可能会进行拓展学习，有些地方只是一笔带过。个人能力有限，如果有错误的内容烦请在评论区指正！</p><p>  另外帮我的C++课老师于仕琪教授打个广告，他的C++程序设计课程体验很棒。大家可以去<a href="https://space.bilibili.com/519963684?from=search&amp;seid=2332289542653409243&amp;spm_id_from=333.337.0.0">b站</a>围观一下，并且这里也提供了他的<a href="https://github.com/ShiqiYu/CPP">课程仓库</a>，大家可以下载ppt和实例代码看看，课程讲了很多矩阵运算优化方法。</p><h2 id="catalog">Catalog</h2><ol start="0" type="1"><li><a href="https://judera9.github.io/2022/02/02/2022-2-2-Effective-Cpp-Introduction/">Introduction</a></li><li><a href="">Accustoming Yourself to C++</a></li><li><a href="">Constructors, Destructors, and Assignment Operators</a></li><li><a href="">Resource Management</a></li><li><a href="">Designs and Declarations</a></li><li><a href="">Implementations</a></li><li><a href="">Inheritance and Object-Oriented Design</a></li><li><a href="">Templates and Generic Programming</a></li><li><a href="">Customizing new and delete</a></li><li><a href="">Miscellany</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陆地冲浪板介绍与选型</title>
    <link href="/2022/01/30/2022-1-30-Surfskate-Selection/"/>
    <url>/2022/01/30/2022-1-30-Surfskate-Selection/</url>
    
    <content type="html"><![CDATA[<hr /><h2 id="surfskate的由来">Surfskate的由来</h2><p>  中文名陆地冲浪板（简称“陆冲”），板如其名，是用于模拟海上冲浪的。众所周知，冲浪要在暖季合适的海岸，滑雪要在冬季合适的雪地，条件苛刻，更别提大家疲于996福报很少有时间出行去冲浪滑雪。因此，入手一个陆地冲浪板能够帮助提高技能水平，是冲浪滑雪很好的练习道具。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-surf.jpeg" height="250" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-ski.png" height="250" /></div></div></div><h2 id="市面大牌选型">市面大牌选型</h2><p>  可以参考<a href="https://www.zhihu.com/people/surfskate">这个链接</a>，这位大佬对于每种品牌的特点和桥的特点都说的很明白。这个大佬做了一张图，我只用过Yow的桥没啥发言权，所以参考这位老兄的经验肯定是靠谱的。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/choose_surfskate.jpg" width=1000"></center><h2 id="保养与维护">保养与维护</h2>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=62322438&bvid=BV1ht411M78i&cid=108319980&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p>另外还可以参考：</p><ul><li><a href="https://www.bilibili.com/video/av89625664">YOW陆地冲浪板 官方维修指南 Surf YOW Systems Tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/105870163">Carver冲浪滑板和其他Surfskate 陆地冲浪板入门到快乐（五）维修篇</a></li><li><a href="https://space.bilibili.com/508830">猫咪贵族（b站一位玩陆冲的大佬）</a></li></ul><h2 id="玩法show">玩法show</h2><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/82459365">陆地冲浪surfskate入手后的问题和使用说明书！</a></li><li><a href="https://www.bilibili.com/video/BV1wy4y1E7KL?from=search&amp;seid=16512587863776667224&amp;spm_id_from=333.337.0.0">日本小哥横刹(PowerSlide)教学【搬运|字幕】</a></li></ol><p><em>我玩的经验下次博客再介绍吧（等我玩熟练了先） ヾ(=･ω･=)o</em></p>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>杂学笔记</category>
      
      <category>陆地冲浪/冲浪/滑雪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>surfskate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐理基础</title>
    <link href="/2022/01/30/2022-1-30-Music-Theory/"/>
    <url>/2022/01/30/2022-1-30-Music-Theory/</url>
    
    <content type="html"><![CDATA[<p>图片和教程来源，<a href="https://www.bilibili.com/video/BV14x411s7KZ?p=1">bilibili乐球网编曲教程</a>。个人仅作笔记，侵删。</p><span id="more"></span><h2 id="音程">音程</h2><p>  我们能够用<strong>属性+大小+单位</strong>的方式来描述音程。音程是两个音之间的距离，单位都是度；大小有从一到七；属性有<strong>纯、大、小、增、减、倍增、倍减</strong>。</p><h3 id="音程大小">音程大小</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204192938.png" width="550"><center>图 1</center></center><ul><li>对于白键：直接数两者之间有几个白键就是几度，注意是包括开始和结束的键；</li><li>对于黑键：首先还原黑键，然后和白键一样数就行；</li></ul><blockquote><p>  也可以这样，sou就是5，升re就是♯2（或者♭3），因此对应(5-2)+1=4，所以是四度。不过好像跨了下一个八度就不好算了，还是好好数琴键吧 &gt;_&lt;|||</p></blockquote><h3 id="音程属性">音程属性</h3><p>  如图1所示，尽管大小相同，还需要区分属性。<strong>“纯”只存在于一、四、五、八度中，“大/小“只存在于二、三、六、七度中，而“增、减、倍增、倍减”存在于所有度数大小</strong>。即，不存在纯三度或大四度。</p><h3 id="标准音程与音程计算">标准音程与音程计算</h3><p>  标准音程是以C为起点到下一个八度的C为止，共七个白键音程的名称。如图2所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204203925.png" width="550"><center>图 2</center></center><p>  对于不是两个琴键都落在白键上的情况，遵循以下的步骤进行计算：</p><ol type="1"><li>找大小：还原升降号，然后数白键的数量；</li><li>找属性：数白键和黑键的总数，通过图3的公式和标准音程比较，进行计算；</li></ol><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204204602.png" width="550"><center>图 3</center></center><p>  例如：对于♯F和D，如图4所示。首先，还原♯F，F和D之间有6个琴键，所以是六度。标准的六度是10个键，对应的是大六度。然后，数白键与黑键一共是9个键，因此根据公式结果是小六度。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204205257.png" width="550"><center>图 4</center></center><blockquote><p>  我自己总结也差不多，假设E和F之间以及B和C之间少了一个黑键我们叫做一个坑（“少了个黑键”），那么最终其实就是比较坑的数量嘛。假设还是♯F和D，很容易发现♯F和G之间由于升降号导致了一个坑，在B和C之间本来有一个坑，那么一共是两个坑。标准的六度是一个坑（标准的四度到七度都是一个坑），所以♯F到D比标准的多了一个坑（“少了一个黑键”），因此是小六度。</p></blockquote><h2 id="和弦">和弦</h2><p>  和弦就是<strong>以任何一个音作为根音，往上按照三度的音程关系叠加构成的组合</strong>。和弦最少是三个音，两个音的是音程。所谓三和弦，指的是根音到冠音的度数是三，而后面直到十三和弦以此类推。音最多的十三和弦有7个音，刚好从C到B。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204223656.png" width="550"><center>图 5</center></center><h3 id="三和弦">三和弦</h3><p>  属性包括“<strong>大三和弦、小三和弦、增三和弦、减三和弦</strong>”，其中增三和弦在流行乐中很少用到，所以这里不讲。区分大三和弦，小三和弦和减三和弦的方式是看三和弦的两个音程的属性，如图6：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204231246.png" width="550"><center>图 6</center></center><p>  例如：FAC是大三度+小三度=F大三和弦，F♭AC是小三度+大三度=F小三和弦，F♭A♭C是小三度+小三度=F减三和弦（这就是F为根音对应的几个三和弦）</p><h3 id="七和弦">七和弦</h3><p>  属性主要包括“<strong>大大七和弦、小小七和弦、大小七和弦、减小七和弦、减减七和弦</strong>”，其中我们并不会这么叫，实际的叫法是“<strong>大七和弦、小七和弦、属七和弦、半减七和弦、减七和弦</strong>”。区分它们的方法建立在三和弦的分类基础上，如图7所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204233441.png" width="550"><center>图 7</center></center><p>  例如：DFAC是小三和弦+小七度=D小七和弦，DF♭AC是减三和弦+小七度=D半减七和弦，DF♭A♭C是减三和弦+减七度=D减七和弦（这就是D为根音对应的几个七和弦）</p><blockquote><p>这里其实可以换一种理解方式（可能更好计算一点）：</p><ul><li><p>大三和弦+大三（大七）=大七和弦</p></li><li><p>大三和弦+小三（小七）=属七和弦</p></li><li><p>小三和弦+小三（小七）=小七和弦</p></li><li><p>减三和弦+大三（小七）=半减七和弦</p></li><li><p>减三和弦+小三（减七）=减七和弦</p></li></ul></blockquote><h3 id="和弦转位">和弦转位</h3><p>  和弦转位其实就是将和弦中的某个或某些音提高了八度，然后低音变成了其他音。如图8中C（表示C大三和弦）的转位，由于除了根音外有两个音，所以三和弦都是有两个转位的。图8中间的<strong>C/E就是C和弦第一转位，“/”前面的“C”表示这是一个C和弦，后面的“E”表示低音演奏E</strong>；而C/G同理。注意到，对于C/E来说，只要保证低音是E，上面不论是135还是513都没有关系，都是C和弦第一转位。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204234704.png" width="550"><center>图 8</center></center><p>  对于七和弦，也是同样的道理。例如：CM7（也就是C小七和弦）是CEGB是原位，然后第一转位是CM7/E，也就是E...（如EGBC），第二转位是G...（如GBCE），以此类推共有三个和弦转位。再比如下图9，原位是D7（D属七和弦），对应的三个转位是D7/♯F、D7/A、D7/C。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205000556.png" width="550"><center>图 9</center></center><h2 id="音调">音调</h2><p>  对于一首歌，如果调太高了唱不上去，我们通常会降调，音阶整体上移或下移就是变调（变调是不会改变旋律本身的）。首先是自然大调和自然小调，在其基础上对六音和七音进行升降就得到和声大调、旋律大调、和声小调、旋律小调。</p><h3 id="自然大调">自然大调</h3><p>  总结来说，<strong>听起来像CDEFGABC的就是自然大调</strong>，上述是C大调。再比如说，♭D大调是♭D♭EF♭G♭A♭BC♭D，E大调是E♯F♯GAB♯C♯DE，这些自然大调的音阶结构，都是如下图10所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205103723.png" width="550"><center>图 10</center></center><h3 id="自然小调">自然小调</h3><p>  总结来说，<strong>听起来像ABCDEFGA的就是自然大调</strong>，上述是A小调。再比如说，C小调是CD♭EFG♭A♭BC。自然小调的音阶结构如下图11所示。由此，我们又能够看出，C大调和A小调的音是一样的，只是顺序不同而已，因此它们称为<strong>关系大小调</strong>。除此之外，C大调的C和A小调的A之间差了一个小3°，因此所有的关系大小调间也是差了一个小3°。例如，C小调的关系大调是♭E大调。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205110501.png" width="550"><center>图 11</center></center><h3 id="如何辨别一首歌的调">如何辨别一首歌的调</h3><blockquote><p>  这里貌似教程少了这方面的内容，所以另外找了个讲的很好的视频补上！<strong>其实就是听最后的结尾旋律，一般流行乐的结尾音就是这个调的调名啦</strong>，不过我乐感好拉跨（羡慕绝对音感的人）。</p></blockquote>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=43075656&bvid=BV1cb411S7ra&cid=141283989&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><h3 id="调性">调性</h3><p>  即在自然大调和自然小调的基础上对六音和七音进行升降，如下图12所示。例如：要找E和声大调，首先找到E自然大调E♯F♯GAB♯C♯DE，然后降低六音得到E♯F♯GABC♯DE，此时再降低七音得到E旋律大调E♯F♯GABCDE。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205140927.png" width="550"><center>图 12</center></center><h2 id="音符">音符</h2><p>  音符就比较简单了，即所谓表示演奏时间的长短。这一部分因为自己好歹学了多年演奏，比较熟练所以就懒得记太多了。图13是从全音符到六十四分音符单个的写法（六十四一般用不到）。图14是节拍的写法，例如：3/4念作四三拍，表示以四分音符为一拍，一个小节是三拍。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205141824.png" width="550"><center>图 13</center></center><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142042.png" width="550"><center>图 14</center></center><h3 id="附点音符">附点音符</h3><p>  附点音符=原音符+原音符的一半，如图15。附点在乐谱上的写法也要注意，如果音符在第n线上，那个附点标记在这条线的上面的间；如果音符在间上，那么直接标记在这个间就可以了。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142607.png" width="550"><center>图 15</center></center><h3 id="休止符">休止符</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205143000.png" width="550"><center>图 16</center></center><h3 id="连音">连音</h3><p>  概念比较简单，注意连音的写法。如果音符是四分音符，标了三连音的符号之后（三连音对应到2），相当于4个四分音符也就是两拍，即<strong>在两拍内演奏完三连音</strong>。再比如如下图17，音符是十六分音符（五、六、七连音对应到4），相当于4个十六分音符也就是一拍，即<strong>在一拍内演奏完五、六、七连音</strong>。以此类推，9～15连音对应到8进行相应的计算。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205144219.png" width="550"><center>图 17</center></center>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人娱乐与文学</title>
    <link href="/2022/01/30/2022-1-30-Robot-Introduction/"/>
    <url>/2022/01/30/2022-1-30-Robot-Introduction/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/robotIntroductionPaper.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>知识科普</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器人</tag>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝冢与歌剧少女</title>
    <link href="/2022/01/30/2022-1-30-Takarazuka-Revue/"/>
    <url>/2022/01/30/2022-1-30-Takarazuka-Revue/</url>
    
    <content type="html"><![CDATA[<h2 id="一选题原因">一、选题原因</h2><p>  老师在课上介绍宝冢歌剧团时，提问我们是如何了解到“宝冢”这个名字的，当时我回答是从一部番剧了解的，这部番剧即本文分析涉及的2021新番“歌剧少女”。歌剧作为本门课程中重要的课题，我希望结合宝冢歌剧团和这部番剧来进行一些歌剧文化方面的探讨。</p><h2 id="二宝冢歌剧团">二、宝冢歌剧团</h2><p>  与歌舞伎全部为男性演员相反，日本宝冢歌剧以全员女性的形式为观众演绎各种各样的浪漫爱情故事。自大正年间创立以来宝冢已有百年历史，如今分为各具特色的“花、月、雪、星、宙”五个组，可简单总结其特色为歌舞之花、戏剧之月、和物之雪、装扮之星、年轻之宙。宝冢的歌剧题材来源极其广泛，服装和舞台效果也非常还原所演绎的故事设定。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="易巧丽.华丽旖旎的女性之梦 谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84.">[1]</span></a></sup></p><p>  宝冢歌剧一个重要的特色是男役演员，为了向以已婚女性主妇为主体的观众展现其“大男主”题材的爱情故事，舞台的核心即男役演员需要展现出完美的男性魅力。宝冢歌剧通过瑰丽的舞台，为女性观众们编织了完美与浪漫的爱情之梦。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-1.png" width="300"><center>宝冢歌剧团首席男役</center></center><h2 id="三歌剧少女">三、歌剧少女</h2><p>  番剧“歌剧少女”是一部歌剧相关题材的漫改动画，于2021年7月开始放送。剧中的红华歌剧学院即现实中的宝冢音乐学院，且许多专有名词，如男役、娘役、预科生等，以及戏剧名和相关文化特色均是直接还原现实中的宝冢文化，个人认为在设定上对宝冢的还原度相对较高。</p><p>  放送完结的第一季对应原作的前日谈部分，介绍了几位不同背景的预科生各自的过往和相互建立羁绊的故事。有意思的是，剧中主要角色的背景还涉及了歌舞伎和偶像文化等。与少女漫画或偶像企划（如lovelive）不同，本剧细致描写了各个同学在学院学习歌剧的跌宕起伏的经历，并且在细节上较好的还原了宝冢音乐学院的特色（如学生间的阶级制度和各种道具等）。</p><p>  “歌剧少女”的片尾曲很有宝冢的歌剧特色，经过调查发现音乐部分是由在宝塚歌剧团工作过的齐藤恒芳先生完成作词、作曲、编曲的。在字幕表中能看到不少宝冢的OG也有演出。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”. https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-2.png" width="300"><center>歌剧少女宣传封面</center></center><h2 id="四宝冢歌剧文化的创新与魅力">四、宝冢歌剧文化的创新与魅力</h2><p>  <em>“一般文化的寿命是50年，50年过后，即便不消失也不再是大众之物。”</em></p><p>  随着互大众传媒的发展，娱乐的形式和观赏娱乐的方式都在不断扩张，许多曾经流行的艺术也在逐渐淡出历史舞台。这并不是一件坏事，毕竟艺术源于生活，而当一种艺术已经与当代人的生活脱钩时，这种艺术也不再能引起人们的共鸣。如为了迎合当下快节奏的生活方式而诞生出的“短视频”文化，而像豫剧、河北梆子等这种地方戏剧没有跟上时代的改变并迎合现代人的喜好，便逐渐在戏剧的历史舞台上消逝。</p><p>  我认为宝冢歌剧是成功迎合新时代的文化之一，我认为主要原因有两点。</p><p>  首先是题材上的创新，在电视刚开始流行的时候，宝冢歌剧遭遇了严重的打击，而她们顶住舆论的压力，用一部《凡尔赛玫瑰》成功背水一战重新焕发生机。而后来她们也尝试去改编各种各样的题材，包括古代历史、近代风物、当代故事、甚至关于未来想象，容纳了中国、阿拉伯、印度等各个国家的文化，改编自歌剧、话剧、影视剧、漫画、小说、历史传说、神话故事等；</p><p>  其次是系统的演员培养方式和优秀的团内文化，很多人真正粉上宝冢歌剧不是由于戏剧本身，而是由于舞台上绚丽多姿的演员们，尤其是男役演员。所谓“男役十年”，即培养一个优秀的男役演员需要十年的功夫来模仿、沉淀和学习，从而演绎出“女性眼中最完美的男性”。其次，在宝冢音乐学院里，学生不仅要学习各种歌剧表演方面的技能和知识，更加重要的是对气质的培养，即“清正美”的形象和态度。</p><h2 id="五歌剧少女与宝冢歌剧">五、歌剧少女与宝冢歌剧</h2><p>  在讨论宝冢歌剧的魅力时，上面提到了宝冢歌剧团演员的培养和团内文化，而这方面的魅力如何才能展现在大众的面前呢？如何能将宝冢歌剧团内日复一日的枯燥练习，与背后每个团员的故事与经历呈现在大众面前呢？歌剧少女这部番剧，就很好的做到了这一点。</p><p>  制片人诹访丰在访谈中提到，他原本对歌剧并不熟悉，而是在看了原作漫画后对其产生兴趣，<em>“实际去观看了歌剧后，发现非常有趣。我觉得就像是这样的我一样，如果能通过作品，给其他人制造一个契机，会是非常好的一件事，这也是企划立项原因之一。”</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”. https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><p>  实际上，这是一种很好的扩大戏剧影响力的方式，和在论坛中有同学讨论关于游戏原神的角色云瑾与京剧文化的结合相似。歌剧少女通过二次元番剧和漫画的形式，将宝冢歌剧文化浓缩为一个个角色背后生动的故事，故事中的主角即为台上的演员。通过这些或是感人、或是引人发笑的故事，将宝冢歌剧团的魅力更是加深一层，也使得更多原本对宝冢不了解的人们能够来尝试观看歌剧，并找到其中的乐趣。</p><p>  举个例子说明，番剧中有一段关于身材焦虑与催吐的剧情，最终在老师的开导下该角色走出了焦虑。我认为这类的焦虑其实在宝冢歌剧团和一些偶像团体中并不少见，但观众和饭们平时不会对此有深刻的体会。而在观看番剧的过程中，观众们能够认识到这些演员们平时不能在大众面前表现的一面，从而使现实中的演员的人设更加丰富具体。</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>易巧丽.华丽旖旎的女性之梦 谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”. https://www.bilibili.com/read/cv12419830. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
      <category>知识科普</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧</tag>
      
      <tag>戏剧</tag>
      
      <tag>宝冢</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

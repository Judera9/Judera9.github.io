<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Note of Modern Control 2021</title>
    <link href="/2022/02/14/2022-2-14-Note-Of-Modern-Control-2021/"/>
    <url>/2022/02/14/2022-2-14-Note-Of-Modern-Control-2021/</url>
    
    <content type="html"><![CDATA[<h2 id="course">Course</h2><p>  欢迎大家关注我们实验室b站账号，这个课程录像的质量还是很高的，可以作为入门ModernControl的课程资料，下半学期学了一部分最优估计的内容，包括KalmanFilter和DynamicProgramming，主要是前者。很遗憾MPC没有时间讲了，所以这一部分只能等下次开课老师讲的时候来补。<em>本课程有提供github仓库。</em></p><ul><li><ahref="https://space.bilibili.com/474380277?from=search&amp;seid=9415905800355105743&amp;spm_id_from=333.337.0.0">CLEAR_LAB</a></li><li><ahref="https://space.bilibili.com/474380277/channel/collectiondetail?sid=111390">ME424现代控制与最优估计</a></li></ul><h2 id="note">Note</h2><p>  这是自己的期末复习Note，因为博客显示有size限制，所以提供<ahref="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/NoteOfModernControl.pdf">下载链接</a>：</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/期末复习笔记-content.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/期末复习笔记-part1.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/期末复习笔记-part2.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/期末复习笔记-part3.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>课程相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制</tag>
      
      <tag>机器人</tag>
      
      <tag>b站</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda in PyCharm</title>
    <link href="/2022/02/13/2022-2-13-Anaconda-in-PyCharm/"/>
    <url>/2022/02/13/2022-2-13-Anaconda-in-PyCharm/</url>
    
    <content type="html"><![CDATA[<h2 id="what-is-anaconda">What is Anaconda</h2><p>Anaconda is a powerful package management tool, it solves someweakness when using python. For example, the inconvenience of switchingamong different versions of python interpreters and many site-packages.It is similar to the function of <code>pip</code> and <code>pip3</code>,but it is more powerful.</p><h2 id="install-anaconda">Install Anaconda</h2><p>Follow the instruction in 在 <ahref="https://anaconda.org.cn/anaconda/install/linux/">Linux 上安装</a>,which supports chinese. First, you would be asked to download somedependence by the following code (my OS is Ubuntu20.04):</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libgl1-mesa-glx libegl1-mesa libxrandr2 libxrandr2 libxss1 libxcursor1 libxcomposite1 libasound2 libxi6 libxtst6<br></code></pre></td></tr></table></figure><p>Then you would get a <code>.sh</code> file, give it executablepermission. Run the <code>.sh</code> file to install Anaconda just likein Windows. Press <code>Enter</code> all through the progress, youbetter install Anaconda in the default location, which is under the<code>/home/</code> directory. Mention that do not put it under<code>/usr</code>, the official site give a warning about this!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmod +x filename.sh<br>./Anaconda3-2021.11-Linux-x86_64.sh <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Anaconda3 will now be installed into this location:<br>/home/name/anaconda3<br><br>  - Press ENTER to confirm the location<br>  - Press CTRL-C to abort the installation<br>  - Or specify a different location below<br><br>[/home/name/anaconda3] &gt;&gt;&gt; <br></code></pre></td></tr></table></figure><p>After that you would be asked to init the environment, which isactually adjusting the <code>.bashrc</code> file, like using<code>source &lt;path to conda&gt;/bin/activateconda init</code>. Afterall the steps, you would get a respond "Thank you for installingAnaconda3!"</p><h2 id="anaconda-navigator">Anaconda-navigator</h2><p>Anaconda-navigator is a GUI application provided by Anaconda, youcould use it to manage virtual environments without using terminal.Switch to the "Environments" Tab, choose the env that you areinteresting. There are 5 types of selections: <em>Installed, Notinstalled, Updatable, Selected, All</em>. If you want to install a newpackage, one method is to choose <em>Not installed</em>, and then searchthe package you want and download it.</p><h2 id="config-pycharm">Config PyCharm</h2><p>If you haven't got PyCharm, go to <ahref="https://www.anaconda.com/pycharm">this link</a> to download it!Then in the <em>New Project</em> page, choose Conda to manage the newenvironment.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220213232131.png" width="600"></center><p>In the <em>Settings</em> Tab, you could add and remove packages.</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/20220213235222.png" width="600"></center>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>知识科普</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PyCharm</tag>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL入门与Iterator失效</title>
    <link href="/2022/02/12/2022-2-12-Cpp-Iterator/"/>
    <url>/2022/02/12/2022-2-12-Cpp-Iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="stl六大组件">STL六大组件</h2><p>  因为于老师没讲STL，所以补一下课。STL的六大部件是下面这些：容器（Container）、算法（Algorithm）、迭代器（Iterator）、仿函数（Functionobject）、适配器（Adaptor）、空间配置器（allocator）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup>下面分别简单介绍一下：</p><h3 id="容器-container">容器 Container</h3><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td valign="center" width="170"><center><p>容器</p></center></td><td valign="center" width="700"><center><p>特性</p></center></td><td valign="center" width="130"><center><p>所在头文件</p></center></td></tr><tr><td valign="center" width="170"><center><p>向量vector</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;可以用常数时间访问和修改任意元素，</span>在序列尾部进行插入和删除时，具有常数时间复杂度，对任意项的插入和删除就有的时间复杂度与到末尾的距离成正比，尤其对向量头的添加和删除的代价是惊人的高的</p></td><td valign="center" width="130"><center><p>&lt;vector&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>双端队列deque</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;基本上与向量相同，</span>唯一的不同是，其在序列头部插入和删除操作也具有常量时间复杂度</span></p></td><td valign="center" width="130"><center><p>&lt;deque&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>表list</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;对任意元素的访问与对两端的距离成正比，但对某个位置上插入和删除一个项的花费为常数时间。</span></p></td><td valign="center" width="130"><center><p>&lt;list&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>队列queue</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;插入只可以在尾部进行，删除、检索和修改只允许从头部进行。按照先进先出的原则。</span></p></td><td valign="center" width="130"><center><p>&lt;queue&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>堆栈stack</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;堆栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项。即按照后进先出的</span>原则</p></td><td valign="center" width="130"><center><p>&lt;stack&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>集合set</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序，具有快速查找的功能</span>。但是它是以牺牲插入删除操作的效率为代价的</p></td><td valign="center" width="130"><center><p>&lt;set&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>多重集合multiset</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;和集合基本相同，但可以支持重复元素具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;set&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>映射map</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;由{键，值}对组成的集合，以某种作用于键对上的谓词排列。具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;map&gt;</p></center></td></tr><tr><td valign="center" width="170"><center><p>多重集合multimap</p></center></td><td valign="center" width="700"><p>&emsp;&emsp;比起映射，一个键可以对应多了值。具有快速查找能力</span></p></td><td valign="center" width="130"><center><p>&lt;map&gt;</p></center></td></tr></tbody></table><h3 id="算法-algorithm">算法 Algorithm</h3><p>  由头文件<code>&lt;algorithm&gt;</code>，<code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成，<code>&lt;algorithm&gt;</code>是STL头文件中最大的一个，由一大堆模板函数组成，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等。。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup></p><h3 id="迭代器-iterator">迭代器 Iterator</h3><p>  实现位于<code>&lt;itertator&gt;</code>中，在某种程度上，可以理解为指针来使用。容器适配器stack 和 queue没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。另外，有的Iterator能够使用<code>++p</code>，<code>p++</code>，<code>*p</code>操作，还可以被复制或赋值，以及用<code>==</code>和<code>!=</code>等比较运算符。具体的每种Iterator的用法是不一样的，需要查手册。一般迭代器都会有对应的常量迭代器，能够避免用户修改指向的内容（类似constvoid*的指针）。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://c.biancheng.net/view/6675.html">[3]</span></a></sup></p><table border="0" cellspacing="0" cellpadding="0"><tbody><tr><td colspan="3" valign="center"><p align="center">迭代器功能</p></center></td></tr><tr><td valign="center" width="350"><p>输入迭代器 Input iterator</p></td><td valign="center" width="350"><center><p>Reads forward</p></center></td><td valign="center" width="300"><center><p>istream</p></center></td></tr><tr><td valign="center" width="350"><p>输出迭代器 Output iterator</p></td><td valign="center" width="350"><center><p>Writes forward</p></center></td><td valign="center" width="300"><center><p>ostream, inserter</p></center></td></tr><tr><td valign="center" width="350"><p>前向迭代器 Forward iterator</p></td><td valign="center" width="350"><center><p>Read and Writes forward</p></center></td><td valign="center" width="300"><center><p> </p></center></td></tr><tr><td valign="center" width="350"><p>双向迭代器 Bidirectional iterator</p></td><td valign="center" width="350"><center><p>Read and Writes forward and backward</span></p></center></td><td valign="center" width="300"><center><p>list, set, multiset, map, mul, timap</span></p></center></td></tr><tr><td valign="center" width="350"><p>随机迭代器 Random access iterator</p></td><td valign="center" width="350"><center><p>Read and Write with random access</p></center></td><td valign="center" width="300"><center><p>vector, deque, array, string</p></center></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 举个例子，如何使用Iterator</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-comment">// use for loop to iterate</span><br>        cout &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator i; <span class="hljs-comment">// declare iterator</span><br>    <span class="hljs-keyword">for</span> (i = v.<span class="hljs-built_in">begin</span>(); i != v.<span class="hljs-built_in">end</span>(); ++i) <span class="hljs-comment">// use `i &lt; v.end()` is also fine</span><br>        cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="仿函数-functor">仿函数 Functor</h3><p>  仿函数(functor)又称之为函数对象（functionobject），其实就是重载了()操作符的struct或者class，使一个类的使用看上去象一个函数。这些仿函数可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理。C语言使用函数指针和回调函数来实现仿函数；在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象，而不是一个普通函数。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/K346K346/article/details/82818801">[2]</span></a></sup></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在C语言中，例如一个用来排序的函数可以这样使用仿函数</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/* Callback function */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_ints_function</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* A, <span class="hljs-keyword">void</span>* B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *((<span class="hljs-keyword">int</span>*)(A)) &lt; *((<span class="hljs-keyword">int</span>*)(B));<br>&#125;<br><br><span class="hljs-comment">/* Declaration of C sorting function */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* first_item, <span class="hljs-keyword">size_t</span> item_size, <span class="hljs-keyword">void</span>* last_item, <span class="hljs-keyword">int</span>(*cmpfunc)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*))</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> items[]=&#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    sort((<span class="hljs-keyword">void</span>*)(items), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), (<span class="hljs-keyword">void</span>*)(items +<span class="hljs-number">3</span>), compare_ints_function);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在C++中，重载括号运算符实现仿函数</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsGreaterThanThresholdFunctor</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsGreaterThanThresholdFunctor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> : threshold(t) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-comment">// 可以用户design这一部分</span><br>        <span class="hljs-keyword">return</span> num &gt; threshold;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> threshold; <span class="hljs-comment">// 利用成员变量的特性，避免全局变量</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RecallFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end, IsGreaterThanThresholdFunctor myFunctor)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> *i = start; i != end + <span class="hljs-number">1</span>; i++) &#123;<br>        count = <span class="hljs-built_in">myFunctor</span>(*i) ? count + <span class="hljs-number">1</span> : count; <span class="hljs-comment">// 传参给operator()函数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>&#125;;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">RecallFunc</span>(a, a + <span class="hljs-number">4</span>, <span class="hljs-built_in">IsGreaterThanThresholdFunctor</span>(<span class="hljs-number">10</span>));<br>    cout &lt;&lt; result &lt;&lt; endl; <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适配器-adaptor-空间配置器-allocator">适配器 Adaptor &amp;空间配置器 Allocator</h3><p>  适配器是用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。</p><ul><li><p><strong>容器适配器</strong>：包括栈（stack）、队列(queue)、优先(priority_queue)。使用容器适配器，stack就可以被实现为基本容器类型（vector,dequeue,list）的适配。可以把stack看作是某种特殊的vctor,deque或者list容器，只是其操作仍然受到stack本身属性的限制。queue和priority_queue与之类似。容器适配器的接口更为简单，只是受限比一般容器要多。</p></li><li><p><strong>迭代器适配器</strong>：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。</p></li><li><p><strong>函数适配器</strong>：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器有否定器（相当于"非"操作）、绑定器、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或是将多参数的函数对象转化为少参数的函数对象。</p></li></ul><p>  STL内存配置器为容器分配并管理内存，统一的内存管理使得STL库的可用性、可移植行、以及效率都有了很大的提升。SGI-STL的空间配置器有2种，一种仅仅对c语言的malloc和free进行了简单的封装，而另一个设计到小块内存的管理等，运用了内存池技术等。在SGI-STL中默认的空间配置器是第二级的配置器。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/welen/articles/3533008.html">[1]</span></a></sup></p><h2 id="具体学习iterator">具体学习Iterator</h2><h3 id="自增操作">自增操作</h3><p>  注意<code>A(i++);</code>是先执行<code>A(i)</code>，再执行<code>i++;</code>，后者相反。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; i++ &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="迭代器失效">迭代器失效</h3><p>可以参考<ahref="https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2">第四个Reference</a>，讲的很细致。关键的点基本都在下面：<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2">[4]</span></a></sup></p><ul><li>C++标准中，<strong>顺序容器的erase函数会返回iterator，但关联容器的erase函数不返回iterator</strong>；</li><li>对于顺序容器vector、deque，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector、deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。erase方法可以返回下一个有效的iterator；</li><li>对于关联容器map、set、multimap、multiset，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响；</li><li>对于顺序容器list，erase方法可以返回下一个有效的iterator。由于list是一个链表，删除当前的iterator，仅仅会使当前的iterator失效，所以也可以在erase时，递增当前的iterator。</li><li>erase函数返回被删除元素的下一个元素的迭代器。<strong>在STL中，不能以指针来看待迭代器，指针是与内存绑定的，而迭代器是与容器里的元素绑定的</strong>。</li></ul><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.cnblogs.com/welen/articles/3533008.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/K346K346/article/details/82818801<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>http://c.biancheng.net/view/6675.html<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/u010318270/article/details/78575371?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Iterator</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍树莓派Pico | MicroPython插件</title>
    <link href="/2022/02/12/2022-2-12-Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/"/>
    <url>/2022/02/12/2022-2-12-Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/</url>
    
    <content type="html"><![CDATA[<h2 id="raspberry-pico">Raspberry Pico</h2><p>推荐网页：<a href="https://pico.org.cn/">树莓派 Pico 中文站</a></p><blockquote><p>上面的站点提供了树莓派 Pico 开发板的说明文档，以及完备的 RP2040芯片资料，本文也有参考上面的内容。</p></blockquote><h3 id="pico-规格参数">Pico 规格参数</h3><p>  这里涉及了很多嵌入式方面的知识，这一块我学的不是很好，有一些看得不是很明白的以后用到再来学吧。看了看相关的评测<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup>，ESP32不仅比Pico便宜而且外设还丰富的多，而且也支持MicroPython。不过我自己也只是买着玩玩，不用在意这些，个人感觉主要树莓派学习门槛更低吧。</p><ul><li>双核 Arm Cortex-M0 + @ 133MHz</li><li>芯片内置 264KB SRAM 和 2MB 的板载闪存</li><li>通过专用 QSPI 总线支持最高 16MB 的片外闪存</li><li>DMA 控制器</li><li>30 个 GPIO 引脚，其中 4 个可用作模拟输入</li><li>2 个 UART、2 个 SPI 控制器和 2 个 I2C 控制器</li><li>16 个 PWM 通道</li><li>USB 1.1 主机和设备支持</li><li>8 个树莓派可编程 I/O（PIO）状态机，用于自定义外围设备支持</li><li>支持 UF2 的 USB 大容量存储启动模式，用于拖放式编程</li></ul><blockquote><p><strong>SRAM是什么</strong>：SRAM (static RAM) is random accessmemory (RAM) that retains data bits in its memory as long as power isbeing supplied. Unlike dynamic RAM (DRAM), which stores bits in cellsconsisting of a capacitor and a transistor, SRAM does not have to beperiodically refreshed. Static RAM provides faster access to data and ismore expensive than DRAM. SRAM is used for a computer's cache memory andas part of the random access memory digital-to-analog converter on avideocard.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://whatis.techtarget.com/definition/SRAM-static-random-access-memory">[1]</span></a></sup></p></blockquote><blockquote><p><strong>QSPI是什么</strong>：QSPI是QueuedSPI的简写，是Motorola公司推出的SPI接口的扩展，比SPI应用更加广泛。在SPI协议的基础上，Motorola公司对其功能进行了增强，增加了队列传输机制，推出了队列串行外围接口协议（即QSPI协议）。片外闪存顾名思义就是外接的Flash存储空间。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/firege/p/9435349.html">[2]</span></a></sup></p></blockquote><blockquote><p><strong>PIO是什么</strong>：这是应该是Pico最大的亮点，我没有看得很明白官方的说明。大概就是说能够使用PIO来实现硬件接口，相对于软件模拟的方式，可以达到更高的时钟精度、高得多的I/O吞吐量，还能分担一点CPU的计算工作，比如奇偶校验、和校验等。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup></p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/pico/20220212190432.png" width="1000"><center>Pico原理图</center></center><h3 id="pico提供的开发工具">Pico提供的开发工具</h3><p>  有一个C++的SDK，是专门给Pico设计的，感觉没有必要，用这套SDK不如用STM32系列的SDK。除了C++之外还有一个MicroPython的SDK，我是打算用这个来做点小东西，顺便学习一下各种嵌入式常见的外设。除此之外，学一些MicroPython也挺好的，主要看这个文档<ahref="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf">PicoPython SDK</a>。除此之外还有<ahref="https://datasheets.raspberrypi.com/rp2040/hardware-design-with-rp2040.pdf">RP2040硬件设计</a>、<ahref="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040Datasheet</a>和<ahref="https://datasheets.raspberrypi.com/pico/pico-datasheet.pdf">树莓派PicoDatasheet</a>这三个文档也可以作为学习过程的参考，主要和RP2040和Pico的硬件外设有关。</p><h2 id="pycharm-micropython-插件">PyCharm MicroPython 插件</h2><p>  直接在PyCharm的Settings-Plugins中去搜索“MicroPython”插件然后安装，完成后需要在Project中进行配置，在Settings-Languages&amp; Frameworks-MicroPython对开启该插件进行勾选，然后选择对应的Devicetype和Device path（我是在linuxubuntu下所以是dev/ttyACM0）。完成配置后使用如下程序进行测试，如果LED灯闪烁说明配置成功（REPL显示对应输出）：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin<br><span class="hljs-keyword">import</span> time<br><br>led = Pin(<span class="hljs-number">25</span>, Pin.OUT)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    led.value(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light on&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    led.value(<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light off&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/pico/20220212200558.png" width="600"><center>Pico原理图</center></center><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://whatis.techtarget.com/definition/SRAM-static-random-access-memory<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.cnblogs.com/firege/p/9435349.html<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.zhihu.com/question/440677296<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>知识科普</category>
      
      <category>Raspberry Pico</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raspberry</tag>
      
      <tag>Pico</tag>
      
      <tag>MicroPython</tag>
      
      <tag>嵌入式</tag>
      
      <tag>Python</tag>
      
      <tag>PyCharm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》0 导读</title>
    <link href="/2022/02/02/2022-2-2-Effective-Cpp-Introduction/"/>
    <url>/2022/02/02/2022-2-2-Effective-Cpp-Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="terminology">Terminology</h2><h3 id="声明-declaration">声明-declaration</h3><p>在《C++ Primer》中提到：</p><blockquote><p>变量声明：用于向程序表明变量的类型和名字。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> x; <span class="hljs-comment">// declare an object</span><br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">numDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>; <span class="hljs-comment">// declare a function</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span> <span class="hljs-comment">// declare a class</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// declare a template</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span>;</span><br></code></pre></td></tr></table></figure><h4 id="extern关键字">extern关键字</h4><p>  通过使用extern关键字能够声明变量名而不定义它，使用extern编译器不会给变量分配存储空间。所以<code>externint x;</code>是声明而不是定义，而<code>intx;</code>是声明也是定义。但是如果对声明进行了initialization，如<code>externint x = 1;</code>，则一定是定义。</p><p>  对函数来说如果加了<code>&#123;&#125;</code>就是定义，如果没有就是声明。<strong>在一个程序中，变量或函数可以声明多次（如下会提示<code>Clang-Tidy:Redundant 'foo'declaration</code>），但是定义只能有一次</strong>，如下代码能够编译成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// redundant declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123; <span class="hljs-comment">// definition</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用std">使用std</h4><p>  为了方便，作者在后面章节的代码中省略了C++标准程序库的命名空间<code>std::</code>的书写，但是在实际编译时是不能省略的。另外，<code>usenamespacestd;</code>并不是一个好选择，因为会引入很多不必要的名称，这可能会导致灾难性的结果。在《C++Primer Plus》的“第九章-内存模型和名称空间”中，提到：</p><blockquote><p>  一般说来，使用using命令比使用using编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。<strong>如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。</strong>另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><h4 id="为什么使用size_t">为什么使用size_t</h4><p>  上面提到的标准库中的size_t，是很多C++Programmer知道但是很多时候不敢用的一个typedef的unsignedinteger类型。使用size_t能够使得代码更加便于在不同系统间移植（如IP16L32和I16PL32），同时增加移植性和可读性，可以参考给出的链接<ahref="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?">Whysize_t matters</a>。</p><h4 id="函数签名-signature">函数签名-signature</h4><p>  官方定义的C++signature只包括函数的参数，不包括返回类型。编译器在检查函数signature是否重复时，如果两个函数声明只有返回类型不同，编译器同样会报错，因为它不知道调用的是哪个函数。但是本书为了帮助理解将返回类型视为signature的一部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>  上面的declaration我使用C++14标准会报<em>“Functions that differ onlyin their return type cannot beoverloaded”</em>。如下的代码是可以编译通过的（对于C89来说这两种都不行，C只检查函数名，而不会将参数类型和返回值加到signature中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="定义-definition">定义-definition</h3><p>  书中描述是<em>“definition的任务是提供编译器一些声明式所遗漏的细节“</em>，个人感觉说的不够清楚。在《C++Primer》中提到：</p><blockquote><p>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义（定义也是声明）。</p></blockquote><h4 id="关于声明与定义的程序设计风格">关于声明与定义的程序设计风格</h4><p>  参考博客<ahref="https://blog.csdn.net/sjxbf/article/details/6310150">C++定义与声明区别</a>，我觉得有几点很值得注意：</p><ol type="1"><li>不要把变量定义放入.h文件，这样容易导致重复定义错误。</li><li>但是值在编译时就已知的const变量的定义、类的定义、inline函数的定义可以放到头文件中。</li><li>尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。</li><li>可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。</li></ol><h3 id="初始化-initialization">初始化-initialization</h3><p>  初始化是“给予对象初值”的过程，通常由构造函数constructor完成。需要注意如下三个特别的构造函数：default构造函数、copy构造函数、以及copyassignment操作符。</p><h4 id="default构造函数">default构造函数</h4><p>  default构造函数的要求是<em>“一个可被调用而不带任何实参者”</em>，也可以是每个参数都有缺省值。<strong>通常来说，建议构造函数被声明为explicit，这样能够阻止implicittype conversions。</strong></p><h4 id="copy构造函数和copy-assignment操作符">copy构造函数和copyassignment操作符</h4><p>  copy构造函数被用来<em>“以同型对象初始化自我对象”</em>，而copyassignment操作符被用来<em>“从另一个同型对象中拷贝其值到自我对象”</em>。copy构造和copy赋值的区别在于是否有新的对象被创建。<strong>这两个都是典型的pass-by-value的方式，而一般更好的方式是pass-by-reference-to-const。</strong>书中的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(); <span class="hljs-comment">// default构造函数</span><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy构造函数</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy assignment操作符</span><br>    ...<br>&#125;;<br>Widget w1; <span class="hljs-comment">// 调用default构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">(w1)</span></span>; <span class="hljs-comment">// 调用copy构造函数</span><br>w1 = w2; <span class="hljs-comment">// 调用copy assignment操作符</span><br></code></pre></td></tr></table></figure><h3 id="standard-template-library-stl">Standard TemplateLibrary-STL</h3><p>  是C++标准程序库的一部分，内含容器（vector、list、set、map等），迭代器（iterator、set<string>::iterator等），算法（for_each、find、sort等）及其相关机能。作者说STL是非常有用的，不过我基本没用过（因为我C++课的老师主要让我们搞速度优化，用STL肯定卷不过别人了）。</p><h3 id="不明确行为-undefined-behavior">不明确行为-undefinedbehavior</h3><p>  带有undefinedbehavior的程序通常是令人崩溃的，这样的程序即使能够编译成功，在执行过程中可能有时正常执行，有时造成崩坏，有时产生不正确的结果。因此，使用C++编程时要能够自己处理异常并小心避免undefinedbehavior。下面程序的返回值就是一个随机的结果，因为数组name的大小为6，发生了越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> name[] = <span class="hljs-string">&quot;Darla&quot;</span>;<br><span class="hljs-keyword">char</span> c = name[<span class="hljs-number">10</span>];<br>std::cout &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h2 id="tr1和boost">TR1和Boost</h2><p>TR1是描述C++许多新机能的一份规范，而Boost是一个相关的开源平台。关于这方面，下面提供了一些可能有帮助的C++学习相关资源链接。</p><ul><li><ahref="https://www.runoob.com/cplusplus/cpp-useful-resources.html">C++有用的资源</a></li><li><a href="https://en.cppreference.com/w/cpp/header">C++ StandardLibrary headers</a></li><li><a href="https://en.wikibooks.org/wiki/C++_Programming">C++Programming（书）</a></li><li><a href="http://www.sunistudio.com/cppfaq/">C++ FAQ LITE —Frequently Asked Questions</a></li><li><a href="https://www.thefreecountry.com/sourcecode/cpp.shtml">Free C/ C++ Libraries, Source Code and Frameworks</a></li><li><a href="https://www.boost.org/">boost</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》阅读笔记目录</title>
    <link href="/2022/02/02/2022-2-2-Effective-Cpp-Content/"/>
    <url>/2022/02/02/2022-2-2-Effective-Cpp-Content/</url>
    
    <content type="html"><![CDATA[<p>  《Effective C++第三版》这本书给出了55条使用C++编程时需要注意的要点，帮助程序员写出更加优雅合理的程序。如导读里所说，<em>“学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是另一回事”</em>，在这方面C++是代表。因此，本书的目的不是教你学会C++，而是学习如何写出Effective的C++程序。</p><p>  我记录这篇笔记的目的是为了提取我自己认为重要，或是需要的条款，方便以后写代码时随时能够查看使用。因此，有些地方可能会进行拓展学习，有些地方只是一笔带过。个人能力有限，如果有错误的内容烦请在评论区指正！</p><p>  另外帮我的C++课老师于仕琪教授打个广告，他的C++程序设计课程体验很棒。大家可以去<ahref="https://space.bilibili.com/519963684?from=search&amp;seid=2332289542653409243&amp;spm_id_from=333.337.0.0">b站</a>围观一下，并且这里也提供了他的<ahref="https://github.com/ShiqiYu/CPP">课程仓库</a>，大家可以下载ppt和实例代码看看，课程讲了很多矩阵运算优化方法。</p><h2 id="catalog">Catalog</h2><ol start="0" type="1"><li><a href="">Introduction</a></li><li><a href="">Accustoming Yourself to C++</a></li><li><a href="">Constructors, Destructors, and AssignmentOperators</a></li><li><a href="">Resource Management</a></li><li><a href="">Designs and Declarations</a></li><li><a href="">Implementations</a></li><li><a href="">Inheritance and Object-Oriented Design</a></li><li><a href="">Templates and Generic Programming</a></li><li><a href="">Customizing new and delete</a></li><li><a href="">Miscellany</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陆地冲浪板介绍与选型</title>
    <link href="/2022/01/30/2022-1-30-Surfskate-Selection/"/>
    <url>/2022/01/30/2022-1-30-Surfskate-Selection/</url>
    
    <content type="html"><![CDATA[<hr /><h2 id="surfskate的由来">Surfskate的由来</h2><p>  中文名陆地冲浪板（简称“陆冲”），板如其名，是用于模拟海上冲浪的。众所周知，冲浪要在暖季合适的海岸，滑雪要在冬季合适的雪地，条件苛刻，更别提大家疲于996福报很少有时间出行去冲浪滑雪。因此，入手一个陆地冲浪板能够帮助提高技能水平，是冲浪滑雪很好的练习道具。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-surf.jpeg" height="250" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-ski.png" height="250" /></div></div></div><h2 id="市面大牌选型">市面大牌选型</h2><p>  可以参考<ahref="https://www.zhihu.com/people/surfskate">这个链接</a>，这位大佬对于每种品牌的特点和桥的特点都说的很明白。这个大佬做了一张图，我只用过Yow的桥没啥发言权，所以参考这位老兄的经验肯定是靠谱的。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/others/choose_surfskate.jpg" width=1000"></center><h2 id="保养与维护">保养与维护</h2>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=62322438&bvid=BV1ht411M78i&cid=108319980&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p>另外还可以参考：</p><ul><li><a href="https://www.bilibili.com/video/av89625664">YOW陆地冲浪板官方维修指南 Surf YOW Systems Tutorial</a></li><li><ahref="https://zhuanlan.zhihu.com/p/105870163">Carver冲浪滑板和其他Surfskate陆地冲浪板入门到快乐（五）维修篇</a></li><li><ahref="https://space.bilibili.com/508830">猫咪贵族（b站一位玩陆冲的大佬）</a></li></ul><h2 id="玩法show">玩法show</h2><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/82459365">陆地冲浪surfskate入手后的问题和使用说明书！</a></li><li><ahref="https://www.bilibili.com/video/BV1wy4y1E7KL?from=search&amp;seid=16512587863776667224&amp;spm_id_from=333.337.0.0">日本小哥横刹(PowerSlide)教学【搬运|字幕】</a></li></ol><p><em>我玩的经验下次博客再介绍吧（等我玩熟练了先） ヾ(=･ω･=)o</em></p>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>杂学笔记</category>
      
      <category>陆地冲浪/冲浪/滑雪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>surfskate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐理基础</title>
    <link href="/2022/01/30/2022-1-30-Music-Theory/"/>
    <url>/2022/01/30/2022-1-30-Music-Theory/</url>
    
    <content type="html"><![CDATA[<p>图片和教程来源，<ahref="https://www.bilibili.com/video/BV14x411s7KZ?p=1">bilibili乐球网编曲教程</a>。个人仅作笔记，侵删。</p><span id="more"></span><h2 id="音程">音程</h2><p>  我们能够用<strong>属性+大小+单位</strong>的方式来描述音程。音程是两个音之间的距离，单位都是度；大小有从一到七；属性有<strong>纯、大、小、增、减、倍增、倍减</strong>。</p><h3 id="音程大小">音程大小</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204192938.png" width="550"><center>图 1</center></center><ul><li>对于白键：直接数两者之间有几个白键就是几度，注意是包括开始和结束的键；</li><li>对于黑键：首先还原黑键，然后和白键一样数就行；</li></ul><blockquote><p>  也可以这样，sou就是5，升re就是♯2（或者♭3），因此对应(5-2)+1=4，所以是四度。不过好像跨了下一个八度就不好算了，还是好好数琴键吧&gt;_&lt;|||</p></blockquote><h3 id="音程属性">音程属性</h3><p>  如图1所示，尽管大小相同，还需要区分属性。<strong>“纯”只存在于一、四、五、八度中，“大/小“只存在于二、三、六、七度中，而“增、减、倍增、倍减”存在于所有度数大小</strong>。即，不存在纯三度或大四度。</p><h3 id="标准音程与音程计算">标准音程与音程计算</h3><p>  标准音程是以C为起点到下一个八度的C为止，共七个白键音程的名称。如图2所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204203925.png" width="550"><center>图 2</center></center><p>  对于不是两个琴键都落在白键上的情况，遵循以下的步骤进行计算：</p><ol type="1"><li>找大小：还原升降号，然后数白键的数量；</li><li>找属性：数白键和黑键的总数，通过图3的公式和标准音程比较，进行计算；</li></ol><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204204602.png" width="550"><center>图 3</center></center><p>  例如：对于♯F和D，如图4所示。首先，还原♯F，F和D之间有6个琴键，所以是六度。标准的六度是10个键，对应的是大六度。然后，数白键与黑键一共是9个键，因此根据公式结果是小六度。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204205257.png" width="550"><center>图 4</center></center><blockquote><p>  我自己总结也差不多，假设E和F之间以及B和C之间少了一个黑键我们叫做一个坑（“少了个黑键”），那么最终其实就是比较坑的数量嘛。假设还是♯F和D，很容易发现♯F和G之间由于升降号导致了一个坑，在B和C之间本来有一个坑，那么一共是两个坑。标准的六度是一个坑（标准的四度到七度都是一个坑），所以♯F到D比标准的多了一个坑（“少了一个黑键”），因此是小六度。</p></blockquote><h2 id="和弦">和弦</h2><p>  和弦就是<strong>以任何一个音作为根音，往上按照三度的音程关系叠加构成的组合</strong>。和弦最少是三个音，两个音的是音程。所谓三和弦，指的是根音到冠音的度数是三，而后面直到十三和弦以此类推。音最多的十三和弦有7个音，刚好从C到B。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204223656.png" width="550"><center>图 5</center></center><h3 id="三和弦">三和弦</h3><p>  属性包括“<strong>大三和弦、小三和弦、增三和弦、减三和弦</strong>”，其中增三和弦在流行乐中很少用到，所以这里不讲。区分大三和弦，小三和弦和减三和弦的方式是看三和弦的两个音程的属性，如图6：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204231246.png" width="550"><center>图 6</center></center><p>  例如：FAC是大三度+小三度=F大三和弦，F♭AC是小三度+大三度=F小三和弦，F♭A♭C是小三度+小三度=F减三和弦（这就是F为根音对应的几个三和弦）</p><h3 id="七和弦">七和弦</h3><p>  属性主要包括“<strong>大大七和弦、小小七和弦、大小七和弦、减小七和弦、减减七和弦</strong>”，其中我们并不会这么叫，实际的叫法是“<strong>大七和弦、小七和弦、属七和弦、半减七和弦、减七和弦</strong>”。区分它们的方法建立在三和弦的分类基础上，如图7所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204233441.png" width="550"><center>图 7</center></center><p>  例如：DFAC是小三和弦+小七度=D小七和弦，DF♭AC是减三和弦+小七度=D半减七和弦，DF♭A♭C是减三和弦+减七度=D减七和弦（这就是D为根音对应的几个七和弦）</p><blockquote><p>这里其实可以换一种理解方式（可能更好计算一点）： *大三和弦+大三（大七）=大七和弦 * 大三和弦+小三（小七）=属七和弦 *小三和弦+小三（小七）=小七和弦 * 减三和弦+大三（小七）=半减七和弦 *减三和弦+小三（减七）=减七和弦</p></blockquote><h3 id="和弦转位">和弦转位</h3><p>  和弦转位其实就是将和弦中的某个或某些音提高了八度，然后低音变成了其他音。如图8中C（表示C大三和弦）的转位，由于除了根音外有两个音，所以三和弦都是有两个转位的。图8中间的<strong>C/E就是C和弦第一转位，“/”前面的“C”表示这是一个C和弦，后面的“E”表示低音演奏E</strong>；而C/G同理。注意到，对于C/E来说，只要保证低音是E，上面不论是135还是513都没有关系，都是C和弦第一转位。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204234704.png" width="550"><center>图 8</center></center><p>  对于七和弦，也是同样的道理。例如：CM7（也就是C小七和弦）是CEGB是原位，然后第一转位是CM7/E，也就是E...（如EGBC），第二转位是G...（如GBCE），以此类推共有三个和弦转位。再比如下图9，原位是D7（D属七和弦），对应的三个转位是D7/♯F、D7/A、D7/C。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205000556.png" width="550"><center>图 9</center></center><h2 id="音调">音调</h2><p>  对于一首歌，如果调太高了唱不上去，我们通常会降调，音阶整体上移或下移就是变调（变调是不会改变旋律本身的）。首先是自然大调和自然小调，在其基础上对六音和七音进行升降就得到和声大调、旋律大调、和声小调、旋律小调。</p><h3 id="自然大调">自然大调</h3><p>  总结来说，<strong>听起来像CDEFGABC的就是自然大调</strong>，上述是C大调。再比如说，♭D大调是♭D♭EF♭G♭A♭BC♭D，E大调是E♯F♯GAB♯C♯DE，这些自然大调的音阶结构，都是如下图10所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205103723.png" width="550"><center>图 10</center></center><h3 id="自然小调">自然小调</h3><p>  总结来说，<strong>听起来像ABCDEFGA的就是自然大调</strong>，上述是A小调。再比如说，C小调是CD♭EFG♭A♭BC。自然小调的音阶结构如下图11所示。由此，我们又能够看出，C大调和A小调的音是一样的，只是顺序不同而已，因此它们称为<strong>关系大小调</strong>。除此之外，C大调的C和A小调的A之间差了一个小3°，因此所有的关系大小调间也是差了一个小3°。例如，C小调的关系大调是♭E大调。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205110501.png" width="550"><center>图 11</center></center><h3 id="如何辨别一首歌的调">如何辨别一首歌的调</h3><blockquote><p>  这里貌似教程少了这方面的内容，所以另外找了个讲的很好的视频补上！<strong>其实就是听最后的结尾旋律，一般流行乐的结尾音就是这个调的调名啦</strong>，不过我乐感好拉跨（羡慕绝对音感的人）。</p></blockquote>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=43075656&bvid=BV1cb411S7ra&cid=141283989&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><h3 id="调性">调性</h3><p>  即在自然大调和自然小调的基础上对六音和七音进行升降，如下图12所示。例如：要找E和声大调，首先找到E自然大调E♯F♯GAB♯C♯DE，然后降低六音得到E♯F♯GABC♯DE，此时再降低七音得到E旋律大调E♯F♯GABCDE。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205140927.png" width="550"><center>图 12</center></center><h2 id="音符">音符</h2><p>  音符就比较简单了，即所谓表示演奏时间的长短。这一部分因为自己好歹学了多年演奏，比较熟练所以就懒得记太多了。图13是从全音符到六十四分音符单个的写法（六十四一般用不到）。图14是节拍的写法，例如：3/4念作四三拍，表示以四分音符为一拍，一个小节是三拍。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205141824.png" width="550"><center>图 13</center></center><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142042.png" width="550"><center>图 14</center></center><h3 id="附点音符">附点音符</h3><p>  附点音符=原音符+原音符的一半，如图15。附点在乐谱上的写法也要注意，如果音符在第n线上，那个附点标记在这条线的上面的间；如果音符在间上，那么直接标记在这个间就可以了。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142607.png" width="550"><center>图 15</center></center><h3 id="休止符">休止符</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205143000.png" width="550"><center>图 16</center></center><h3 id="连音">连音</h3><p>  概念比较简单，注意连音的写法。如果音符是四分音符，标了三连音的符号之后（三连音对应到2），相当于4个四分音符也就是两拍，即<strong>在两拍内演奏完三连音</strong>。再比如如下图17，音符是十六分音符（五、六、七连音对应到4），相当于4个十六分音符也就是一拍，即<strong>在一拍内演奏完五、六、七连音</strong>。以此类推，9～15连音对应到8进行相应的计算。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205144219.png" width="550"><center>图 17</center></center>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人娱乐与文学</title>
    <link href="/2022/01/30/2022-1-30-Robot-Introduction/"/>
    <url>/2022/01/30/2022-1-30-Robot-Introduction/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/robotIntroductionPaper.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>课程相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器人</tag>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝冢与歌剧少女</title>
    <link href="/2022/01/30/2022-1-30-Takarazuka-Revue/"/>
    <url>/2022/01/30/2022-1-30-Takarazuka-Revue/</url>
    
    <content type="html"><![CDATA[<h2 id="一选题原因">一、选题原因</h2><p>  老师在课上介绍宝冢歌剧团时，提问我们是如何了解到“宝冢”这个名字的，当时我回答是从一部番剧了解的，这部番剧即本文分析涉及的2021新番“歌剧少女”。歌剧作为本门课程中重要的课题，我希望结合宝冢歌剧团和这部番剧来进行一些歌剧文化方面的探讨。</p><h2 id="二宝冢歌剧团">二、宝冢歌剧团</h2><p>  与歌舞伎全部为男性演员相反，日本宝冢歌剧以全员女性的形式为观众演绎各种各样的浪漫爱情故事。自大正年间创立以来宝冢已有百年历史，如今分为各具特色的“花、月、雪、星、宙”五个组，可简单总结其特色为歌舞之花、戏剧之月、和物之雪、装扮之星、年轻之宙。宝冢的歌剧题材来源极其广泛，服装和舞台效果也非常还原所演绎的故事设定。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="易巧丽.华丽旖旎的女性之梦谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84.">[1]</span></a></sup></p><p>  宝冢歌剧一个重要的特色是男役演员，为了向以已婚女性主妇为主体的观众展现其“大男主”题材的爱情故事，舞台的核心即男役演员需要展现出完美的男性魅力。宝冢歌剧通过瑰丽的舞台，为女性观众们编织了完美与浪漫的爱情之梦。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-1.png" width="300"><center>宝冢歌剧团首席男役</center></center><h2 id="三歌剧少女">三、歌剧少女</h2><p>  番剧“歌剧少女”是一部歌剧相关题材的漫改动画，于2021年7月开始放送。剧中的红华歌剧学院即现实中的宝冢音乐学院，且许多专有名词，如男役、娘役、预科生等，以及戏剧名和相关文化特色均是直接还原现实中的宝冢文化，个人认为在设定上对宝冢的还原度相对较高。</p><p>  放送完结的第一季对应原作的前日谈部分，介绍了几位不同背景的预科生各自的过往和相互建立羁绊的故事。有意思的是，剧中主要角色的背景还涉及了歌舞伎和偶像文化等。与少女漫画或偶像企划（如lovelive）不同，本剧细致描写了各个同学在学院学习歌剧的跌宕起伏的经历，并且在细节上较好的还原了宝冢音乐学院的特色（如学生间的阶级制度和各种道具等）。</p><p>  “歌剧少女”的片尾曲很有宝冢的歌剧特色，经过调查发现音乐部分是由在宝塚歌剧团工作过的齐藤恒芳先生完成作词、作曲、编曲的。在字幕表中能看到不少宝冢的OG也有演出。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-2.png" width="300"><center>歌剧少女宣传封面</center></center><h2 id="四宝冢歌剧文化的创新与魅力">四、宝冢歌剧文化的创新与魅力</h2><p>  <em>“一般文化的寿命是50年，50年过后，即便不消失也不再是大众之物。”</em></p><p>  随着互大众传媒的发展，娱乐的形式和观赏娱乐的方式都在不断扩张，许多曾经流行的艺术也在逐渐淡出历史舞台。这并不是一件坏事，毕竟艺术源于生活，而当一种艺术已经与当代人的生活脱钩时，这种艺术也不再能引起人们的共鸣。如为了迎合当下快节奏的生活方式而诞生出的“短视频”文化，而像豫剧、河北梆子等这种地方戏剧没有跟上时代的改变并迎合现代人的喜好，便逐渐在戏剧的历史舞台上消逝。</p><p>  我认为宝冢歌剧是成功迎合新时代的文化之一，我认为主要原因有两点。</p><p>  首先是题材上的创新，在电视刚开始流行的时候，宝冢歌剧遭遇了严重的打击，而她们顶住舆论的压力，用一部《凡尔赛玫瑰》成功背水一战重新焕发生机。而后来她们也尝试去改编各种各样的题材，包括古代历史、近代风物、当代故事、甚至关于未来想象，容纳了中国、阿拉伯、印度等各个国家的文化，改编自歌剧、话剧、影视剧、漫画、小说、历史传说、神话故事等；</p><p>  其次是系统的演员培养方式和优秀的团内文化，很多人真正粉上宝冢歌剧不是由于戏剧本身，而是由于舞台上绚丽多姿的演员们，尤其是男役演员。所谓“男役十年”，即培养一个优秀的男役演员需要十年的功夫来模仿、沉淀和学习，从而演绎出“女性眼中最完美的男性”。其次，在宝冢音乐学院里，学生不仅要学习各种歌剧表演方面的技能和知识，更加重要的是对气质的培养，即“清正美”的形象和态度。</p><h2 id="五歌剧少女与宝冢歌剧">五、歌剧少女与宝冢歌剧</h2><p>  在讨论宝冢歌剧的魅力时，上面提到了宝冢歌剧团演员的培养和团内文化，而这方面的魅力如何才能展现在大众的面前呢？如何能将宝冢歌剧团内日复一日的枯燥练习，与背后每个团员的故事与经历呈现在大众面前呢？歌剧少女这部番剧，就很好的做到了这一点。</p><p>  制片人诹访丰在访谈中提到，他原本对歌剧并不熟悉，而是在看了原作漫画后对其产生兴趣，<em>“实际去观看了歌剧后，发现非常有趣。我觉得就像是这样的我一样，如果能通过作品，给其他人制造一个契机，会是非常好的一件事，这也是企划立项原因之一。”</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><p>  实际上，这是一种很好的扩大戏剧影响力的方式，和在论坛中有同学讨论关于游戏原神的角色云瑾与京剧文化的结合相似。歌剧少女通过二次元番剧和漫画的形式，将宝冢歌剧文化浓缩为一个个角色背后生动的故事，故事中的主角即为台上的演员。通过这些或是感人、或是引人发笑的故事，将宝冢歌剧团的魅力更是加深一层，也使得更多原本对宝冢不了解的人们能够来尝试观看歌剧，并找到其中的乐趣。</p><p>  举个例子说明，番剧中有一段关于身材焦虑与催吐的剧情，最终在老师的开导下该角色走出了焦虑。我认为这类的焦虑其实在宝冢歌剧团和一些偶像团体中并不少见，但观众和饭们平时不会对此有深刻的体会。而在观看番剧的过程中，观众们能够认识到这些演员们平时不能在大众面前表现的一面，从而使现实中的演员的人设更加丰富具体。</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>易巧丽.华丽旖旎的女性之梦谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>课程相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>戏剧</tag>
      
      <tag>番剧</tag>
      
      <tag>宝冢</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

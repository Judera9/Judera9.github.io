<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Image Spatial Operations and Filtering | Jude's Blog</title><meta name="keywords" content="DIP,滤波,NumPy,Histogram"><meta name="author" content="Jude"><meta name="copyright" content="Jude"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Support .ipynb and images are here">
<meta property="og:type" content="article">
<meta property="og:title" content="Image Spatial Operations and Filtering">
<meta property="og:url" content="https://judera9.github.io/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/index.html">
<meta property="og:site_name" content="Jude&#39;s Blog">
<meta property="og:description" content="Support .ipynb and images are here">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-03-16T03:33:34.000Z">
<meta property="article:modified_time" content="2022-06-12T14:57:07.994Z">
<meta property="article:author" content="Jude">
<meta property="article:tag" content="DIP">
<meta property="article:tag" content="滤波">
<meta property="article:tag" content="NumPy">
<meta property="article:tag" content="Histogram">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://judera9.github.io/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Image Spatial Operations and Filtering',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-12 22:57:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jude's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Image Spatial Operations and Filtering</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-16T03:33:34.000Z" title="发表于 2022-03-16 11:33:34">2022-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-12T14:57:07.994Z" title="更新于 2022-06-12 22:57:07">2022-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/">课程相关</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/DIP/">DIP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Image Spatial Operations and Filtering"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Support <code>.ipynb</code> and images are <a target="_blank" rel="noopener" href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/spatial%20operation%20and%20filtering">here</a></p>
<span id="more"></span>
<h1 id="spatial-transforms-and-filtering">Spatial Transforms and Filtering</h1>
<ul>
<li><a href="#spatial-transforms-and-filtering">Spatial Transforms and Filtering</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#task-1">Task 1</a>
<ul>
<li><a href="#histogram-equalization">Histogram Equalization</a>
<ul>
<li><a href="#principle">Principle</a></li>
<li><a href="#pseudo-code">Pseudo Code</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul></li>
</ul></li>
<li><a href="#task-2">Task 2</a>
<ul>
<li><a href="#histogram-match">Histogram Match</a>
<ul>
<li><a href="#principle-1">Principle</a></li>
<li><a href="#pseudo-code-1">Pseudo Code</a></li>
<li><a href="#implementation-1">Implementation</a></li>
</ul></li>
<li><a href="#gamma-transform">Gamma Transform</a></li>
<li><a href="#local-statistic-enhancement">Local Statistic Enhancement</a></li>
</ul></li>
<li><a href="#task-3">Task 3</a>
<ul>
<li><a href="#local-histogram-equalization">Local Histogram Equalization</a>
<ul>
<li><a href="#principle-2">Principle</a></li>
<li><a href="#pseudo-code-2">Pseudo Code</a></li>
<li><a href="#implementation-2">Implementation</a></li>
</ul></li>
<li><a href="#gamma-transform-1">Gamma Transform</a></li>
<li><a href="#local-statistic-enhancement-1">Local Statistic Enhancement</a></li>
</ul></li>
<li><a href="#task-4">Task 4</a>
<ul>
<li><a href="#box-filter">Box Filter</a>
<ul>
<li><a href="#principle-3">Principle</a></li>
<li><a href="#pseudo-code-3">Pseudo Code</a></li>
<li><a href="#implementation-3">Implementation</a></li>
</ul></li>
<li><a href="#median-filter">Median Filter</a>
<ul>
<li><a href="#principle-4">Principle</a></li>
<li><a href="#pseudo-code-4">Pseudo Code</a></li>
<li><a href="#implementation-4">Implementation</a></li>
</ul></li>
<li><a href="#gaussian-filter">Gaussian Filter</a>
<ul>
<li><a href="#principle-5">Principle</a></li>
<li><a href="#pseudo-code-5">Pseudo Code</a></li>
<li><a href="#implementation-5">Implementation</a></li>
</ul></li>
</ul></li>
<li><a href="#results">Results</a>
<ul>
<li><a href="#task-1-1">Task 1</a></li>
<li><a href="#task-2-1">Task 2</a></li>
<li><a href="#task-3-1">Task 3</a></li>
<li><a href="#task-4-1">Task 4</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>The spatial operations directly operate the pixels of an image, so they are usually efficient and low-resource-occupying. Besides, some spatial nonlinear filtering techniques, like the median filter discussed below, could achieve fantastic results in certain conditions (SAP) rather than other transform domain operations. Therefore, it is significant to learn and implement some classical image spatial operations.</p>
<p>Spatial operations are mainly divided into intensity transformations and spatial filtering. Intensity transformations usually operate with single pixels, such as gamma transform, which could generally be depicted by <span class="math inline">\(s=T[r]\)</span> (r is a 1 x 1 input pixel, s is the output pixel). Spatial filtering usually operates with the neighbor of pixels, such as linear box filtering.</p>
<p>The usage of spatial operations are extraordinarily wide, the image enhancement and denoising discussed in this lab are just one of them. Actually, some of the Neural Network and Deep Learning technologies also use spatial operations to extract image features.</p>
<p>The enhancement methods discussed in this report are listed below:</p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>Enhancement Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Basic intensity transformation (Gamma transform)</td>
<td>Gamma transform is the simplest method for implementation, and its result is pretty good after tuning the <span class="math inline">\(\gamma\)</span> factor</td>
</tr>
<tr class="even">
<td>Histogram equalization</td>
<td>It can automatically redistribute the gray scales according to histogram, spread out the centralized histogram bins. However, it can not generate new gray scales and would sometimes cause "wash-out"</td>
</tr>
<tr class="odd">
<td>Histogram matching (specification)</td>
<td>User need to design a probability distribution <span class="math inline">\(pdf(z_q)\)</span> as a desired histogram. This method could withstand the "wash-out" effect</td>
</tr>
<tr class="even">
<td>Local Histogram Equalization</td>
<td>It iterate histogram equalization in small neighbors, the enhancement effect in local details is better, but the time-cost increases as well</td>
</tr>
<tr class="odd">
<td>Histogram statistic filtering (mean and variance)</td>
<td>Need to put effort on tuning parameters, but it is more flexible to enhance certain areas or details. Prior knowledge might be essential</td>
</tr>
</tbody>
</table>
<p>The denoising (SAP) methods discussed in this report are also listed below:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Denoising Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Box filter (Linear filter)</td>
<td>Actually is calculating average in a neighbor. It could smooth some of the noise, but the edge blur are also apparent</td>
</tr>
<tr class="even">
<td>Median filter</td>
<td>Might be the best choice for SAP, because it would not cause edge blur effect. But for many other kinds of noise, it might not be a good choice</td>
</tr>
<tr class="odd">
<td>Gaussian low pass filter (Linear filter)</td>
<td>For gaussian noise it might be a good choice, but it also cause edge blur like box filter does (but less blur rather than box filter)</td>
</tr>
</tbody>
</table>
<h2 id="task-1">Task 1</h2>
<h3 id="histogram-equalization">Histogram Equalization</h3>
<h4 id="principle">Principle</h4>
<p><span class="math inline">\(s\)</span> is the processed pixel, <span class="math inline">\(r\)</span> is the input pixel and <span class="math inline">\(p_i(i)\)</span> is the corresponding PDF of gray scale. Note that this is the proof for continuous condition, discrete is similar, changing integral to sum, and the <span class="math inline">\(s=T(r)\)</span> step need to map <span class="math inline">\(s\)</span> to the nearest integer. <span class="math display">\[
\begin{aligned}
s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw \\
prove \ how \ &amp; it \ works: \\
  &amp; \left\{
\begin{aligned}
p_s(s) &amp; =p_r(r)|\frac{dr}{ds}| \\
s &amp; =T(r)=(L-1)\int^{r}_0p_r(w)dw
\end{aligned}
\right. \\
\\
\Rightarrow
\frac{ds}{dr} &amp; =\frac{dT(r)}{dr}=(L-1)\frac{d}{dr}[\int^r_0p_r(w)dw]=(L-1)p_r(r) \\
\Rightarrow p_s(s) &amp;=p_r(r)|\frac{dr}{ds}|=p_r(r)|\frac{1}{(L-1)p_r(r)}|=\frac{1}{L-1} \quad 0\leq s\leq L-1
\end{aligned}
\]</span></p>
<h4 id="pseudo-code">Pseudo Code</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist</span>(<span class="params">arr</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	return the histogram of a given array (ravel or unravel are both fine)</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	init histogram <span class="keyword">with</span> zeros</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> whole gray scale</span><br><span class="line">        calculate the number of pixels that <span class="string">&#x27;value = i&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> histogram</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_equ</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Remap the gray scale of arr according to CDF(r)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    input_hist = hist(arr) <span class="comment"># `hist` is defined above</span></span><br><span class="line">    calculate p(r) by normalizing -&gt; r_pdf</span><br><span class="line">    calculate integral[p(r)] by accumulate p(r) -&gt; r_cdf</span><br><span class="line">    init output <span class="keyword">with</span> zeros</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">256</span>:</span><br><span class="line">    	change pixels(arr) that <span class="string">&#x27;value = i&#x27;</span> into <span class="string">&#x27;value = r_cdf[i]&#x27;</span> -&gt; output</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<h4 id="implementation">Implementation</h4>
<p>Prove the correctness of my histogram method, I compare it with <code>np.histogram</code>, it turns out that they are the same. Note that I do not iterate the whole image with two <code>for</code> loops, because of two reason:</p>
<ol type="1">
<li><code>numpy</code> is written by high quality C in bottom, it is much more efficient than row python codes</li>
<li>the tricky <code>np.sum</code> method has bottom acceleration supported by <code>numpy</code>, so I iterate all the possible gray values rather than iterate the (H, W) axis with two <code>for</code> loops (Although iterate gray scales has higher time complexity than iterate the image with two <code>for</code>, it is actually faster)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="function"><span class="keyword">def</span> <span class="title">hist</span></span></span><br><span class="line"><span class="function"><span class="title">_hist</span> = <span class="title">np</span>.<span class="title">zeros</span>(<span class="params">_max - _min + <span class="number">1</span></span>)</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="title">v</span> <span class="title">in</span> <span class="title">range</span>(<span class="params">_min, _max + <span class="number">1</span></span>):</span></span><br><span class="line">    _hist[v] = np.<span class="built_in">sum</span>(arr == v)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471935845342.png" alt="output" style="zoom:60%;" /></p>
<p>Only use one <code>for</code> loop to implement this algorithm. Actually, the optimize methods for python is similar with <code>@matlab</code>, which is efficient with matrix operations. Therefore, the object of optimizing python code could be concluded as:</p>
<ol type="1">
<li>use less <code>for</code> loops</li>
<li>use more <code>numpy</code> methods and matrix operations</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="function"><span class="keyword">def</span> <span class="title">hist_equ</span></span></span><br><span class="line"><span class="function"><span class="title">input_hist</span> = <span class="title">hist</span>(<span class="params">arr.ravel(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function"><span class="title">r_pdf</span> = <span class="title">np</span>.<span class="title">array</span>(<span class="params">input_hist</span>) / <span class="title">np</span>.<span class="title">sum</span>(<span class="params">input_hist</span>)</span></span><br><span class="line"><span class="function"><span class="title">r_cdf</span> = <span class="title">np</span>.<span class="title">round</span>(<span class="params"><span class="number">255</span> * np.cumsum(<span class="params">r_pdf</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="title">output_image</span> = <span class="title">np</span>.<span class="title">zeros_like</span>(<span class="params">arr</span>)</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="title">idx</span> <span class="title">in</span> <span class="title">range</span>(<span class="params"><span class="number">256</span></span>):</span></span><br><span class="line">    output_image[arr == idx] = r_cdf[idx]</span><br><span class="line"><span class="keyword">return</span> output_image</span><br></pre></td></tr></table></figure>
<h2 id="task-2">Task 2</h2>
<h3 id="histogram-match">Histogram Match</h3>
<h4 id="principle-1">Principle</h4>
<p>First consider the continuous condition, we want to get a transform of <span class="math inline">\(z=\hat{T}[r]\)</span>, <span class="math inline">\(p(z)\)</span> is the desired histogram designed. We introduce a variable <span class="math inline">\(s\)</span> for transition, and we get <span class="math inline">\(z=G^{-1}[T(r)]\)</span>: <span class="math display">\[
\begin{aligned}
s&amp;=T(r)=(L-1)\int_0^rp_r(w)dw \\
G(z)&amp;=(L-1)\int^r_0p_z(t)dt=s \\
&amp;\Rightarrow
z=G^{-1}[T(r)]=G^{-1}(s)
\end{aligned}
\]</span> The discrete time condition is similar, we do not need to solve <span class="math inline">\(G^{-1}\)</span> any more, because we can get a integer mapping relationship (round) using <span class="math inline">\(s_k=G(z_q)\)</span>, if we want to know <span class="math inline">\(z_q\)</span>, just iterate the array of <span class="math inline">\(s_k\)</span>. Here is the proof: <span class="math display">\[
\begin{aligned}
s_k&amp;=T(r_k)=(L-1)\sum^k_{j=0}p_r(r_j)=\frac{L-1}{MN}\sum^k_{j=0}n_j \\
G(z_q)&amp;=(L-1)\sum^q_{i=0}p_z(z_i)=s_k \\
&amp;\Rightarrow
z_q=G^{-1}(s_k)=G^{-1}[T(r_k)]
\end{aligned}
\]</span></p>
<h4 id="pseudo-code-1">Pseudo Code</h4>
<p>First we need to design a <code>z_q</code>, and pass its histogram</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_match</span>(<span class="params">arr, spec_hist</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	Do histogram match according to given spec_hist</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	input_hist = hist(arr) <span class="comment"># `hist` is defined above</span></span><br><span class="line">	calculate CDF(s_k) <span class="keyword">as</span> we do <span class="keyword">in</span> histogram equalization -&gt; s_k</span><br><span class="line">	calculate CDF(z_q2s_k) <span class="keyword">from</span> the given histogram(spec_hist) -&gt; z_q2s_k</span><br><span class="line">	init output <span class="keyword">with</span> zeros</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">256</span>:</span><br><span class="line">    	find the indices that satisfy <span class="string">&#x27;s_k &lt;= z_q2s_k&#x27;</span> <span class="keyword">and</span> choose the smallest -&gt; idx</span><br><span class="line">    	change pixels(arr) that <span class="string">&#x27;value = i&#x27;</span> into idx -&gt; output</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<h4 id="implementation-1">Implementation</h4>
<p>I design two <span class="math inline">\(pdf(z_q)\)</span> here, the blue one is expected to be better for easing the "wash-out" effect.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471964888277.png" alt="output" style="zoom:65%;" /></p>
<p>Notice that I also only use one <code>for</code> loop, I use many <code>numpy</code> tricks to avoid using <code>for</code>. During the for loop, I cut some of the iteration values of all these variables, it works out correctly.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def hist_match</span></span><br><span class="line">input_hist = hist(arr.ravel())</span><br><span class="line">s_k = np.<span class="built_in">round</span>(<span class="number">255</span> / np.<span class="built_in">sum</span>(input_hist) * np.cumsum(input_hist))</span><br><span class="line">z_q2s_k = np.<span class="built_in">round</span>(<span class="number">255</span> * np.cumsum(spec_hist))</span><br><span class="line">output_image = np.zeros_like(arr)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):  <span class="comment"># r -&gt; s</span></span><br><span class="line">    idx = np.where(s_k[i] &lt;= z_q2s_k)[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># s -&gt; z</span></span><br><span class="line">    output_image[arr == i] = idx</span><br><span class="line"><span class="keyword">return</span> output_image</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rk: <span class="number">0</span> sk: <span class="number">147</span> zq2sk: <span class="number">145</span> zq: <span class="number">57</span></span><br><span class="line">rk: <span class="number">1</span> sk: <span class="number">155</span> zq2sk: <span class="number">155</span> zq: <span class="number">60</span></span><br><span class="line">rk: <span class="number">2</span> sk: <span class="number">163</span> zq2sk: <span class="number">163</span> zq: <span class="number">63</span></span><br><span class="line">rk: <span class="number">3</span> sk: <span class="number">166</span> zq2sk: <span class="number">166</span> zq: <span class="number">64</span></span><br><span class="line">rk: <span class="number">4</span> sk: <span class="number">171</span> zq2sk: <span class="number">171</span> zq: <span class="number">66</span></span><br><span class="line">rk: <span class="number">5</span> sk: <span class="number">175</span> zq2sk: <span class="number">173</span> zq: <span class="number">67</span></span><br><span class="line">rk: <span class="number">6</span> sk: <span class="number">180</span> zq2sk: <span class="number">178</span> zq: <span class="number">69</span></span><br><span class="line">rk: <span class="number">7</span> sk: <span class="number">184</span> zq2sk: <span class="number">183</span> zq: <span class="number">71</span></span><br><span class="line">rk: <span class="number">8</span> sk: <span class="number">186</span> zq2sk: <span class="number">185</span> zq: <span class="number">72</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="gamma-transform">Gamma Transform</h3>
<p>The principle could not be simpler. It is one of the most widely used intensity transformation method, actually it has a pretty good effect on enhancing Q3_2.tif and Q3_3.tif. The time it costs is also very low: <span class="math display">\[
s=cr^{\gamma}
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_transform</span>(<span class="params">arr, gamma</span>):</span></span><br><span class="line">    gamma_img = np.<span class="built_in">round</span>(np.power(arr / <span class="number">255.0</span>, gamma) * <span class="number">255</span>).astype(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">return</span> gamma_img</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output.png" alt="output" style="zoom:65%;" /></p>
<h3 id="local-statistic-enhancement">Local Statistic Enhancement</h3>
<p>The statistic property we are interested are mean and variance (secondary moment), here we can calculate the global mean <span class="math inline">\(m_G\)</span> and variance <span class="math inline">\(\sigma^2_G\)</span>, then get the standard variance <span class="math inline">\(\sigma_G\)</span>: <span class="math display">\[
\begin{aligned}
\mu_2(r)&amp; =\sigma^2=\sum^{L-1}_{i=0}(r_i-m)^2p(r_i) \\
m&amp; =\sum^{L-1}_{i=0}r_ip(r_i) \\
\end{aligned}
\]</span> During local enhancement, we calculate mean and variance of the neighbor, then use the last equation below to decide whether enhance the current pixel or not. <span class="math inline">\(E,k_0,k_1,k_2,k_3\)</span> are the parameters to design and tune. <span class="math display">\[
\begin{aligned}
m_{S_{xy}} &amp; =\sum^{L-1}_{i=0}r_ip_{S_{xy}}(r_i) \\
\sigma^2_{S_{xy}} &amp; =\sum^{L-1}_{i=0}(r_i-m_{S_{xy}})^2p_{S_{xy}}(r_i) \\
g(x,y) &amp; =\left\{
\begin{aligned}
&amp; E \cdot f(x,y), \quad k_0m_G\leq m_{S_{xy}} \leq k_1m_G , \ k_2\sigma_G
\leq \sigma_{S_{xy}} \leq k_3\sigma_G\\
&amp; f(x,y), \quad otherwise
\end{aligned}
\right.
\end{aligned}
\]</span> This method is <code>def local_statistic_adjust(arr, k0, k1, k2, k3, E, m_size=3)</code> in the code file submitted, I have not done many optimization, therefore this method runs more than 10 seconds for Q3_2.tif.</p>
<p>The result is not desirable, might because the parameter need to be tuned more carefully. However, this image is not suitable for using this method to enhance, because the details do not behave similarly. Another approach for utilizing histogram statistics should be designed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719917401210.png" alt="output" style="zoom:65%;" /></p>
<h2 id="task-3">Task 3</h2>
<h3 id="local-histogram-equalization">Local Histogram Equalization</h3>
<h4 id="principle-2">Principle</h4>
<p>There is no equations and proof for this algorithm. Actually, we does histogram equalization for every neighbors. However, this is a very expensive process, therefore I think of another tricky way to implement this algorithm. Like we discussed above, we should use <code>numpy</code> as much as possible and try to reduce operations under <code>for</code> loops. Therefore, I re-organize the neighbors into a <code>Big_Mat</code> and done operations parallelly. <span class="math display">\[
\begin{aligned}
A &amp;= \begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; ... &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; ... &amp; a_{2n} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; ... &amp; a_{3n} \\
... &amp; ... &amp; ... &amp; ... &amp; ... \\
a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; ... &amp; a_{mn} \\
\end{bmatrix} \quad
\\
Big_Mat &amp;= \begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{31} &amp; a_{32} &amp; a_{33} \\
a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{32} &amp; a_{33} &amp; a_{34}\\
 &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp; \\
 a_{(m-2)(n-2)} &amp; a_{(m-2)(n-1)} &amp; a_{(m-2)n} &amp; a_{(m-1)(n-2)} &amp; a_{(m-1)(n-1)} &amp; a_{(m-1)n} &amp; a_{m(n-2)} &amp; a_{m(n-1)} &amp; a_{mn}\\
\end{bmatrix} \\
\end{aligned}
\]</span> Another optimizing method is to maintain a global <span class="math inline">\(pdf\)</span>, then push and pop elements while iterating the neighbors, after judging by experience I think the first one could be more effective, so I just leave the proof here. <span class="math inline">\(n_{L_k}\)</span> is the deleted and <span class="math inline">\(n_{R_k}\)</span> is the new comer pixels: <span class="math display">\[
\begin{aligned}
p_r(r_k)&amp;=\frac{n_k}{n} \quad\quad k=0, 1, ..., K-1\\
\hat{p_r}(r_k)&amp;=\frac{1}{n}[n_k-n_{L_k}+n_{R_k}]=p_r(r_k)+\frac{1}{n}[n_{R_k}-n_{L_k}]
\end{aligned}
\]</span></p>
<h4 id="pseudo-code-2">Pseudo Code</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist</span>(<span class="params">arr, parallel</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the input is the (HW x m_size^2) Big_Mat, therefore in this method calculate histogram seperately for each row of Big_Mat. The return array is with size (HW, 256), and each row of it _hist[i] with size (1 , 256) is a single histogram for the (m_size x m_size) neighbor</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    init _hist <span class="keyword">as</span> zeros</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> whole gray scale</span><br><span class="line">        calculate the number of pixels that <span class="string">&#x27;value = i&#x27;</span> <span class="keyword">for</span> each row seperately</span><br><span class="line">    <span class="keyword">return</span> _hist</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2big_mat</span>(<span class="params">arr, m_size</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	change the image into the Big_Mat. For example, a (5 x 6) size gray image is the input `arr`. `m_size` is the scale of the neighborhood size, let it be 3. Therefore, the return Big_Mat would be (30 x 9), and each Big_Mat[i] correspond to a flatten neighborhood with 3 x 3 size.</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	_H <span class="keyword">is</span> arr height</span><br><span class="line">	_W <span class="keyword">is</span> arr width</span><br><span class="line">	<span class="keyword">assert</span> that _H, _W are large enough <span class="keyword">for</span> calculation</span><br><span class="line">	_half <span class="keyword">is</span> <span class="number">1</span>/<span class="number">2</span> of neighbor scale <span class="comment"># m_size is odd, _half is the smaller half</span></span><br><span class="line">	_l_half  = _half + <span class="number">1</span> <span class="comment"># _l_half is the larger half</span></span><br><span class="line">	pad the original image -&gt; _padded</span><br><span class="line">	init Big_Mat <span class="keyword">as</span> zeros -&gt; big_mat</span><br><span class="line">	use cnt to record the count of neighbors (axis[<span class="number">0</span>] of Big_Mat) -&gt; cnt = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i start <span class="keyword">from</span> _half to (_H + _half)</span><br><span class="line">		<span class="keyword">for</span> j start form _half to (_W + _half)</span><br><span class="line">			big_mat[cnt] <span class="keyword">is</span> the flattened No.cnt neighbor of _padded</span><br><span class="line">			cnt++</span><br><span class="line">	<span class="keyword">return</span> _padded, big_mat</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_equ</span>(<span class="params">arr, local=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This equalization method deal with a different input, arr is not a (H, W) image any more but a (HW x m_size^2) Big_Mat.Actually this method is the core for local histogram equalization, because many core operations are packed here</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">	get the total pixels number (H x W) -&gt; _parallel</span><br><span class="line">    get the total neighbor pixel number (m_size x m_size) -&gt; _m2</span><br><span class="line">    _half <span class="keyword">is</span> <span class="number">1</span>/<span class="number">2</span> of neighbor scale <span class="comment"># m_size is odd, _half is the smaller half</span></span><br><span class="line">    get hist(arr, _parallel) <span class="keyword">with</span> size of (_parallel x <span class="number">256</span>) -&gt; input_hist <span class="comment"># call from the `hist` method above, return histogram is with size (HW x 256)</span></span><br><span class="line">    calculate p(r) by normalizing <span class="keyword">for</span> each row of input_hist -&gt; r_pdf <span class="comment"># size is (HW, 256)</span></span><br><span class="line">    calculate integral[p(r)] by accumulate p(r) <span class="keyword">for</span> each row of r_pdf -&gt; r_cdf <span class="comment"># size is (HW, 256)</span></span><br><span class="line">    init output <span class="keyword">with</span> zeros <span class="comment"># output is (, HW), can be reshape to (H, W), and that is the result of all the local histrogram equalization process</span></span><br><span class="line">    find the center pixel values <span class="keyword">for</span> <span class="built_in">all</span> the neighborhoods -&gt; center_pixel <span class="comment"># this is because that we only care with the result of hisotgram equalization of the center pixel, therefore we have no need to calculate the other m_size^2 - 1 pixels </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (H x W): <span class="comment"># itherate all the neighborhoods</span></span><br><span class="line">    	find the histogram equalization result <span class="keyword">for</span> the center_pixel of the No.i neighborhood -&gt; r_cdf[i, center_pixel[i]]</span><br><span class="line">        then update this equalized value to output[i]</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local_hist_equ</span>(<span class="params">arr, m_size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Nearly all the local histogram equalization process are packed in above methods, here just call them to get the result!</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    call img2big_mat to get the Big_Mat -&gt; _big_mat</span><br><span class="line">    call hist_equ to get the result <span class="keyword">with</span> size (, HW) -&gt;  output_image</span><br><span class="line">    then reshape output_image to (H, W)</span><br><span class="line">    <span class="keyword">return</span> output_image</span><br></pre></td></tr></table></figure>
<h4 id="implementation-2">Implementation</h4>
<p>I have done this method with only one <code>for</code> loop as well, therefore the speed is very fast compare to the first version of my code (which has two <code>for</code> loop and runs much slower). Here is my first version code, it call the <code>hist_equ(arr)</code> implemented for only one neighborhood, not the efficient <code>hist_equ(arr, _parallel)</code> used above:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def local_hist_equ_deprecated</span></span><br><span class="line">local_equalized = np.zeros_like(img)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_half, _H, stride):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(s_half, _W, stride):</span><br><span class="line">        local_equalized[i - <span class="number">1</span>, j - <span class="number">1</span>] = hist_equ(padded_img[i - s_half:i + l_half, j - s_half:j + l_half])[s_half, s_half]</span><br></pre></td></tr></table></figure>
<p>The implementation codes could be found in supplementary files, I do not list them here. Then I would compare the efficiency of the two strategy. I do local histogram equalization for <code>m_size = 3, 5, 7</code> and plot their running time below:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722285939316.png" alt="output" style="zoom:65%;" /></p>
<h3 id="gamma-transform-1">Gamma Transform</h3>
<p>The gamma transform principle and codes are discussed above in <em>Task 1</em>, here I show the result of it. Surprisingly, the details could be enhanced perfectly as well. In my opinion, I believe that the other intensity transformation methods could enhance the details perfectly as well, like the <em>contrast stretching</em> method. Besides, these intensity transformation methods are usually simple and fast.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471925885981.png" alt="output" style="zoom:65%;" /></p>
<h3 id="local-statistic-enhancement-1">Local Statistic Enhancement</h3>
<p>The statistic distribution of Q3_3.tif is much simpler than Q3_2.tif, therefore using statistic method would complete the enhancement task, and the parameters I tuned for the effect shown below are: <code>k0 = 0.02, k1 = 0.5, k2 = 0, k3 = 0.5, E = 30</code>. However, the effect is not as good as gamma transform and local histogram equalization.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722229456914.png" alt="output" style="zoom:65%;" /></p>
<h2 id="task-4">Task 4</h2>
<h3 id="box-filter">Box Filter</h3>
<h4 id="principle-3">Principle</h4>
<p>Could also be named as <em>Mean Filter</em>, from a view of Frequency Domain, it is a kind of low pass filter. Therefore, some edge information are lost and cause blur effect. Below, <span class="math inline">\(n\)</span> is the kernel size: <span class="math display">\[
R=\frac{1}{n^2}\sum^{n^2}_{i=1}z_i \\
\]</span> For implementing all the filtering methods, I use the <code>Big_Mat</code> strategy discussed in task 3, here proves that this strategy is useful for all kinds of spatial operations associated with kernels (neighborhoods). It is actually a code design optimization method for changing image convolution (correlation) into matrix multiplication, which has many acceleration methods for different languages: <span class="math display">\[
\begin{aligned}
&amp;Image \ A ,\ \ Kernel \ K \\
A &amp;= \begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; ... &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; a_{23} &amp; ... &amp; a_{2n} \\
a_{31} &amp; a_{32} &amp; a_{33} &amp; ... &amp; a_{3n} \\
... &amp; ... &amp; ... &amp; ... &amp; ... \\
a_{m1} &amp; a_{m2} &amp; a_{m3} &amp; ... &amp; a_{mn} \\
\end{bmatrix} \quad
K = \begin{bmatrix}
k_1 &amp; k_2 &amp; k_3 \\ 
k_4 &amp; k_5 &amp; k_6 \\ 
k_7 &amp; k_8 &amp; k_9 \\ 
\end{bmatrix} \\
\\
Mat &amp;= \begin{bmatrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{31} &amp; a_{32} &amp; a_{33} \\
a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{32} &amp; a_{33} &amp; a_{34}\\
 &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp;  &amp; ... &amp; \\
 a_{(m-2)(n-2)} &amp; a_{(m-2)(n-1)} &amp; a_{(m-2)n} &amp; a_{(m-1)(n-2)} &amp; a_{(m-1)(n-1)} &amp; a_{(m-1)n} &amp; a_{m(n-2)} &amp; a_{m(n-1)} &amp; a_{mn}\\
\end{bmatrix} \\
\\
\hat{k} &amp;= \begin{bmatrix}
k_1 &amp; k_2 &amp; k_3 &amp; k_4 &amp; k_5 &amp; k_6 &amp; k_7 &amp; k_8 &amp; k_9\end{bmatrix}^{T} \\
&amp; Conv2d(A,K) = (Mat \cdot \hat{k}).Reshape(H, W) \\
\end{aligned}
\]</span> Another reason for using this <em>Big Mat</em> strategy is that python has a smart memory allocating bottom logic, therefore, the <code>big_mat</code> created has a well-designed memory distribution in bottom, without <strong>hard copy</strong> (by <code>np.copy</code>) of anything.</p>
<h4 id="pseudo-code-3">Pseudo Code</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_filter</span>(<span class="params">arr, box_size</span>):</span></span><br><span class="line">    generate the box filtering kernel <span class="keyword">from</span> given box_size</span><br><span class="line">    _H, _W are the shapes of <span class="built_in">input</span> image</span><br><span class="line">	_half <span class="keyword">is</span> <span class="number">1</span>/<span class="number">2</span> of neighbor scale <span class="comment"># m_size is odd, _half is the smaller half</span></span><br><span class="line">	_l_half  = _half + <span class="number">1</span> <span class="comment"># _l_half is the larger half</span></span><br><span class="line">    get the Big Mat by calling img2big_mat(arr) -&gt; arr_big</span><br><span class="line">    <span class="keyword">return</span> arr_big @ kernel <span class="comment"># &#x27;@&#x27; of course is matrix multiplication</span></span><br></pre></td></tr></table></figure>
<h4 id="implementation-3">Implementation</h4>
<p>The implementation use the <code>img2big_mat</code> method discussed in Task 3, and <code>linear_filtered</code> is calculated by matrix multiplication, thus it runs very fast (without using any <code>for</code> loop)!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_filter</span>(<span class="params">arr, box_size=<span class="number">0</span>, kernel=<span class="literal">None</span>, pad_mode=<span class="string">&#x27;constant&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> box_size != <span class="number">0</span>:</span><br><span class="line">        kernel = <span class="number">1</span> / (box_size ** <span class="number">2</span>) * np.ones((box_size, box_size))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> kernel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    _H = arr.shape[<span class="number">0</span>]</span><br><span class="line">    _W = arr.shape[<span class="number">1</span>]</span><br><span class="line">    _kernel_size = kernel.shape[<span class="number">0</span>]</span><br><span class="line">    _half = _kernel_size // <span class="number">2</span></span><br><span class="line">    _l_half = _half + <span class="number">1</span></span><br><span class="line">    _, arr_big = img2big_mat(arr, _kernel_size, pad_mode=pad_mode)</span><br><span class="line">    linear_filtered = (arr_big @ kernel.ravel()).reshape(_H, _W)</span><br><span class="line">    <span class="keyword">return</span> linear_filtered</span><br></pre></td></tr></table></figure>
<h3 id="median-filter">Median Filter</h3>
<h4 id="principle-4">Principle</h4>
<p>This is a kind of nonlinear spatial filter, it chooses the statistic median value of a neighborhood as its center pixel value. The principle is simple so I do not put redundant equations here.</p>
<h4 id="pseudo-code-4">Pseudo Code</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_filter</span>(<span class="params">arr, n_size</span>):</span></span><br><span class="line">    _H, _W are the shapes of <span class="built_in">input</span> image</span><br><span class="line">	_half <span class="keyword">is</span> <span class="number">1</span>/<span class="number">2</span> of neighbor scale <span class="comment"># m_size is odd, _half is the smaller half</span></span><br><span class="line">	_l_half  = _half + <span class="number">1</span> <span class="comment"># _l_half is the larger half</span></span><br><span class="line">    pad the original image -&gt; _padded</span><br><span class="line">    init order_filtered <span class="keyword">with</span> zeros</span><br><span class="line">    <span class="keyword">for</span> i start <span class="keyword">from</span> _half to (_H + _half)</span><br><span class="line">		<span class="keyword">for</span> j start form _half to (_W + _half)</span><br><span class="line">			find median of the correspond neighborhood -&gt; order_filtered[i-<span class="number">1</span>, j-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> order_filtered</span><br></pre></td></tr></table></figure>
<h4 id="implementation-4">Implementation</h4>
<p>Because this is a nonlinear operation, so I could not use <em>Big Mat</em> here for optimizing. As known, matrix multiplication is a linear math tool. However, I use <code>np.median</code> instead, and the speed turns out to be fast enough, even though I iterate using two <code>for</code> loops.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order_filter</span>(<span class="params">arr, n_size, pad_mode=<span class="string">&#x27;constant&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> n_size % <span class="number">2</span> == <span class="number">1</span>  <span class="comment"># only handel odd kernel</span></span><br><span class="line">    _H = arr.shape[<span class="number">0</span>]</span><br><span class="line">    _W = arr.shape[<span class="number">1</span>]</span><br><span class="line">    _half = n_size // <span class="number">2</span></span><br><span class="line">    _l_half = _half + <span class="number">1</span></span><br><span class="line">    padded = np.pad(arr, (_half, _half), mode=pad_mode)</span><br><span class="line">    order_filtered = np.zeros_like(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(_half, _H):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_half, _W):</span><br><span class="line">            order_filtered[i - <span class="number">1</span>, j - <span class="number">1</span>] = np.median(padded[i - _half:i + _l_half, j - _half:j + _l_half])</span><br><span class="line">    <span class="keyword">return</span> order_filtered</span><br></pre></td></tr></table></figure>
<h3 id="gaussian-filter">Gaussian Filter</h3>
<h4 id="principle-5">Principle</h4>
<p>Actually, this is a weighted <em>Mean Filter</em>, and the weights are decided by gaussian distribution. The gaussian kernel could be designed by giving <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(K\)</span>, the standard deviation. Here is the proof: <span class="math display">\[
w(s,t)=G(s,t)=Ke^{-\frac{s^2+t^2}{2\sigma^2}}=Ke^{-\frac{r^2}{2\sigma^2}}
\]</span> <img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/image-20220314102642943.png" alt="image-20220314102642943" style="zoom:67%;" /></p>
<p>According to the <span class="math inline">\(3\sigma\)</span> principle, the size of a gaussian kernel should be <span class="math inline">\([6\sigma,6\sigma]\)</span>, and it should ceil to the nearest odd integer. For example, <span class="math inline">\(\sigma=1\)</span> would lead to a <span class="math inline">\([7,7]\)</span> kernel. Another important step for designing gaussian kernel is to get the Distance Matrix shown above.</p>
<h4 id="pseudo-code-5">Pseudo Code</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span>(<span class="params">arr, sigma, K</span>):</span></span><br><span class="line">    calculate kernel size <span class="keyword">from</span> sigma -&gt; _kernel_size</span><br><span class="line">    get _H, _W <span class="keyword">from</span> the shapes of arr -&gt; _H, _W</span><br><span class="line">    design the Distance Matrix R</span><br><span class="line">    genereate gaussian kernel <span class="keyword">from</span> the equation given <span class="keyword">in</span> proof -&gt; kernel</span><br><span class="line">    do linear filtering just like box_filter does -&gt; gaussian_filtered</span><br><span class="line">    <span class="keyword">return</span> gaussian_filtered</span><br></pre></td></tr></table></figure>
<h4 id="implementation-5">Implementation</h4>
<p>I haven't think a better way to get the distance matrix <code>R</code>, so as seen I use many <code>flip</code> methods to design it, they might be redundant and complex. However, the time cost is very low, because I do not use <code>for</code> loop for the filtering process. The core optimizing approach is as the above algorithms.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span>(<span class="params">arr, sigma, K, pad_mode=<span class="string">&#x27;constant&#x27;</span></span>):</span></span><br><span class="line">    _kernel_size = np.ceil(<span class="number">6</span> * sigma).astype(<span class="built_in">int</span>)</span><br><span class="line">    _H = arr.shape[<span class="number">0</span>]</span><br><span class="line">    _W = arr.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> _kernel_size % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        _kernel_size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the distance matrix</span></span><br><span class="line">    R_gen_size = (_kernel_size - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    R_gen_row = np.arange(<span class="number">1</span>, R_gen_size + <span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    R_gen = np.zeros((R_gen_size, R_gen_size))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, R_gen_size + <span class="number">1</span>):</span><br><span class="line">        R_gen[i - <span class="number">1</span>] = R_gen_row + R_gen_row[i - <span class="number">1</span>]</span><br><span class="line">    R_right = np.vstack((np.flipud(R_gen), R_gen_row, R_gen))</span><br><span class="line">    R_mid = np.r_[np.flip(R_gen_row), [<span class="number">0</span>], R_gen_row]</span><br><span class="line">    R_left = np.fliplr(R_right)</span><br><span class="line">    R = np.hstack((R_left, R_mid.reshape(_kernel_size, <span class="number">1</span>), R_right))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># generate coefficient w</span></span><br><span class="line">    G = K * np.exp(-R / (<span class="number">2</span> * sigma ** <span class="number">2</span>))</span><br><span class="line">    kernel = <span class="number">1</span> / np.<span class="built_in">sum</span>(G) * G</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> _kernel_size % <span class="number">2</span> == <span class="number">1</span>  <span class="comment"># only handel odd kernel</span></span><br><span class="line">    gaussian_filtered = linear_filter(arr, kernel=kernel, pad_mode=pad_mode)</span><br><span class="line">    <span class="keyword">return</span> gaussian_filtered</span><br></pre></td></tr></table></figure>
<h2 id="results">Results</h2>
<p>Tasks for this lab are listed below:</p>
<ol type="1">
<li>Implement the <strong>histogram equalization</strong> to the input images Q3_1_1.tif and Q3_1_2.tif</li>
<li>Specify a histogram for image Q3_2.tif and implement the <strong>specified histogram matching</strong> to the input image Q3_2.tif</li>
<li>Implement the <strong>local histogram equalization</strong> to the input images Q3_3.tif</li>
<li>Implement an algorithm to <strong>reduce the salt and pepper noise</strong> of an image</li>
</ol>
<h3 id="task-1-1">Task 1</h3>
<p>This is the result for Q3_1_1, the time used for my histogram equalization method is <code>0.22960257530212402</code> seconds. The result is the same as <code>opencv</code>, and the histogram are distributed as we expected. <strong>A very interesting phenomenon is that the gray scale with the most pixels would become sparse after redistribution, and on the contrary, the gray scale with only a few pixels tend to be dense after equalization</strong>. The explanation is simple and reasonable: the remapping process refers to <span class="math inline">\(cdf(r)\)</span> which of course would jump when the gray scale occupies a large amount of pixels (just name them <em>dominant gray scales</em>). These <em>dominant gray scales</em> need to be distributed far from each other to make the image have larger contrast, and they actually do.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471951140013.png" alt="output" style="zoom:65%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471951396674.png" alt="output" style="zoom:65%;" /></p>
<p>This is the result for Q3_1_2, the time used for my histogram equalization method is <code>0.23404693603515625</code> seconds. The histogram is also as expected.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471957811395.png" alt="output" style="zoom:65%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-16471957969016.png" alt="output" style="zoom:65%;" /></p>
<h3 id="task-2-1">Task 2</h3>
<p>The two designed <span class="math inline">\(pdf(z_q)\)</span> are plotted above, we could see that the first one is better as we expected. The following figures proved that using histogram matching could decrease the "wash-out" effect of histogram equalization. The time costed for <span class="math inline">\(z_{q1}\)</span> and <span class="math inline">\(z_{q2}\)</span> are <code>0.6347625255584717</code> and <code>0.62331223487854</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719941724311.png" alt="output" style="zoom:72%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719957060612.png" alt="output" style="zoom:65%;" /></p>
<p>However, it dramatically turns out that gamma transform might be the best solution for this enhancement task. As seen in the following, I just casually give a factor <span class="math inline">\(\gamma=0.35\)</span> and the details hidden in the right corner appear, and there is not any "wash-out" effect. By the way, the time cost of gamma transform is only <code>0.032987356185913086</code>. The result of local statistic is not good, its running times is <code>19.913657426834106</code> (no optimize, so there are 2 <code>for</code> loops).</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164719971968113.png" alt="output" style="zoom:65%;" /></p>
<h3 id="task-3-1">Task 3</h3>
<p>If I just use the global histogram equalization method, the result is poor, and cannot extract the details hidden in the black blocks. Ironically, the SAP noise is enhanced as well apparently.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/image-20220314034344199.png" alt="image-20220314034344199" style="zoom:67%;" /></p>
<p>Here is all the results I get for Q3_3.tif. We could see that when using local equalization: when the <code>m_size</code> is increased from 3 to 7, the details (and noise) become much more clearer and we get better result. This could be explained: when <code>m_size</code> increases, it means that we use a larger neighborhood for deciding the value of center pixels, that is, more information are used. However, the trade-off is that the time cost increases, from <code>4.724057197570801</code> to <code>9.002043008804321</code> for <code>m_size = 3, 7</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722309058217.png" alt="output" style="zoom:65%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722312382318.png" alt="output" style="zoom:65%;" /></p>
<h3 id="task-4-1">Task 4</h3>
<p>All the results are plotted here. The running time of order filter is a little higher because it uses two <code>for</code> loops to iterate the image height and width, and time for <code>n_size = 3, 7</code> are <code>3.73285174369812</code> and <code>3.608351707458496</code> seconds. The box filter method time cost are <code>0.29807138442993164</code> and <code>0.4164392948150635</code>, for <code>n_size = 3, 7</code> as well. The corresponding time costs for gaussian filter are <code>0.4878067970275879</code> and <code>0.813880443572998</code>, which are higher than box filter, because it generally has larger kernel size.</p>
<p>The order filter (Median Filter) has the best denoising result. This is as our expectation, because it is suitable to deal with SAP noise. The other linear filtering methods all cause different level of blur effect. Besides, if I use <em>Zero Padding</em> for kernels that are large, it would cause black margins like the figure below using <span class="math inline">\(\sigma=3.5\)</span> for gaussian filter. Using the <em>Reflected</em> padding strategy would avoid this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/output-164722624560219.png" alt="output" style="zoom:65%;" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion for the <em>Enhancement</em> tasks:</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>Methods</th>
<th>Conclusion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intensity Transformation (like gamma transform)</td>
<td>The principle of these kinds of methods are really simple, and all we need to do is to design <span class="math inline">\(s=T(r)\)</span> for single pixels. It turns out that gamma transform performs very well for the task 2 &amp;3. Another advantage of Intensity transformation methods is that they could run fast.</td>
</tr>
<tr class="even">
<td>Global Histogram Methods</td>
<td>Its core concept is to remap the different gray scales to larger distance with each other. The biggest advantage of Histogram equalization is that it works automatically. However, "wash-out" might occurs if most of the pixels are at the very dark gray scales, using a specification method with a designed histogram could relieve this effect.</td>
</tr>
<tr class="odd">
<td>Local Histogram Methods</td>
<td>Local histogram equalization could extract details hidden in an image magically, but it is usually very time-consuming. Besides, all of the histogram methods might inflate the noise somehow, they could not differ noise from details. The histogram statistic methods are very flexible, I only implement one usage of it, but this always associate with heavy tuning works.</td>
</tr>
</tbody>
</table>
<p>In conclusion for the <em>Filtering</em> task:</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>Methods</th>
<th>Conclusion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Linear Filtering</td>
<td>Linear filtering methods like box filter and weighted mean filters (gaussian filter) could weaken the SAP noise, but they also cause edge blur. This is because of their low-pass property. In my opinion, they might show their ability deal with some kinds of continuous noise, like gaussian noise.</td>
</tr>
<tr class="even">
<td>Nonlinear Filtering (Median Filter)</td>
<td>The advantage of Median Filter for dealing with SAP noise shows the advantage of spatial filtering than frequency filtering. Using the statistic property of neighborhood, like median, might avoid filtering the edge information and cause blur.</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://judera9.github.io">Jude</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://judera9.github.io/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/">https://judera9.github.io/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://judera9.github.io" target="_blank">Jude's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DIP/">DIP</a><a class="post-meta__tags" href="/tags/%E6%BB%A4%E6%B3%A2/">滤波</a><a class="post-meta__tags" href="/tags/NumPy/">NumPy</a><a class="post-meta__tags" href="/tags/Histogram/">Histogram</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/27/2022-3-27-CondaHTTPError-Solution/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CondaHTTPError解决方法</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/16/2022-3-16-Connection-refused-error-for-proxy/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解决proxy导致的Connection refused</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/27/2022-3-27-Intensity-Transform-and-Spatial-Filtering/" title="灰度变换与空间滤波"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">灰度变换与空间滤波</div></div></a></div><div><a href="/2022/06/12/2022-06-12-Frequency-Domain-Filtering/" title="频率域滤波"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">频率域滤波</div></div></a></div><div><a href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-13</div><div class="title">光流估计目标追踪-简单的KLT Feature Tracker</div></div></a></div><div><a href="/2022/03/04/2022-3-4-Image-Interpolation/" title="Image Interpolation"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-04</div><div class="title">Image Interpolation</div></div></a></div><div><a href="/2022/06/12/2022-06-12-Lena-the-CV-girl/" title="CV和DIP处理常见的那个女孩到底是谁"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">CV和DIP处理常见的那个女孩到底是谁</div></div></a></div><div><a href="/2022/06/12/2022-06-12-FFT-description-and-code/" title="一维快速傅里叶变换"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">一维快速傅里叶变换</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jude</div><div class="author-info__description">Record anything interesting!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#spatial-transforms-and-filtering"><span class="toc-number">1.</span> <span class="toc-text">Spatial Transforms and Filtering</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task-1"><span class="toc-number">1.2.</span> <span class="toc-text">Task 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#histogram-equalization"><span class="toc-number">1.2.1.</span> <span class="toc-text">Histogram Equalization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task-2"><span class="toc-number">1.3.</span> <span class="toc-text">Task 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#histogram-match"><span class="toc-number">1.3.1.</span> <span class="toc-text">Histogram Match</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle-1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-1"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gamma-transform"><span class="toc-number">1.3.2.</span> <span class="toc-text">Gamma Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#local-statistic-enhancement"><span class="toc-number">1.3.3.</span> <span class="toc-text">Local Statistic Enhancement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task-3"><span class="toc-number">1.4.</span> <span class="toc-text">Task 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#local-histogram-equalization"><span class="toc-number">1.4.1.</span> <span class="toc-text">Local Histogram Equalization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle-2"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-2"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-2"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gamma-transform-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">Gamma Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#local-statistic-enhancement-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">Local Statistic Enhancement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task-4"><span class="toc-number">1.5.</span> <span class="toc-text">Task 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#box-filter"><span class="toc-number">1.5.1.</span> <span class="toc-text">Box Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle-3"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-3"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-3"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#median-filter"><span class="toc-number">1.5.2.</span> <span class="toc-text">Median Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle-4"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-4"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-4"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gaussian-filter"><span class="toc-number">1.5.3.</span> <span class="toc-text">Gaussian Filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#principle-5"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-5"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Pseudo Code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#implementation-5"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Implementation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#results"><span class="toc-number">1.6.</span> <span class="toc-text">Results</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#task-1-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">Task 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-2-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">Task 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-3-1"><span class="toc-number">1.6.3.</span> <span class="toc-text">Task 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-4-1"><span class="toc-number">1.6.4.</span> <span class="toc-text">Task 4</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conclusion"><span class="toc-number">1.7.</span> <span class="toc-text">Conclusion</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/Review-of-fourier-transform/" title="Review of fourier transform"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Review of fourier transform"/></a><div class="content"><a class="title" href="/2022/07/21/Review-of-fourier-transform/" title="Review of fourier transform">Review of fourier transform</a><time datetime="2022-07-21T14:28:37.000Z" title="发表于 2022-07-21 22:28:37">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/20/Introduction-to-Hexo-pdf-and-music-plugins/" title="Introduction to Hexo pdf and music plugins"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Hexo pdf and music plugins"/></a><div class="content"><a class="title" href="/2022/07/20/Introduction-to-Hexo-pdf-and-music-plugins/" title="Introduction to Hexo pdf and music plugins">Introduction to Hexo pdf and music plugins</a><time datetime="2022-07-19T17:04:21.000Z" title="发表于 2022-07-20 01:04:21">2022-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/20/2022-07-20-Introduction-to-chrono/" title="Introduction to chrono"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to chrono"/></a><div class="content"><a class="title" href="/2022/07/20/2022-07-20-Introduction-to-chrono/" title="Introduction to chrono">Introduction to chrono</a><time datetime="2022-07-19T16:30:08.000Z" title="发表于 2022-07-20 00:30:08">2022-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/19/2022-07-19-The-usage-of-round-in-design/" title="The usage of round in design"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The usage of round in design"/></a><div class="content"><a class="title" href="/2022/07/19/2022-07-19-The-usage-of-round-in-design/" title="The usage of round in design">The usage of round in design</a><time datetime="2022-07-19T15:49:21.000Z" title="发表于 2022-07-19 23:49:21">2022-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="光流估计目标追踪-简单的KLT Feature Tracker"/></a><div class="content"><a class="title" href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker">光流估计目标追踪-简单的KLT Feature Tracker</a><time datetime="2022-06-13T15:36:22.000Z" title="发表于 2022-06-13 23:36:22">2022-06-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jude</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
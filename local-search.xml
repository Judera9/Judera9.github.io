<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>和弦基础</title>
    <link href="/2022/02/12/Music-Chord/"/>
    <url>/2022/02/12/Music-Chord/</url>
    
    <content type="html"><![CDATA[<h2 id="和弦标记">和弦标记</h2><p>  每种和弦都会有多种表示方法，最常用的总结如下：</p><table><thead><tr class="header"><th style="text-align: center;">三和弦</th><th style="text-align: center;">符号</th><th style="text-align: center;">七和弦</th><th style="text-align: center;">符号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">大三和弦</td><td style="text-align: center;">C</td><td style="text-align: center;">大七和弦</td><td style="text-align: center;">CM7</td></tr><tr class="even"><td style="text-align: center;">小三和弦</td><td style="text-align: center;">Cm</td><td style="text-align: center;">小七和弦</td><td style="text-align: center;">Cm7</td></tr><tr class="odd"><td style="text-align: center;">挂四和弦</td><td style="text-align: center;">Csus</td><td style="text-align: center;">属七和弦</td><td style="text-align: center;">C7</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">半减七和弦</td><td style="text-align: center;">C∅7</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">减七和弦</td><td style="text-align: center;">Co7</td></tr></tbody></table><h3 id="大和弦-major">大和弦 Major</h3><ul><li><strong>三和弦</strong>：例如，CEG（大三+小三=大三和弦），可以记为<strong>Cmaj、CM、CΔ、C</strong>；</li><li><strong>七和弦</strong>：例如，CEGB（大三和弦+大三=大七和弦），可以记为<strong>Cmaj7、CM7、CΔ7</strong>（不是C7）；</li></ul><h3 id="小和弦-minor">小和弦 Minor</h3><ul><li><strong>三和弦</strong>：例如，ACE（小三+大三=小三和弦），可以记为<strong>Amin、Am、A-</strong>；</li><li><strong>七和弦</strong>：例如，ACEG（小三和弦+小三=小七和弦），可以记为<strong>Amin7、Am7、A-7</strong>；</li></ul><h3 id="减和弦-diminish">减和弦 Diminish</h3><ul><li><strong>三和弦</strong>：例如，BDF（小三+小三=减三和弦），可以记为<strong>Bdim、Bo</strong>；</li><li><strong>七和弦</strong>：例如，BDF♭A（减三和弦+小三=减七和弦），可以记为<strong>Bdim7、Bo7</strong>；</li></ul><h3 id="增三和弦-augmented">增三和弦 Augmented</h3><ul><li><strong>三和弦</strong>：这个和弦用的少，例如，CE♯G（大三+大三=增三和弦），可以记为<strong>Caug</strong>；</li></ul><h3 id="属七和弦-dominant-7th">属七和弦 Dominant 7th</h3><ul><li><strong>七和弦</strong>：例如，CEG♭B（大三和弦+小三=属七和弦），可以记为<strong>C7</strong>；</li><li>    例如，GBDF（大三和弦+小三=属七和弦），可以记为<strong>G7</strong>；</li></ul><h3 id="半减七和弦-half-diminished-7th">半减七和弦 Half Diminished7th</h3><ul><li><strong>七和弦</strong>：例如，BDFA（减三和弦+大三=半减七和弦），可以记为<strong>Bm7b5、Bm7-5、B∅7</strong>（如果我没理解错的话，Bm7b5的含义是在B小七和弦的基础上将♭G，即七和弦的5音降低，其他半减七可写为Xm-5）；</li></ul><h3 id="sus和弦挂">SUS和弦（挂）</h3><ul><li><strong>三和弦</strong>：以大三和弦C（即CEG）为例，它的<strong>挂二和弦Csus2就是CDG，即将3音变成2音</strong>，它的<strong>挂四和弦Csus4就是CFG，即将3音变成4音</strong>，如果<strong>Xsus后面没有任何数字，默认为挂四和弦</strong>；</li></ul><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213000058.png" width="650"><center>图 1</center></center><h2 id="和弦功能">和弦功能</h2><ul><li><strong>主和弦</strong>：音乐开始或者结束，给人稳定的感觉（家）。不能整首曲子都是主和弦，这样会给人一种单调乏味的感觉；</li><li><strong>属和弦</strong>：一种听起来不稳定的和弦（在外面，想要回家），<strong>在和声学里，从不稳定到稳定的过程叫“解决”</strong>；</li><li><strong>下属和弦</strong>：相对属和弦比较轻松，但是除了主和弦的其他和弦都有不稳定的感觉（也在外面，但没有急着回家）。整体来说，乐曲的发展是<strong>主和弦&gt; 下属和弦 &gt; 属和弦 &gt;主和弦</strong>这样的顺序，也可以如图2其他顺序（但是不能从属和弦到下属和弦）：</li></ul><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213104608.png" width="500"><center>图 2</center></center><h2 id="大调leading-bass">大调Leading Bass</h2><p>  首先要知道，很多的流行歌曲并不是用心编配和弦写出来的，而是有固定的套路的，例如这个LeadingBass就是一种固定的套路。不同的曲子可能以一个或两个和弦为一小节去编排，但最后转个调都能够用这一套和弦去伴奏。</p><p>  <strong>LeadingBase（顺阶和弦）是一组和声进行，之所以叫这个名字是因为它的低音是顺着音阶下行的（CBAGFEDG）</strong>。C大调的和弦记号如下：C- G/B - Am - C/G - F - C/E - Dm - G7。大约30%的流行歌曲用的是LeadingBase的和声进行，可以看看下面这个视频：</p>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=14452311&bvid=BV14x411s7KZ&cid=335407887&page=28" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p><strong>II-V-I进行</strong>：在流行乐中，例如大调LeadingBase的结尾，就是II-V-I进行（即对于C大调来说是DGC）。这种进行是非常重要的，并且用的非常多。继续观察，<strong>II-V-I其实就是“小七-属七-主”这样的和弦进行方式，这也是旋律小调为什么降低VI音和VII音的原因</strong>。</p><h2 id="大调四度圈">大调四度圈</h2><p>  大约30%的华语流行歌曲就是用四度圈写出来的，四度圈在C大调上的记号如下：F- G/F - Em - Am - Dm - G7 - C -C7。大七和弦具有让乐曲开始和结束的功能，因此对于大调来说，音乐开始的第一个和弦要么是第I级，要么是第IV级，如图3：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213124411.png" width="550"><center>图 3</center></center>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=14452311&bvid=BV14x411s7KZ&cid=335408040&page=29" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><h2 id="小调leading-base和小调四度圈">小调Leading Base和小调四度圈</h2><p>  小调的这两种和声在流行乐中用的较少，在华语流行歌曲中也就大概5%左右。回忆之前学的大调，结尾是II-V-I进行（“小七-属七-主”）。<strong>注意到在小调LeadingBase中，以A小调ABCDEFGA为例，其II-V-I和弦进行对应的是“半减七（BDFG）-小七（EGBD）-小七（ACEG）”，所以需要将六音和七音（F和G）进行升音，得到“小七（BD♯FG）-属七（E♯GBD）-小大七（ACE♯G</strong>）**</p><blockquote><p>不知道是我算错了还是不理解，这个小大七和弦（小三和弦+大三）听起来也不像个稳定的和弦，为啥能够作为主和弦。目前这个地方不太明白，虽然小调LeadingBase用的不多，但希望以后能搞懂。</p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220213181143.png" width="600"><center>图 4</center></center><p>-未完待续-</p>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
      <tag>乐理</tag>
      
      <tag>和弦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Iterator 迭代器学习</title>
    <link href="/2022/02/12/Cpp-Iterator/"/>
    <url>/2022/02/12/Cpp-Iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="stl六大组件">STL六大组件</h2><p>因为于老师没讲STL，所以补一下课。STL的六大部件是下面这些：容器（Container）、算法（Algorithm）、迭代器（Iterator）、仿函数（Functionobject）、适配器（Adaptor）、空间配置器（allocator）。其他的以后碰到了再说，现在先学一下Iterator并简单做下实验。</p><h2 id="section"></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>介绍树莓派Pico | MicroPython插件</title>
    <link href="/2022/02/12/Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/"/>
    <url>/2022/02/12/Introduction-to-Pico-MicroPython-Plugin-Of-Pycharm/</url>
    
    <content type="html"><![CDATA[<h2 id="raspberry-pico">Raspberry Pico</h2><p>推荐网页：<a href="https://pico.org.cn/">树莓派 Pico 中文站</a></p><blockquote><p>上面的站点提供了树莓派 Pico 开发板的说明文档，以及完备的 RP2040芯片资料，本文也有参考上面的内容。</p></blockquote><h3 id="pico-规格参数">Pico 规格参数</h3><p>  这里涉及了很多嵌入式方面的知识，这一块我学的不是很好，有一些看得不是很明白的以后用到再来学吧。看了看相关的评测<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup>，ESP32不仅比Pico便宜而且外设还丰富的多，而且也支持MicroPython。不过我自己也只是买着玩玩，不用在意这些，个人感觉主要树莓派学习门槛更低吧。</p><ul><li>双核 Arm Cortex-M0 + @ 133MHz</li><li>芯片内置 264KB SRAM 和 2MB 的板载闪存</li><li>通过专用 QSPI 总线支持最高 16MB 的片外闪存</li><li>DMA 控制器</li><li>30 个 GPIO 引脚，其中 4 个可用作模拟输入</li><li>2 个 UART、2 个 SPI 控制器和 2 个 I2C 控制器</li><li>16 个 PWM 通道</li><li>USB 1.1 主机和设备支持</li><li>8 个树莓派可编程 I/O（PIO）状态机，用于自定义外围设备支持</li><li>支持 UF2 的 USB 大容量存储启动模式，用于拖放式编程</li></ul><blockquote><p><strong>SRAM是什么</strong>：SRAM (static RAM) is random accessmemory (RAM) that retains data bits in its memory as long as power isbeing supplied. Unlike dynamic RAM (DRAM), which stores bits in cellsconsisting of a capacitor and a transistor, SRAM does not have to beperiodically refreshed. Static RAM provides faster access to data and ismore expensive than DRAM. SRAM is used for a computer's cache memory andas part of the random access memory digital-to-analog converter on avideocard.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://whatis.techtarget.com/definition/SRAM-static-random-access-memory">[1]</span></a></sup></p></blockquote><blockquote><p><strong>QSPI是什么</strong>：QSPI是QueuedSPI的简写，是Motorola公司推出的SPI接口的扩展，比SPI应用更加广泛。在SPI协议的基础上，Motorola公司对其功能进行了增强，增加了队列传输机制，推出了队列串行外围接口协议（即QSPI协议）。片外闪存顾名思义就是外接的Flash存储空间。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.cnblogs.com/firege/p/9435349.html">[2]</span></a></sup></p></blockquote><blockquote><p><strong>PIO是什么</strong>：这是应该是Pico最大的亮点，我没有看得很明白官方的说明。大概就是说能够使用PIO来实现硬件接口，相对于软件模拟的方式，可以达到更高的时钟精度、高得多的I/O吞吐量，还能分担一点CPU的计算工作，比如奇偶校验、和校验等。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zhihu.com/question/440677296">[3]</span></a></sup></p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/pico/20220212190432.png" width="1000"><center>Pico原理图</center></center><h3 id="pico提供的开发工具">Pico提供的开发工具</h3><p>  有一个C++的SDK，是专门给Pico设计的，感觉没有必要，用这套SDK不如用STM32系列的SDK。除了C++之外还有一个MicroPython的SDK，我是打算用这个来做点小东西，顺便学习一下各种嵌入式常见的外设。除此之外，学一些MicroPython也挺好的，主要看这个文档<ahref="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf">PicoPython SDK</a>。除此之外还有<ahref="https://datasheets.raspberrypi.com/rp2040/hardware-design-with-rp2040.pdf">RP2040硬件设计</a>、<ahref="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040Datasheet</a>和<ahref="https://datasheets.raspberrypi.com/pico/pico-datasheet.pdf">树莓派PicoDatasheet</a>这三个文档也可以作为学习过程的参考，主要和RP2040和Pico的硬件外设有关。</p><h2 id="pycharm-micropython-插件">PyCharm MicroPython 插件</h2><p>  直接在PyCharm的Settings-Plugins中去搜索“MicroPython”插件然后安装，完成后需要在Project中进行配置，在Settings-Languages&amp; Frameworks-MicroPython对开启该插件进行勾选，然后选择对应的Devicetype和Device path（我是在linuxubuntu下所以是dev/ttyACM0）。完成配置后使用如下程序进行测试，如果LED灯闪烁说明配置成功（REPL显示对应输出）：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin<br><span class="hljs-keyword">import</span> time<br><br>led = Pin(<span class="hljs-number">25</span>, Pin.OUT)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    led.value(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light on&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br>    led.value(<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;led light off&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/pico/20220212200558.png" width="600"><center>Pico原理图</center></center><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://whatis.techtarget.com/definition/SRAM-static-random-access-memory<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://www.cnblogs.com/firege/p/9435349.html<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://www.zhihu.com/question/440677296<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Raspberry Pico</category>
      
      <category>知识科普</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raspberry</tag>
      
      <tag>pico</tag>
      
      <tag>MicroPython</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人运动学中表示旋转的方法（四元数、欧拉角、旋转向量）</title>
    <link href="/2022/02/06/Rotation-Representation-Methods-Introduction/"/>
    <url>/2022/02/06/Rotation-Representation-Methods-Introduction/</url>
    
    <content type="html"><![CDATA[<p>在网上看了一些博客，感觉多数没有把旋转讲明白，包括各种表示法以及转换，因此记录本文整合一下网上相关的介绍，也作为以后复习的参考。</p><span id="more"></span><h2 id="什么是so3矩阵">什么是SO3矩阵</h2><h3 id="so3矩阵定义">SO3矩阵定义</h3><p>  最近在复习Robotics运动学和动力学，看的是ETH那份Dynamics讲义，看到运动学旋转矩阵这里的时候想深究一下SO3，讲义上并没有仔细介绍这个概念。简单来说，就是所谓的旋转矩阵群，在机器人学中能够表征刚体围绕原点旋转，并保持被旋转向量的长度和相对矢量方向，同时是线性的；在性质上，是所谓的SpecialOrthogonal Group，也即正交群（<spanclass="math inline">\(AA^T=I\)</span>）中行列式为1的部分。</p><h3 id="旋转矩阵">旋转矩阵</h3><span class="katex-error" title="ParseError: KaTeX parse error: Can&#x27;t use function &#x27;$&#x27; in math mode at position 1: $̲$_{A}r_{AP}=\…" style="color:#cc0000">$$_{A}r_{AP}=\begin{pmatrix}_{A}r_{AP_{x}}\\_{A}r_{AP_{y}}\\_{A}r_{AP_{z}}\\\end{pmatrix}\\_{}r_{AP}=\begin{pmatrix}_{B}r_{AP_{x}}\\_{B}r_{AP_{y}}\\_{B}r_{AP_{z}}\\\end{pmatrix}\\\rArr_{A}r_{AP}=\begin{bmatrix}_{A}e_{x}^{B} &amp; _{A}e_{y}^{B} &amp; _{A}e_{z}^{B}\end{bmatrix} \cdot { }_{B}r_{AP}=C_{AB} \cdot { }_{B}r_{AP}$$</span><h3 id="复合旋转矩阵">复合旋转矩阵</h3><h2 id="欧拉角euler-angle">欧拉角（Euler Angle）</h2><h3 id="欧拉角定义">欧拉角定义</h3><h3 id="几种典型欧拉角及计算">几种典型欧拉角及计算</h3><h2 id="李代数基础">李代数基础</h2><h3 id="李群">李群</h3><h3 id="李代数">李代数</h3><h2 id="轴线角angle-axis">轴线角（Angle Axis）</h2><h3 id="旋转向量">旋转向量</h3><h3 id="与旋转矩阵的转化">与旋转矩阵的转化</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编曲笔记目录</title>
    <link href="/2022/02/04/Music-Arrangment-Content/"/>
    <url>/2022/02/04/Music-Arrangment-Content/</url>
    
    <content type="html"><![CDATA[<h2 id="参考教程链接">参考教程链接</h2><ul><li><a href="https://space.bilibili.com/13639412">乐球网b站主页</a></li><li><ahref="https://www.bilibili.com/video/BV14x411s7KZ?p=15&amp;spm_id_from=pageDriver">B站乐球网最全从零开始的完整的编曲教程『301P更新完毕』【你还不会编曲吗？】</a></li><li><ahref="https://www.bilibili.com/video/BV1bx411s7A5?spm_id_from=333.999.0.0">FLStudio使用教程【乐球网】</a></li><li><ahref="https://www.bilibili.com/video/BV1CE411g7Wz/?spm_id_from=333.788.recommend_more_video.7">如何在B站自学音乐制作，从零开始系统全面引导向教程教你作曲编曲混音母带直到成为一名制作人</a></li><li><ahref="https://space.bilibili.com/285766656?spm_id_from=333.788.b_765f7570696e666f.1">来玩吉他b站主页</a></li><li><a href="http://www.fhdq.net/ts/96.html">音符符号</a></li></ul><h2 id="笔记目录">笔记目录</h2><ol type="1"><li><a href="">乐理基础</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ETH Robot Dynamics Note</title>
    <link href="/2022/02/04/ETH-Robot-Dynamics-Note/"/>
    <url>/2022/02/04/ETH-Robot-Dynamics-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="robot-dynamics-lecture-notes">Robot Dynamics Lecture Notes</h1><p>  来自ETH大神实验室Robotic Systems Lab, ETHZurich的课程笔记，感觉写的非常棒，仅仅100页不到总结了机器人学最核心的内容。这里作为阅读记录，使用English。笔记链接：<ahref="https://ethz.ch/content/dam/ethz/special-interest/mavt/robotics-n-intelligent-systems/rsl-dam/documents/RobotDynamics2017/RD_HS2017script.pdf">RobotDynamics Lecture Notes</a></p><h2 id="introduction">1 Introduction</h2><h3 id="nomenclature">1.1 Nomenclature</h3><h3 id="operators">1.2 Operators</h3><h2 id="kinematics">2 Kinematics</h2><h3 id="introduction-1">2.1 Introduction</h3><h2 id="dynamics">3 Dynamics</h2><h2 id="appendix">Appendix</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》1 让自己习惯C++</title>
    <link href="/2022/02/03/Effective-Cpp-Accustoming-Yourself-to-C/"/>
    <url>/2022/02/03/Effective-Cpp-Accustoming-Yourself-to-C/</url>
    
    <content type="html"><![CDATA[<h2 id="条款01view-c-as-a-federation-of-languages">条款01：View C++ as afederation of languages</h2><p>  当下的C++标准仍然在不断的扩充，我查了一下最新的C++20标准，也有<ahref="https://www.oschina.net/news/123834/cpp20-published">很多重大的更新</a>，比如模块等，这是继C++11以来加入重要新特性的一次更新。在链接下方的评论区有句话说的挺正确：</p><blockquote><p>C++功能非常多，支持范围非常广，然而各种功能各有各的使用场景。人家支持的全，并不是强行要求你全用，而是按需使用。自己不行，也不愿意学习和了解，还跑出来到处喷。对于c++，一定要清楚你需要什么，能够满足使用即可，而不是一个项目把所有功能都用上，真没必要。你可以先用最基本的功能实现，然后用新特性去改进，从而学习新特性。</p></blockquote><p>  根据本书，C++是一个多重范型编程语言（multiparadigm programminglanguage），同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式（metaprogramming）。所以C++最大的缺点是它的复杂性，这可能让很多项目变得难以维护。本书对此给出的建议是将C++看作多个次语言来学习和使用（正如上面的评论所说），对于不同的次语言需要考虑不同的高效编程策略，其中主要的四个次语言和其特点如下：</p><ol type="1"><li>C：最基础的部分，特点在于指针（pointers）、数组（arrays）、预处理器（preprocessor）等基础机能，对于程序员要求较高的主要是内存管理、指针运用等，此时pass-by-value通常比pass-by-reference更加高效；</li><li>Object-Oriented C++：即C withClasses的部分，包括了classes（构造与析构）、封装（encapsulation）、继承（inheritance）、多态（polymorphism）、virtual函数（动态绑定）等；</li><li>Template C++：这是C++ genericprogramming的部分，根据本书，template特性带来了TMP（templatemetaprogramming）的编程范式。不过在C++20特性中，貌似引入了能够替代TMP的新特性；</li><li>STL：是C++的一个template程序库，有很多现成迭代器和算法可以方便开发；</li></ol><h2 id="条款02prefer-consts-enums-and-inlines-to-define">条款02：Preferconsts, enums, and inlines to #define</h2><ul><li>对于单纯变量，最好以const对象或enums替换#defines</li><li>对于形似函数的macros，最好改用inline函数替换#defines</li></ul><h3 id="const">const</h3><p>  使用预处理器不会将被替换的记号名称记入记号表，这可能导致调试时不方便追踪记号名称。除此之外，使用常量可能比宏定义导致更小量的码，从而速度更快。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ASPECT_RATIO 1.653 <span class="hljs-comment">// preprocessor</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> AspectRatio = <span class="hljs-number">1.653</span>; <span class="hljs-comment">// compiler</span><br></code></pre></td></tr></table></figure><p>对于常量定义有两种特殊的情况需要注意：</p><ol type="1"><li>定义constant pointers</li></ol><p>  通常对于此类情况，我们希望指针和指针所指向的东西都是const的，因此需要写两次const。通常来说，使用string比char*字符串更好，对于constantpointers的定义更加简洁。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1st const is constant content(&quot;Scott Meyers&quot;)</span><br><span class="hljs-comment">// 2nd const is constant pointer(authorName)</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> std::string <span class="hljs-title">authorName</span><span class="hljs-params">(<span class="hljs-string">&quot;Scott Meyers&quot;</span>)</span></span>; <span class="hljs-comment">// use `std::string`</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>关于<code>&lt;string.h&gt;</code>、<code>&lt;cstring&gt;</code>、<code>&lt;string&gt;</code>的使用</strong>：</p><p>  <code>&lt;string.h&gt;</code>是C++标准化（1998年）以前的C++库文件，是原本C风格的字符串库。而<code>&lt;cstring&gt;</code>是<code>&lt;string.h&gt;</code>在C++标准化之后的对应版本，内容相同并做了一定升级，因此如果需要在C++中使用<code>&lt;string.h&gt;</code>，不妨引用<code>&lt;cstring&gt;</code>。（大部分原本的C标准库在C++标准化之后都是这么处理的，例如<code>&lt;cmath&gt;</code>和<code>&lt;math.h&gt;</code>等）这两个库中包含了strcmp、strchr、strstr等char*类型字符串操作的基本函数。</p><p>  <code>&lt;string&gt;</code>属于STL（标准模板库）范畴，包含了拟容器<code>classstd::string</code>的声明（事实上只是<code>basic_string\&lt;char\&gt;</code>的typedef），在<code>&lt;string.h&gt;</code>的基础上新增了一系列字符串操作。和上述两种global的标准库不同，<code>&lt;string&gt;</code>需要使用<code>std::strings;</code>来定义string变量。对于内存要求较高的项目，考虑减少使用string，即使在string类中使用了引用计数来减少内存占用。相关内容可以先参考<ahref="https://www.jianshu.com/p/6ed6755268f9">这篇博客</a>，我自己还没有做实验验证其内容。</p></blockquote><ol type="1"><li>定义class常量</li></ol><p>  需要限制scope在class内，因此将变量声明为class的即staticmember。需要注意的是，在头文件中我们如下进行的并不是定义，而是声明，因此需要在实现文件中进行定义。该staticclass变量只能给予一次初值，如果在头文件中不需要使用NumTurns，也可以在实现文件定义式中给予初值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// .h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayer</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">// declaration</span><br>    <span class="hljs-keyword">int</span> scores[NumTurns]; <span class="hljs-comment">// use the declared var</span><br>    ...<br>&#125;<br><br><span class="hljs-comment">// .cpp</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> GamePlayer::NumTurns; <span class="hljs-comment">// definition</span><br></code></pre></td></tr></table></figure><h3 id="enum-hack">enum hack</h3><p>  一个属于enumeratedtype的数值能够权充ints被使用，类似于#define作为一个记号名称，事实上编译器是不会为enum分配内存空间的。枚举类型最常见也最有意义的用处之一就是用来描述状态量，并且增强代码可读性。与const相比，enum变量的地址是无法获取的，因此我们能够用enum来避免别人使用pointer或reference指向我们定义好的整型变量（这一点是const关键字做不到的）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Days</span> &#123;</span><br>    Mon,<br>    Tues,<br>    Wed,<br>    Thu,<br>    Fri<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> const_Mon = <span class="hljs-number">0</span>;<br>cout &lt;&lt; Mon &lt;&lt; endl &lt;&lt; const_Mon &lt;&lt; endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;const_Mon);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;Mon); <span class="hljs-comment">// Cannot take the address of an rvalue of type &#x27;Days&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="inline">inline</h3><p>  我们使用预处理器（如宏函数和宏变量等），是因为可以提高程序的运行效率，预处理器会在编译前将这些宏定义以文本方式在代码文件中进行替换，从而避免了在运行时的栈空间占用。但是宏定义纯文本替换带来的诸多限制性，因此使用inline函数是更好的选择。</p><p>  inline即内联函数，会在编译阶段<strong>告诉</strong>编译器你要将函数体嵌入到每一个调用该函数的语句块中，这和宏是相似的（但是编译器并不一定听话，聪明的编译器会自己判断是否进行替换）。这么做的好处是能够避免一些小规模函数重复调用带来的堆栈开销，而坏处是可能导致代码膨胀，更多可以参考<ahref="https://zhuanlan.zhihu.com/p/50812510">这个博客</a>。例如下面两种代码，都是用于实现“<strong>以a和b的较大值调用f</strong>”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// macro</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-comment">// example of limitation</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, <span class="hljs-number">0</span>); <span class="hljs-comment">// ++a run twice</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, <span class="hljs-number">10</span>); <span class="hljs-comment">// ++a run once</span><br><br><span class="hljs-comment">// inline (better)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; a, <span class="hljs-keyword">const</span> T&amp; b)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条款03use-const-whenever-possible">条款03：Use const wheneverpossible</h2><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwiseconstness，但你编写程序时应该使用“概念上的常量性”（conceptualconstness）。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul><p>  <code>const</code>的用法很多，但是总体来说体现了我们在程序设计时的对编译器强制的语义约束，当我们需要某个变量或者对象不可变更时，加上一个<code>const</code>总是更好的选择。<strong><code>const</code>可以用于在classes外部修饰global或namespace作用域的常量，或修饰文件、函数、或blockscope中被声明为static的对象。面对指针，你也可以指出指针自身、指针所指物、或两者都（或都不）是const。</strong></p><blockquote><p>static对象在函数中的使用（这个自己还真没用过），其实就是在函数多次调用中并不是将值储存在堆栈中，而是在“全局/静态存储区”。可以参考<ahref="https://www.cnblogs.com/chengkeke/p/5417376.html">这篇博客</a>的例子。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// const 用于变量声明时的三种位置</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> pi)</span> <span class="hljs-comment">// const pointer</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> * pi)</span> <span class="hljs-comment">// const value</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* pi)</span> <span class="hljs-comment">// const value (same with 2)</span></span><br></code></pre></td></tr></table></figure><h3 id="stl迭代器">STL迭代器</h3><h4 id="什么是stl迭代器">什么是STL迭代器</h4><p>东西有点多，记在另一篇博客了</p><h3 id="一般函数声明">一般函数声明</h3><h3 id="成员函数声明">成员函数声明</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Note of A Low Cost Modular Actuator for Dynamic Robots</title>
    <link href="/2022/02/03/Note-of-A-Low-Cost-Modular-Actuator-for-Dynamic-Robots/"/>
    <url>/2022/02/03/Note-of-A-Low-Cost-Modular-Actuator-for-Dynamic-Robots/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》0 导读</title>
    <link href="/2022/02/02/Effective-Cpp-Introduction/"/>
    <url>/2022/02/02/Effective-Cpp-Introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="terminology">Terminology</h2><h3 id="声明-declaration">声明-declaration</h3><p>在《C++ Primer》中提到：</p><blockquote><p>变量声明：用于向程序表明变量的类型和名字。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> x; <span class="hljs-comment">// declare an object</span><br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">numDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>; <span class="hljs-comment">// declare a function</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span> <span class="hljs-comment">// declare a class</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// declare a template</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphNode</span>;</span><br></code></pre></td></tr></table></figure><h4 id="extern关键字">extern关键字</h4><p>  通过使用extern关键字能够声明变量名而不定义它，使用extern编译器不会给变量分配存储空间。所以<code>externint x;</code>是声明而不是定义，而<code>intx;</code>是声明也是定义。但是如果对声明进行了initialization，如<code>externint x = 1;</code>，则一定是定义。</p><p>  对函数来说如果加了<code>&#123;&#125;</code>就是定义，如果没有就是声明。<strong>在一个程序中，变量或函数可以声明多次（如下会提示<code>Clang-Tidy:Redundant 'foo'declaration</code>），但是定义只能有一次</strong>，如下代码能够编译成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>; <span class="hljs-comment">// redundant declaration</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123; <span class="hljs-comment">// definition</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用std">使用std</h4><p>  为了方便，作者在后面章节的代码中省略了C++标准程序库的命名空间<code>std::</code>的书写，但是在实际编译时是不能省略的。另外，<code>usenamespacestd;</code>并不是一个好选择，因为会引入很多不必要的名称，这可能会导致灾难性的结果。在《C++Primer Plus》的“第九章-内存模型和名称空间”中，提到：</p><blockquote><p>  一般说来，使用using命令比使用using编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。<strong>如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。</strong>另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p></blockquote><h4 id="为什么使用size_t">为什么使用size_t</h4><p>  上面提到的标准库中的size_t，是很多C++Programmer知道但是很多时候不敢用的一个typedef的unsignedinteger类型。使用size_t能够使得代码更加便于在不同系统间移植（如IP16L32和I16PL32），同时增加移植性和可读性，可以参考给出的链接<ahref="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?">Whysize_t matters</a>。</p><h4 id="函数签名-signature">函数签名-signature</h4><p>  官方定义的C++signature只包括函数的参数，不包括返回类型。编译器在检查函数signature是否重复时，如果两个函数声明只有返回类型不同，编译器同样会报错，因为它不知道调用的是哪个函数。但是本书为了帮助理解将返回类型视为signature的一部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>  上面的declaration我使用C++14标准会报<em>“Functions that differ onlyin their return type cannot beoverloaded”</em>。如下的代码是可以编译通过的（对于C89来说这两种都不行，C只检查函数名，而不会将参数类型和返回值加到signature中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="定义-definition">定义-definition</h3><p>  书中描述是<em>“definition的任务是提供编译器一些声明式所遗漏的细节“</em>，个人感觉说的不够清楚。在《C++Primer》中提到：</p><blockquote><p>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义（定义也是声明）。</p></blockquote><h4 id="关于声明与定义的程序设计风格">关于声明与定义的程序设计风格</h4><p>  参考博客<ahref="https://blog.csdn.net/sjxbf/article/details/6310150">C++定义与声明区别</a>，我觉得有几点很值得注意：</p><ol type="1"><li>不要把变量定义放入.h文件，这样容易导致重复定义错误。</li><li>但是值在编译时就已知的const变量的定义、类的定义、inline函数的定义可以放到头文件中。</li><li>尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。</li><li>可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。</li></ol><h3 id="初始化-initialization">初始化-initialization</h3><p>  初始化是“给予对象初值”的过程，通常由构造函数constructor完成。需要注意如下三个特别的构造函数：default构造函数、copy构造函数、以及copyassignment操作符。</p><h4 id="default构造函数">default构造函数</h4><p>  default构造函数的要求是<em>“一个可被调用而不带任何实参者”</em>，也可以是每个参数都有缺省值。<strong>通常来说，建议构造函数被声明为explicit，这样能够阻止implicittype conversions。</strong></p><h4 id="copy构造函数和copy-assignment操作符">copy构造函数和copyassignment操作符</h4><p>  copy构造函数被用来<em>“以同型对象初始化自我对象”</em>，而copyassignment操作符被用来<em>“从另一个同型对象中拷贝其值到自我对象”</em>。copy构造和copy赋值的区别在于是否有新的对象被创建。<strong>这两个都是典型的pass-by-value的方式，而一般更好的方式是pass-by-reference-to-const。</strong>书中的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(); <span class="hljs-comment">// default构造函数</span><br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy构造函数</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs); <span class="hljs-comment">// copy assignment操作符</span><br>    ...<br>&#125;;<br>Widget w1; <span class="hljs-comment">// 调用default构造函数</span><br><span class="hljs-function">Widget <span class="hljs-title">w2</span><span class="hljs-params">(w1)</span></span>; <span class="hljs-comment">// 调用copy构造函数</span><br>w1 = w2; <span class="hljs-comment">// 调用copy assignment操作符</span><br></code></pre></td></tr></table></figure><h3 id="standard-template-library-stl">Standard TemplateLibrary-STL</h3><p>  是C++标准程序库的一部分，内含容器（vector、list、set、map等），迭代器（iterator、set<string>::iterator等），算法（for_each、find、sort等）及其相关机能。作者说STL是非常有用的，不过我基本没用过（因为我C++课的老师主要让我们搞速度优化，用STL肯定卷不过别人了）。</p><h3 id="不明确行为-undefined-behavior">不明确行为-undefinedbehavior</h3><p>  带有undefinedbehavior的程序通常是令人崩溃的，这样的程序即使能够编译成功，在执行过程中可能有时正常执行，有时造成崩坏，有时产生不正确的结果。因此，使用C++编程时要能够自己处理异常并小心避免undefinedbehavior。下面程序的返回值就是一个随机的结果，因为数组name的大小为6，发生了越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> name[] = <span class="hljs-string">&quot;Darla&quot;</span>;<br><span class="hljs-keyword">char</span> c = name[<span class="hljs-number">10</span>];<br>std::cout &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h2 id="tr1和boost">TR1和Boost</h2><p>TR1是描述C++许多新机能的一份规范，而Boost是一个相关的开源平台。关于这方面，下面提供了一些可能有帮助的C++学习相关资源链接。</p><ul><li><ahref="https://www.runoob.com/cplusplus/cpp-useful-resources.html">C++有用的资源</a></li><li><a href="https://en.cppreference.com/w/cpp/header">C++ StandardLibrary headers</a></li><li><a href="https://en.wikibooks.org/wiki/C++_Programming">C++Programming（书）</a></li><li><a href="http://www.sunistudio.com/cppfaq/">C++ FAQ LITE —Frequently Asked Questions</a></li><li><a href="https://www.thefreecountry.com/sourcecode/cpp.shtml">Free C/ C++ Libraries, Source Code and Frameworks</a></li><li><a href="https://www.boost.org/">boost</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Effective C++ 第三版》阅读笔记目录</title>
    <link href="/2022/02/02/Effective-Cpp-Content/"/>
    <url>/2022/02/02/Effective-Cpp-Content/</url>
    
    <content type="html"><![CDATA[<p>  《Effective C++第三版》这本书给出了55条使用C++编程时需要注意的要点，帮助程序员写出更加优雅合理的程序。如导读里所说，<em>“学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是另一回事”</em>，在这方面C++是代表。因此，本书的目的不是教你学会C++，而是学习如何写出Effective的C++程序。</p><p>  我记录这篇笔记的目的是为了提取我自己认为重要，或是需要的条款，方便以后写代码时随时能够查看使用。因此，有些地方可能会进行拓展学习，有些地方只是一笔带过。个人能力有限，如果有错误的内容烦请在评论区指正！</p><p>  另外帮我的C++课老师于仕琪教授打个广告，他的C++程序设计课程体验很棒。大家可以去<ahref="https://space.bilibili.com/519963684?from=search&amp;seid=2332289542653409243&amp;spm_id_from=333.337.0.0">b站</a>围观一下，并且这里也提供了他的<ahref="https://github.com/ShiqiYu/CPP">课程仓库</a>，大家可以下载ppt和实例代码看看，课程讲了很多矩阵运算优化方法。</p><h2 id="catalog">Catalog</h2><ol start="0" type="1"><li><a href="">Introduction</a></li><li><a href="">Accustoming Yourself to C++</a></li><li><a href="">Constructors, Destructors, and AssignmentOperators</a></li><li><a href="">Resource Management</a></li><li><a href="">Designs and Declarations</a></li><li><a href="">Implementations</a></li><li><a href="">Inheritance and Object-Oriented Design</a></li><li><a href="">Templates and Generic Programming</a></li><li><a href="">Customizing new and delete</a></li><li><a href="">Miscellany</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陆地冲浪板介绍与选型</title>
    <link href="/2022/01/30/Surfskate-Selection/"/>
    <url>/2022/01/30/Surfskate-Selection/</url>
    
    <content type="html"><![CDATA[<hr /><h2 id="surfskate的由来">Surfskate的由来</h2><p>  中文名陆地冲浪板（简称“陆冲”），板如其名，是用于模拟海上冲浪的。众所周知，冲浪要在暖季合适的海岸，滑雪要在冬季合适的雪地，条件苛刻，更别提大家疲于996福报很少有时间出行去冲浪滑雪。因此，入手一个陆地冲浪板能够帮助提高技能水平，是冲浪滑雪很好的练习道具。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-surf.jpeg" height="250" /></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/surfskate/Surfskate-Selection-ski.png" height="250" /></div></div></div><h2 id="市面大牌选型">市面大牌选型</h2><p>  可以参考<ahref="https://zhuanlan.zhihu.com/p/73588869">这个链接</a>，对于每种品牌的特点和桥的特点都说的很明白。这个大佬做了一张图，我只用过Yow的桥没啥发言权，所以参考这位老兄的经验肯定是靠谱的。</p><center><img src="https://pic2.zhimg.com/v2-648b45c90639c886ea0eef7d3989eba5_r.jpg" width="1000"><center>陆冲选型参考</center></center><h2 id="保养与维护">保养与维护</h2>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=62322438&bvid=BV1ht411M78i&cid=108319980&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><p>另外还可以参考：</p><ul><li><a href="https://www.bilibili.com/video/av89625664">YOW陆地冲浪板官方维修指南 Surf YOW Systems Tutorial</a></li><li><ahref="https://zhuanlan.zhihu.com/p/105870163">Carver冲浪滑板和其他Surfskate陆地冲浪板入门到快乐（五）维修篇</a></li><li><ahref="https://space.bilibili.com/508830">猫咪贵族（b站一位玩陆冲的大佬）</a></li></ul><h2 id="玩法show">玩法show</h2><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/82459365">陆地冲浪surfskate入手后的问题和使用说明书！</a></li><li><ahref="https://www.bilibili.com/video/BV1wy4y1E7KL?from=search&amp;seid=16512587863776667224&amp;spm_id_from=333.337.0.0">日本小哥横刹(PowerSlide)教学【搬运|字幕】</a></li></ol><p><em>我玩的经验下次博客再介绍吧（等我玩熟练了先） ヾ(=･ω･=)o</em></p>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>知识科普</category>
      
      <category>陆地冲浪/冲浪/滑雪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>surfskate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐理基础</title>
    <link href="/2022/01/30/Music-Theory/"/>
    <url>/2022/01/30/Music-Theory/</url>
    
    <content type="html"><![CDATA[<p>图片和教程来源，<ahref="https://www.bilibili.com/video/BV14x411s7KZ?p=1">bilibili乐球网编曲教程</a>。个人仅作笔记，侵删。</p><span id="more"></span><h2 id="音程">音程</h2><p>  我们能够用<strong>属性+大小+单位</strong>的方式来描述音程。音程是两个音之间的距离，单位都是度；大小有从一到七；属性有<strong>纯、大、小、增、减、倍增、倍减</strong>。</p><h3 id="音程大小">音程大小</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204192938.png" width="550"><center>图 1</center></center><ul><li>对于白键：直接数两者之间有几个白键就是几度，注意是包括开始和结束的键；</li><li>对于黑键：首先还原黑键，然后和白键一样数就行；</li></ul><blockquote><p>  也可以这样，sou就是5，升re就是♯2（或者♭3），因此对应(5-2)+1=4，所以是四度。不过好像跨了下一个八度就不好算了，还是好好数琴键吧&gt;_&lt;|||</p></blockquote><h3 id="音程属性">音程属性</h3><p>  如图1所示，尽管大小相同，还需要区分属性。<strong>“纯”只存在于一、四、五、八度中，“大/小“只存在于二、三、六、七度中，而“增、减、倍增、倍减”存在于所有度数大小</strong>。即，不存在纯三度或大四度。</p><h3 id="标准音程与音程计算">标准音程与音程计算</h3><p>  标准音程是以C为起点到下一个八度的C为止，共七个白键音程的名称。如图2所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204203925.png" width="550"><center>图 2</center></center><p>  对于不是两个琴键都落在白键上的情况，遵循以下的步骤进行计算：</p><ol type="1"><li>找大小：还原升降号，然后数白键的数量；</li><li>找属性：数白键和黑键的总数，通过图3的公式和标准音程比较，进行计算；</li></ol><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204204602.png" width="550"><center>图 3</center></center><p>  例如：对于♯F和D，如图4所示。首先，还原♯F，F和D之间有6个琴键，所以是六度。标准的六度是10个键，对应的是大六度。然后，数白键与黑键一共是9个键，因此根据公式结果是小六度。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204205257.png" width="550"><center>图 4</center></center><blockquote><p>  我自己总结也差不多，假设E和F之间以及B和C之间少了一个黑键我们叫做一个坑（“少了个黑键”），那么最终其实就是比较坑的数量嘛。假设还是♯F和D，很容易发现♯F和G之间由于升降号导致了一个坑，在B和C之间本来有一个坑，那么一共是两个坑。标准的六度是一个坑（标准的四度到七度都是一个坑），所以♯F到D比标准的多了一个坑（“少了一个黑键”），因此是小六度。</p></blockquote><h2 id="和弦">和弦</h2><p>  和弦就是<strong>以任何一个音作为根音，往上按照三度的音程关系叠加构成的组合</strong>。和弦最少是三个音，两个音的是音程。所谓三和弦，指的是根音到冠音的度数是三，而后面直到十三和弦以此类推。音最多的十三和弦有7个音，刚好从C到B。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204223656.png" width="550"><center>图 5</center></center><h3 id="三和弦">三和弦</h3><p>  属性包括“<strong>大三和弦、小三和弦、增三和弦、减三和弦</strong>”，其中增三和弦在流行乐中很少用到，所以这里不讲。区分大三和弦，小三和弦和减三和弦的方式是看三和弦的两个音程的属性，如图6：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204231246.png" width="550"><center>图 6</center></center><p>  例如：FAC是大三度+小三度=F大三和弦，F♭AC是小三度+大三度=F小三和弦，F♭A♭C是小三度+小三度=F减三和弦（这就是F为根音对应的几个三和弦）</p><h3 id="七和弦">七和弦</h3><p>  属性主要包括“<strong>大大七和弦、小小七和弦、大小七和弦、减小七和弦、减减七和弦</strong>”，其中我们并不会这么叫，实际的叫法是“<strong>大七和弦、小七和弦、属七和弦、半减七和弦、减七和弦</strong>”。区分它们的方法建立在三和弦的分类基础上，如图7所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204233441.png" width="550"><center>图 7</center></center><p>  例如：DFAC是小三和弦+小七度=D小七和弦，DF♭AC是减三和弦+小七度=D半减七和弦，DF♭A♭C是减三和弦+减七度=D减七和弦（这就是D为根音对应的几个七和弦）</p><blockquote><p>这里其实可以换一种理解方式（可能更好计算一点）： *大三和弦+大三（大七）=大七和弦 * 大三和弦+小三（小七）=属七和弦 *小三和弦+小三（小七）=小七和弦 * 减三和弦+大三（小七）=半减七和弦 *减三和弦+小三（减七）=减七和弦</p></blockquote><h3 id="和弦转位">和弦转位</h3><p>  和弦转位其实就是将和弦中的某个或某些音提高了八度，然后低音变成了其他音。如图8中C（表示C大三和弦）的转位，由于除了根音外有两个音，所以三和弦都是有两个转位的。图8中间的<strong>C/E就是C和弦第一转位，“/”前面的“C”表示这是一个C和弦，后面的“E”表示低音演奏E</strong>；而C/G同理。注意到，对于C/E来说，只要保证低音是E，上面不论是135还是513都没有关系，都是C和弦第一转位。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220204234704.png" width="550"><center>图 8</center></center><p>  对于七和弦，也是同样的道理。例如：CM7（也就是C小七和弦）是CEGB是原位，然后第一转位是CM7/E，也就是E...（如EGBC），第二转位是G...（如GBCE），以此类推共有三个和弦转位。再比如下图9，原位是D7（D属七和弦），对应的三个转位是D7/♯F、D7/A、D7/C。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205000556.png" width="550"><center>图 9</center></center><h2 id="音调">音调</h2><p>  对于一首歌，如果调太高了唱不上去，我们通常会降调，音阶整体上移或下移就是变调（变调是不会改变旋律本身的）。首先是自然大调和自然小调，在其基础上对六音和七音进行升降就得到和声大调、旋律大调、和声小调、旋律小调。</p><h3 id="自然大调">自然大调</h3><p>  总结来说，<strong>听起来像CDEFGABC的就是自然大调</strong>，上述是C大调。再比如说，♭D大调是♭D♭EF♭G♭A♭BC♭D，E大调是E♯F♯GAB♯C♯DE，这些自然大调的音阶结构，都是如下图10所示：</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205103723.png" width="550"><center>图 10</center></center><h3 id="自然小调">自然小调</h3><p>  总结来说，<strong>听起来像ABCDEFGA的就是自然大调</strong>，上述是A小调。再比如说，C小调是CD♭EFG♭A♭BC。自然小调的音阶结构如下图11所示。由此，我们又能够看出，C大调和A小调的音是一样的，只是顺序不同而已，因此它们称为<strong>关系大小调</strong>。除此之外，C大调的C和A小调的A之间差了一个小3°，因此所有的关系大小调间也是差了一个小3°。例如，C小调的关系大调是♭E大调。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205110501.png" width="550"><center>图 11</center></center><h3 id="如何辨别一首歌的调">如何辨别一首歌的调</h3><blockquote><p>  这里貌似教程少了这方面的内容，所以另外找了个讲的很好的视频补上！<strong>其实就是听最后的结尾旋律，一般流行乐的结尾音就是这个调的调名啦</strong>，不过我乐感好拉跨（羡慕绝对音感的人）。</p></blockquote>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">        <iframe src="//player.bilibili.com/player.html?aid=43075656&bvid=BV1cb411S7ra&cid=141283989&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe>    </div><h3 id="调性">调性</h3><p>  即在自然大调和自然小调的基础上对六音和七音进行升降，如下图12所示。例如：要找E和声大调，首先找到E自然大调E♯F♯GAB♯C♯DE，然后降低六音得到E♯F♯GABC♯DE，此时再降低七音得到E旋律大调E♯F♯GABCDE。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205140927.png" width="550"><center>图 12</center></center><h2 id="音符">音符</h2><p>  音符就比较简单了，即所谓表示演奏时间的长短。这一部分因为自己好歹学了多年演奏，比较熟练所以就懒得记太多了。图13是从全音符到六十四分音符单个的写法（六十四一般用不到）。图14是节拍的写法，例如：3/4念作四三拍，表示以四分音符为一拍，一个小节是三拍。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205141824.png" width="550"><center>图 13</center></center><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142042.png" width="550"><center>图 14</center></center><h3 id="附点音符">附点音符</h3><p>  附点音符=原音符+原音符的一半，如图15。附点在乐谱上的写法也要注意，如果音符在第n线上，那个附点标记在这条线的上面的间；如果音符在间上，那么直接标记在这个间就可以了。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205142607.png" width="550"><center>图 15</center></center><h3 id="休止符">休止符</h3><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205143000.png" width="550"><center>图 16</center></center><h3 id="连音">连音</h3><p>  概念比较简单，注意连音的写法。如果音符是四分音符，标了三连音的符号之后（三连音对应到2），相当于4个四分音符也就是两拍，即<strong>在两拍内演奏完三连音</strong>。再比如如下图17，音符是十六分音符（五、六、七连音对应到4），相当于4个十六分音符也就是一拍，即<strong>在一拍内演奏完五、六、七连音</strong>。以此类推，9～15连音对应到8进行相应的计算。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/music/20220205144219.png" width="550"><center>图 17</center></center>]]></content>
    
    
    <categories>
      
      <category>杂学笔记</category>
      
      <category>编曲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编曲</tag>
      
      <tag>b站</tag>
      
      <tag>乐理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人娱乐与文学</title>
    <link href="/2022/01/30/Robot-Introduction/"/>
    <url>/2022/01/30/Robot-Introduction/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/file/robotIntroductionPaper.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>课程相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器人</tag>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝冢与歌剧少女</title>
    <link href="/2022/01/30/Takarazuka-Revue/"/>
    <url>/2022/01/30/Takarazuka-Revue/</url>
    
    <content type="html"><![CDATA[<h2 id="一选题原因">一、选题原因</h2><p>  老师在课上介绍宝冢歌剧团时，提问我们是如何了解到“宝冢”这个名字的，当时我回答是从一部番剧了解的，这部番剧即本文分析涉及的2021新番“歌剧少女”。歌剧作为本门课程中重要的课题，我希望结合宝冢歌剧团和这部番剧来进行一些歌剧文化方面的探讨。</p><h2 id="二宝冢歌剧团">二、宝冢歌剧团</h2><p>  与歌舞伎全部为男性演员相反，日本宝冢歌剧以全员女性的形式为观众演绎各种各样的浪漫爱情故事。自大正年间创立以来宝冢已有百年历史，如今分为各具特色的“花、月、雪、星、宙”五个组，可简单总结其特色为歌舞之花、戏剧之月、和物之雪、装扮之星、年轻之宙。宝冢的歌剧题材来源极其广泛，服装和舞台效果也非常还原所演绎的故事设定。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="易巧丽.华丽旖旎的女性之梦谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84.">[1]</span></a></sup></p><p>  宝冢歌剧一个重要的特色是男役演员，为了向以已婚女性主妇为主体的观众展现其“大男主”题材的爱情故事，舞台的核心即男役演员需要展现出完美的男性魅力。宝冢歌剧通过瑰丽的舞台，为女性观众们编织了完美与浪漫的爱情之梦。</p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-1.png" width="300"><center>宝冢歌剧团首席男役</center></center><h2 id="三歌剧少女">三、歌剧少女</h2><p>  番剧“歌剧少女”是一部歌剧相关题材的漫改动画，于2021年7月开始放送。剧中的红华歌剧学院即现实中的宝冢音乐学院，且许多专有名词，如男役、娘役、预科生等，以及戏剧名和相关文化特色均是直接还原现实中的宝冢文化，个人认为在设定上对宝冢的还原度相对较高。</p><p>  放送完结的第一季对应原作的前日谈部分，介绍了几位不同背景的预科生各自的过往和相互建立羁绊的故事。有意思的是，剧中主要角色的背景还涉及了歌舞伎和偶像文化等。与少女漫画或偶像企划（如lovelive）不同，本剧细致描写了各个同学在学院学习歌剧的跌宕起伏的经历，并且在细节上较好的还原了宝冢音乐学院的特色（如学生间的阶级制度和各种道具等）。</p><p>  “歌剧少女”的片尾曲很有宝冢的歌剧特色，经过调查发现音乐部分是由在宝塚歌剧团工作过的齐藤恒芳先生完成作词、作曲、编曲的。在字幕表中能看到不少宝冢的OG也有演出。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><center><img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main/img/2022/takarazuka/Takarazuka-Revue-2.png" width="300"><center>歌剧少女宣传封面</center></center><h2 id="四宝冢歌剧文化的创新与魅力">四、宝冢歌剧文化的创新与魅力</h2><p>  <em>“一般文化的寿命是50年，50年过后，即便不消失也不再是大众之物。”</em></p><p>  随着互大众传媒的发展，娱乐的形式和观赏娱乐的方式都在不断扩张，许多曾经流行的艺术也在逐渐淡出历史舞台。这并不是一件坏事，毕竟艺术源于生活，而当一种艺术已经与当代人的生活脱钩时，这种艺术也不再能引起人们的共鸣。如为了迎合当下快节奏的生活方式而诞生出的“短视频”文化，而像豫剧、河北梆子等这种地方戏剧没有跟上时代的改变并迎合现代人的喜好，便逐渐在戏剧的历史舞台上消逝。</p><p>  我认为宝冢歌剧是成功迎合新时代的文化之一，我认为主要原因有两点。</p><p>  首先是题材上的创新，在电视刚开始流行的时候，宝冢歌剧遭遇了严重的打击，而她们顶住舆论的压力，用一部《凡尔赛玫瑰》成功背水一战重新焕发生机。而后来她们也尝试去改编各种各样的题材，包括古代历史、近代风物、当代故事、甚至关于未来想象，容纳了中国、阿拉伯、印度等各个国家的文化，改编自歌剧、话剧、影视剧、漫画、小说、历史传说、神话故事等；</p><p>  其次是系统的演员培养方式和优秀的团内文化，很多人真正粉上宝冢歌剧不是由于戏剧本身，而是由于舞台上绚丽多姿的演员们，尤其是男役演员。所谓“男役十年”，即培养一个优秀的男役演员需要十年的功夫来模仿、沉淀和学习，从而演绎出“女性眼中最完美的男性”。其次，在宝冢音乐学院里，学生不仅要学习各种歌剧表演方面的技能和知识，更加重要的是对气质的培养，即“清正美”的形象和态度。</p><h2 id="五歌剧少女与宝冢歌剧">五、歌剧少女与宝冢歌剧</h2><p>  在讨论宝冢歌剧的魅力时，上面提到了宝冢歌剧团演员的培养和团内文化，而这方面的魅力如何才能展现在大众的面前呢？如何能将宝冢歌剧团内日复一日的枯燥练习，与背后每个团员的故事与经历呈现在大众面前呢？歌剧少女这部番剧，就很好的做到了这一点。</p><p>  制片人诹访丰在访谈中提到，他原本对歌剧并不熟悉，而是在看了原作漫画后对其产生兴趣，<em>“实际去观看了歌剧后，发现非常有趣。我觉得就像是这样的我一样，如果能通过作品，给其他人制造一个契机，会是非常好的一件事，这也是企划立项原因之一。”</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.">[2]</span></a></sup></p><p>  实际上，这是一种很好的扩大戏剧影响力的方式，和在论坛中有同学讨论关于游戏原神的角色云瑾与京剧文化的结合相似。歌剧少女通过二次元番剧和漫画的形式，将宝冢歌剧文化浓缩为一个个角色背后生动的故事，故事中的主角即为台上的演员。通过这些或是感人、或是引人发笑的故事，将宝冢歌剧团的魅力更是加深一层，也使得更多原本对宝冢不了解的人们能够来尝试观看歌剧，并找到其中的乐趣。</p><p>  举个例子说明，番剧中有一段关于身材焦虑与催吐的剧情，最终在老师的开导下该角色走出了焦虑。我认为这类的焦虑其实在宝冢歌剧团和一些偶像团体中并不少见，但观众和饭们平时不会对此有深刻的体会。而在观看番剧的过程中，观众们能够认识到这些演员们平时不能在大众面前表现的一面，从而使现实中的演员的人设更加丰富具体。</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>易巧丽.华丽旖旎的女性之梦谈日本宝冢歌剧中的多元化[J].中国戏剧,2021(03):83-84.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>“音乐学院舞台，描写青春友情，《歌剧少女!!》制片人诹访丰的访谈”.https://www.bilibili.com/read/cv12419830.<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>知识科普</category>
      
      <category>课程论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>戏剧</tag>
      
      <tag>番剧</tag>
      
      <tag>宝冢</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT Cheetah 论文阅读笔记</title>
    <link href="/2022/01/28/Cheetah-Paper-Reading/"/>
    <url>/2022/01/28/Cheetah-Paper-Reading/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制</tag>
      
      <tag>MPC</tag>
      
      <tag>Mit Cheetah</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

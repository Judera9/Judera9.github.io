<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Image Interpolation | Jude's Blog</title><meta name="keywords" content="DIP,NumPy,图像插值"><meta name="author" content="Jude"><meta name="copyright" content="Jude"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Support .ipynb and images could be found here">
<meta property="og:type" content="article">
<meta property="og:title" content="Image Interpolation">
<meta property="og:url" content="https://judera9.github.io/2022/03/04/2022-3-4-Image-Interpolation/index.html">
<meta property="og:site_name" content="Jude&#39;s Blog">
<meta property="og:description" content="Support .ipynb and images could be found here">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-03-04T11:51:57.000Z">
<meta property="article:modified_time" content="2022-03-16T03:25:33.000Z">
<meta property="article:author" content="Jude">
<meta property="article:tag" content="DIP">
<meta property="article:tag" content="NumPy">
<meta property="article:tag" content="图像插值">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://judera9.github.io/2022/03/04/2022-3-4-Image-Interpolation/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Image Interpolation',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-16 11:25:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jude's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Image Interpolation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-04T11:51:57.000Z" title="发表于 2022-03-04 19:51:57">2022-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-16T03:25:33.000Z" title="更新于 2022-03-16 11:25:33">2022-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/">课程相关</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3/DIP/">DIP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Image Interpolation"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Support <code>.ipynb</code> and images could be found <a target="_blank" rel="noopener" href="https://github.com/Judera9/Pictures-for-Blogs/tree/main/file/DIP%20support%20files/interpolation">here</a></p>
<span id="more"></span>
<h1 id="image-interpolation">Image Interpolation</h1>
<ul>
<li><a href="#image-interpolation">Image Interpolation</a>
<ul>
<li><a href="#objectives">Objectives</a></li>
<li><a href="#principle">Principle</a>
<ul>
<li><a href="#geometric-center-alignment">Geometric Center Alignment</a></li>
<li><a href="#nearest-neighbor-interpolation">Nearest Neighbor Interpolation</a>
<ul>
<li><a href="#derivation">Derivation</a></li>
<li><a href="#pseudo-code">Pseudo Code</a></li>
</ul></li>
<li><a href="#bilinear-interpolation">Bilinear Interpolation</a>
<ul>
<li><a href="#derivation-1">Derivation</a></li>
<li><a href="#pseudo-code-1">Pseudo Code</a></li>
</ul></li>
<li><a href="#bicubic-interpolation">Bicubic Interpolation</a>
<ul>
<li><a href="#derivation-2">Derivation</a></li>
<li><a href="#pseudo-code-2">Pseudo Code</a></li>
</ul></li>
</ul></li>
<li><a href="#analysis">Analysis</a>
<ul>
<li><a href="#brief-results">Brief Results</a></li>
<li><a href="#nearest-neighbor-interpolation-1">Nearest Neighbor Interpolation</a></li>
<li><a href="#bilinear-interpolation-1">Bilinear Interpolation</a></li>
<li><a href="#time-complexity-analysis">Time Complexity Analysis</a>
<ul>
<li><a href="#enlarge">Enlarge</a></li>
<li><a href="#shrunk">Shrunk</a></li>
</ul></li>
</ul></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
<h2 id="objectives">Objectives</h2>
<p>The task of this lab homework is to understand and accomplish codes design for <em>nearest neighbor interpolation, bilinear interpolation and bicubic interpolation</em> in python. The specific implementation of these algorithms is packed in corresponding <code>.py</code> files, the report and test codes are embedded in the <code>.ipynb</code> file. The report contains the derivations, principles and Pseudo codes of the algorithms mentioned above, and then given some optimization, extension and analysis of the results.</p>
<p>Image Interpolation is a significant issue in DIP, we need it when resizing or distorting images from one pixel grid to another. Therefore, the effect and time consumed by varied interpolation algorithms are extraordinarily important. <strong>However, There is always trade-off between efficiency and effect</strong>.</p>
<h2 id="principle">Principle</h2>
<h3 id="geometric-center-alignment">Geometric Center Alignment</h3>
<p>Actually, during interpolation we view pixel positions not as integer, but as float values, this understanding helps when implementing those interpolation algorithms. The meaning of geometric center alignment is that the original figure and the new figure should be aligned based on the image center, not the left side. To achieve this, a coordinate transform is essential, here is an example as the figure shows (sampling from 4 to 5):</p>
<p><span class="math display">\[
transform factor \ \alpha=\frac{src size}{dst size} \\
src=(dst+0.5)\times\alpha-0.5
\]</span> If I want to find the position of A' in float, or find the index of its neighbors. Here is the calculation:</p>
<p><span class="math display">\[
\alpha=\frac{5}{4} \\
A=(dst+0.5)\times\alpha \\
idx_{left}=floor(A-0.5) \\
idx_{right}=ceil(A-0.5)
\]</span></p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure1.jpeg" height="175">
</center>
<center>
fig-1 example of center alignment
</center>
<h3 id="nearest-neighbor-interpolation">Nearest Neighbor Interpolation</h3>
<h4 id="derivation">Derivation</h4>
<p>Nearest interpolation is a very simple interpolation method. For a new point of the resized figure, its value is the same with the nearest point of the original figure. The approach we find this nearest point is by using <code>round</code> operation after calculate the position of the new point in the original coordinate(multiply a factor of <span class="math inline">\(\frac{original dimension}{new dimension}\)</span>). Note that before all these operations, we need to transform the indices for center alignment.</p>
<p>For example, the following <em>fig-2</em> shows an original figure of size 2 x 2, we want to enlarge it to size 3 x 3. Assume <span class="math inline">\((x, y)\)</span> is a point of the resized figure, then its position in the original frame is <span class="math inline">\((2x/3, 2x/3)\)</span>. The result often is a float vector, then round it to integer, e.g., <span class="math inline">\((1, 2) \to (0.67, 1.33) \to (1, 1)\)</span>. Shrunk is similar with enlarging.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure2.jpeg" height="300">
</center>
<center>
fig-2 example of nearest neighbor
</center>
<h4 id="pseudo-code">Pseudo Code</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// nearest_11910206</span><br><span class="line">begin with parameters input_file, [h_new, w_new]</span><br><span class="line"></span><br><span class="line">    // get input array from filename or just array</span><br><span class="line">    error handling</span><br><span class="line">    array input_raw</span><br><span class="line"></span><br><span class="line">    // get resize factor, the \alpha mentioned above</span><br><span class="line">    float h_fac, w_fac</span><br><span class="line">    compute h_fac = h_raw / h_new</span><br><span class="line">    compute w_fac = w_raw / w_new</span><br><span class="line"></span><br><span class="line">    // get bias values for center alignment</span><br><span class="line">    array interpolated</span><br><span class="line">    bias float h_bias, w_bias</span><br><span class="line">    compute h_bias = 0.5 * h_fac - 0.5</span><br><span class="line">    compute w_bias = 0.5 * w_fac - 0.5</span><br><span class="line"></span><br><span class="line">    // two `for` loops to iterate all items in array interpolated</span><br><span class="line">    for index i</span><br><span class="line">        for index j</span><br><span class="line"></span><br><span class="line">            // get the nearest neighbor&#x27;s index [h_idx, w_idx]</span><br><span class="line">            integer h_idx, w_idx</span><br><span class="line">            compute h_idx = round(h_bias + h_fac * i)</span><br><span class="line">            compute w_idx = round(w_bias + w_fac * j)</span><br><span class="line">            update interpolated[i, j]</span><br><span class="line"></span><br><span class="line">    return interpolated</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="bilinear-interpolation">Bilinear Interpolation</h3>
<h4 id="derivation-1">Derivation</h4>
<p><strong>Using repeated linear interpolation:</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>First consider a linear interpolation example in 1-D, like the following figure. The value of f(x) can be expressed by the two neighbor points: <span class="math inline">\(f(x)=\frac{x_2-x}{x_2-x_1}f(x_1)+\frac{x-x_1}{x_2-x_1}f(x_2)\)</span>. Therefore, f(x) can be seen as a weighted average of f(x_1) and f(x_2). <strong>Significantly, the border condition of bilinear interpolation can be regarded as linear condition during implementation</strong>. Besides, <span class="math inline">\(x_2-x_1\)</span> normally equal to one in image interpolation because the operation is down pixel by pixel.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure4.jpeg" height="150">
</center>
<center>
fig-3 linear interpolation
</center>
<p>Then, extend the conclusion to 2-D. Actually, bilinear interpolation is not linear in the whole process but quadratic in the sample location <em>P</em>, it could be expressed in a bilinear polynomial form: <span class="math inline">\(f(x,y)=a_{00}+a_{10}x+a_{01}y+a_{11}xy\)</span>. The basic derivation is by repeat linear interpolation twice. As shown in the figure below, first sample along x-axis:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
f(x,y_1) &amp; =\frac{x_2-x}{x_2-x_1}f(Q_1)+\frac{x-x_1}{x_2-x_1}f(Q_2) \\
         &amp; =(x_2-x)f(Q_1)+(x-x_1)f(Q_2) \\
f(x,y_2) &amp; =\frac{x_2-x}{x_2-x_1}f(Q_3)+\frac{x-x_1}{x_2-x_1}f(Q_4) \\
         &amp; =(x_2-x)f(Q_3)+(x-x_1)f(Q_4)
\end{aligned}
\end{equation}
\]</span> Then sample along y-axis (the sequence of sampling along x and y axes can exchange), writing the equation of f(x, y) in matrix form:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
f(x,y) &amp; =\frac{y_2-y}{y_2-y_1}f(x,y_1)+\frac{y-y_1}{y_2-y_1}f(x,y_2) \\
       &amp; =\frac{y_2-y}{y_2-y_1}[(x_2-x)f(Q_1)+(x-x_1)f(Q_2)]+\frac{y-y_1}{y_2-y_1}[(x_2-x)f(Q_3)+(x-x_1)f(Q_4)] \\
       &amp; =\begin{bmatrix}
          x_2-x &amp; x-x_1
          \end{bmatrix}
          \begin{bmatrix}
          f(Q_3) &amp; f(Q_1) \\ f(Q_4) &amp; f(Q_2)
          \end{bmatrix}
          \begin{bmatrix}
          y_2-y \\ y-y_1
          \end{bmatrix}
\end{aligned}
\end{equation}
\]</span> The points lie in the margin of the <strong>enlarged</strong> figure can be dealt with separately, because it only has 3 or 1 (in the corner) neighbors. Therefore, I do linear interpolation for the points in the margin.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_figure5.jpeg" height="225">
</center>
<center>
fig-4 bilinear interpolation
</center>
<p><strong>Using Polynomial to fit:</strong></p>
<p>As mentioned above, f(x, y) could be written as a multilinear polynomial, therefore using the values of the 4 neighbor points, we can get: $$ <span class="math display">\[\begin{align}
f(x, y) &amp; \approx a_{00}+a_{10}x+a_{01}y+a_{11}xy \\
        &amp; \Rightarrow [f(Q_3) \ f(Q_1) \ f(Q_4) \ f(Q_2)]^T \\
        \\
\begin{pmatrix}
f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)
\end{pmatrix} &amp; = 
\begin{pmatrix}
1 &amp; x_1 &amp; y_1 &amp; x_1y_1 \\
1 &amp; x_1 &amp; y_2 &amp; x_1y_2 \\
1 &amp; x_2 &amp; y_1 &amp; x_2y_1 \\
1 &amp; x_2 &amp; y_2 &amp; x_2y_2 \\
\end{pmatrix}
\begin{pmatrix}
a_{00} \\ a_{10} \\ a_{01} \\ a_{11}
\end{pmatrix} \\
\\
\begin{pmatrix}
a_{00} \\ a_{10} \\ a_{01} \\ a_{11}
\end{pmatrix} &amp; = \frac{1}{(x_2-x_1)(y_2-y_1)}
\begin{pmatrix}
x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\
-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\
-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\
1 &amp; -1 &amp; -1 &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)
\end{pmatrix} \\
\\
              &amp; =
\begin{pmatrix}
x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\
-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\
-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\
1 &amp; -1 &amp; -1 &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)
\end{pmatrix} \\
\\
f(x,y) &amp; = 
\begin{pmatrix}
1 &amp; x &amp; y &amp; xy
\end{pmatrix}
\begin{pmatrix}
x_2y_2 &amp; -x_2y_1 &amp; -x_1y_2 &amp; x_1y_1 \\
-y_2 &amp; y_1 &amp; y_2 &amp; -y_1 \\
-x_2 &amp; x_2 &amp; x_1 &amp; -x_1 \\
1 &amp; -1 &amp; -1 &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
f(Q_3) \\ f(Q_1) \\ f(Q_4) \\ f(Q_2)
\end{pmatrix} \\

\end{align}\]</span> $$ <strong>Using Weighted Mean</strong></p>
<p>In another view, as mentioned we can see the interpolation as weighted average over the 4 neighbor values, therefore we can a vector <span class="math inline">\(w\)</span> to denote the weights. <span class="math display">\[
\begin{align}
f(x, y) &amp; \approx w_{1}f(Q_{1})+w_{2}f(Q_{2})+w_{3}f(Q_{3})+w_{4}f(Q_{4}) \\
        &amp; =
\begin{pmatrix}
f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)
\end{pmatrix}
\begin{pmatrix}
w_3 \\ w_1 \\ w_4 \\ w_2
\end{pmatrix}
\end{align}
\]</span> Substitute the knowledge of the former polynomial principle, we can get the following result. The weights must add up to 1 for different order of terms. Then extract the weights by do inversing, we get a new matrix form for bilinear interpolation. <span class="math display">\[
\begin{align}
\begin{pmatrix}
1 \\ x \\ y \\ xy
\end{pmatrix}
 &amp; =
\begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
x_1 &amp; x_1 &amp; x_2 &amp; x_2 \\
y_1 &amp; y_2 &amp; y_1 &amp; y_2 \\
x_1y_1 &amp; x_1y_2 &amp; x_2y_1 &amp; x_2y_2
\end{pmatrix}
\begin{pmatrix}
w_3 \\ w_1 \\ w_4 \\ w_2
\end{pmatrix} \\
\\
f(x,y) &amp; =
\begin{pmatrix}
f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)
\end{pmatrix}
\begin{pmatrix}
w_3 \\ w_1 \\ w_4 \\ w_2
\end{pmatrix} \\ 
&amp; = \frac{1}{(x_2-x_1)(y_2-y_1)}
\begin{pmatrix}
f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)
\end{pmatrix}
\begin{pmatrix}
x_2y_2 &amp; -y_2 &amp; -x_2 &amp; 1 \\
-x_2y_1 &amp; y_1 &amp; x_2 &amp; -1 \\
-x_1y_2 &amp; y_2 &amp; x_1 &amp; -1 \\
x_1y_1 &amp; -y_1 &amp; -x_1 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 \\ x \\ y \\ xy
\end{pmatrix} \\
&amp; =
\begin{pmatrix}
f(Q_3) &amp; f(Q_1) &amp; f(Q_4) &amp; f(Q_2)
\end{pmatrix}
\begin{pmatrix}
x_2y_2 &amp; -y_2 &amp; -x_2 &amp; 1 \\
-x_2y_1 &amp; y_1 &amp; x_2 &amp; -1 \\
-x_1y_2 &amp; y_2 &amp; x_1 &amp; -1 \\
x_1y_1 &amp; -y_1 &amp; -x_1 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 \\ x \\ y \\ xy
\end{pmatrix}
\end{align}
\]</span> However, it is easy to discover that this matrix form has strong similarity with the one derived from polynomial fitting. In my intuition this methods have the same time complexity with the last one, therefore I do not implement this method to codes.</p>
<h4 id="pseudo-code-1">Pseudo Code</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// bilinear_11910206</span><br><span class="line">begin with parameters input_file, [h_new, w_new]</span><br><span class="line"></span><br><span class="line">    // get input array from filename or just array</span><br><span class="line">    error handling</span><br><span class="line">    array input_raw</span><br><span class="line"></span><br><span class="line">    // get resize factor, the \alpha mentioned above</span><br><span class="line">    float h_fac, w_fac</span><br><span class="line">    compute h_fac = h_raw / h_new</span><br><span class="line">    compute w_fac = w_raw / w_new</span><br><span class="line"></span><br><span class="line">    // get bias values for center alignment</span><br><span class="line">    array interpolated</span><br><span class="line">    bias float h_bias, w_bias</span><br><span class="line">    compute h_bias = 0.5 * h_fac - 0.5</span><br><span class="line">    compute w_bias = 0.5 * w_fac - 0.5</span><br><span class="line"></span><br><span class="line">    // get the indexes that represent margins</span><br><span class="line">    integer h_max, w_max, h_margin, w_margin</span><br><span class="line">    compute h_max = h_raw - 1</span><br><span class="line">    compute w_raw = w_raw - 1</span><br><span class="line">    compute h_margin = floor(0.5 / h_fac + 0.5)</span><br><span class="line">    compute h_margin = floor(0.5 / w_fac + 0.5)</span><br><span class="line"></span><br><span class="line">    // assign values for the 4 corners</span><br><span class="line">    interpolated[left-top] = input_raw[0, 0]</span><br><span class="line">    interpolated[right-top] = input_raw[0, w_raw]</span><br><span class="line">    interpolated[left-down] = input_raw[h_max, 0]</span><br><span class="line">    interpolated[right-down] = input_raw[h_max, w_raw]</span><br><span class="line"></span><br><span class="line">    // assign values for the 4 borderline margins</span><br><span class="line">    for index j</span><br><span class="line"></span><br><span class="line">        // handle 2 horizontal borderline margins</span><br><span class="line">        float y</span><br><span class="line">        integer y1, y2</span><br><span class="line">        compute y = w_bias + w_fac * j</span><br><span class="line">        compute y1 = floor(y)</span><br><span class="line">        compute y2 = ceil(y)</span><br><span class="line"></span><br><span class="line">        // do linear intepolation in y direction</span><br><span class="line">        interpolated[left-border] = (y2 - y) * input_raw[0, y1] + (y - y1) * input_raw[0, y2]</span><br><span class="line">        interpolated[right-border] = (y2 - y) * input_raw[h_max, y1] + (y - y1) * input_raw[h_max, y2]</span><br><span class="line"></span><br><span class="line">    for index i</span><br><span class="line"></span><br><span class="line">        // handle 2 vertical borderline margins</span><br><span class="line">        float x</span><br><span class="line">        integer x1, x2</span><br><span class="line">        compute x = h_bias + h_fac * i</span><br><span class="line">        compute x1 = floor(x)</span><br><span class="line">        compute x2 = ceil(x)</span><br><span class="line"></span><br><span class="line">        // do linear intepolation in x direction</span><br><span class="line">        interpolated[up-border] = (x2 - x) * input_raw[x1, 0] + (x - x1) * input_raw[x2, 0]</span><br><span class="line">        interpolated[down-border] = (x2 - x) * input_raw[x1, w_max] + (x - x1) * input_raw[x2, x_max]</span><br><span class="line"></span><br><span class="line">    // embedded 2 `for` loops to iterate all items in the center part</span><br><span class="line">    for index i exclude margin</span><br><span class="line">        for index j exclude margin</span><br><span class="line">            float x, y</span><br><span class="line">            integer x1, y1, x2, y2</span><br><span class="line">            compute x = h_bias + h_fac * i</span><br><span class="line">            compute y = w_bias + w_fac * j</span><br><span class="line">            compute x1 = floor(x)</span><br><span class="line">            compute y1 = floor(y)</span><br><span class="line">            compute x2 = ceil(x)</span><br><span class="line">            compute y2 = ceil(y)</span><br><span class="line"></span><br><span class="line">            update interpolated[i, j]</span><br><span class="line">            compute f(x, y) // equations are given above for different methods</span><br><span class="line"></span><br><span class="line">    return interpolated</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="bicubic-interpolation">Bicubic Interpolation</h3>
<h4 id="derivation-2">Derivation</h4>
<p>According to the paper in IEEE, I learn this convolution method for bicubic interpolation (there are other approaches).<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> The strategy is like the polynomial and weight method of bilinear interpolation, but this time we have 16 coefficients rather than 4. The general function is: <span class="math display">\[
\sum^{3}_{i=0}\sum^{3}_{j=0}a_{ij}x^iy^j
\]</span> The crucial objective is to solve the <span class="math inline">\(a_{ij}\)</span> coefficients. The paper introduces a BiCubic function: <span class="math display">\[
\begin{align}
W(x) &amp; =\left\{
\begin{aligned}
&amp; (a+2)|x|^3-(a+3)|x|^2 +1 &amp;     &amp; {for \ |x|\leqslant1} \\
&amp; a|x|^3-5a|x|^2+8a|x|-4a &amp;     &amp; {for \ 1&lt;|x|&lt;2} \\
&amp; 0 &amp;     &amp; {otherwise} 
\end{aligned}
\right. \\
a &amp; = -0.5 \ or \ -0.75
\end{align}
\]</span> Let <span class="math inline">\(0&lt;x&lt;1\)</span>, therefore <span class="math inline">\(1&lt;x+1&lt;2\)</span>, <span class="math inline">\(-1&lt;x-1&lt;0\)</span>, <span class="math inline">\(-2&lt;x-2&lt;-1\)</span>, then we substitute to the 4 conditions to <span class="math inline">\(W(x)\)</span>, we could get corresponding equations. Substitute to the <span class="math inline">\(x_1\to x_4\)</span>, and <span class="math inline">\(y_1\to y_4\)</span> we get two 1 x 4 vectors <span class="math inline">\(\{w_x, w_y\}\)</span>. The final result could be: <span class="math display">\[
\begin{align}
f(x,y)=
\begin{pmatrix}
w_{x1} &amp; w_{x2} &amp; w_{x3} &amp; w_{x4}
\end{pmatrix}
\begin{pmatrix}
Q_{11} &amp; Q_{12} &amp; Q_{13} &amp; Q_{14} \\
Q_{21} &amp; Q_{22} &amp; Q_{23} &amp; Q_{24} \\
Q_{31} &amp; Q_{32} &amp; Q_{33} &amp; Q_{34} \\
Q_{41} &amp; Q_{42} &amp; Q_{43} &amp; Q_{44} \\
\end{pmatrix}
\begin{pmatrix}
w_{y1} \\ w_{y2} \\ w_{y3} \\ w_{y4}
\end{pmatrix}
\end{align}
\]</span> Because of time limit, I am still debugging this algorithm..., therefore I use <code>scipy</code> to accomplish it.</p>
<h4 id="pseudo-code-2">Pseudo Code</h4>
<p>I implement this by using <code>scipy</code>, according to the reference.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<h2 id="analysis">Analysis</h2>
<p>Here I import some 3rd-party libraries permitted by teacher, and the <code>xxx_11910206</code> files are solutions of this homework:</p>
<ol type="1">
<li><code>cv2</code>: the python-OpenCV package, used for reading images and comparison</li>
<li><code>numpy</code>: high efficiency calculating tool, written by C/C++ (using CPU)</li>
<li><code>matplotlib</code>: built-in image processing package, used for showing visualization of results</li>
<li><code>xxx_11910206</code>: self implemented algorithms</li>
<li><code>scipy</code>: contains many scientific math algorithms, like interpolation</li>
</ol>
<p>I use two other <code>ndarray test</code> and <code>ndarray test_3</code> for testing my algorithms, the reasons are listed below. Then I set <code>np.random.seed(0)</code> in order to control the result of random generated tests. The "seed" would help to make the results of my <code>ipynb</code> file repeatable:</p>
<ol type="1">
<li>The size of the given image is a square, but my codes support rectangular input, therefore I would like to use a new test for showing the generalization capability. Besides, I want to show that my algorithms can handle RGB images as well.</li>
<li>The pixel image could better depict the difference of different algorithms, it could be helpful for analyzing. The change in visualization is much more obvious. However, I will still use the given figure for time complexity testing.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> nearest_11910206 <span class="keyword">import</span> nearest_11910206</span><br><span class="line"><span class="keyword">from</span> bilinear_11910206 <span class="keyword">import</span> bilinear_11910206</span><br><span class="line"><span class="keyword">from</span> bicubic_11910206 <span class="keyword">import</span> bicubic_11910206</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)  <span class="comment"># repeatable</span></span><br><span class="line">test = np.uint8(np.random.randint(<span class="number">0</span>, <span class="number">255</span>, size=(<span class="number">5</span>, <span class="number">7</span>)))</span><br><span class="line">test_3 = np.uint8(np.random.randint(<span class="number">0</span>,<span class="number">255</span>,size=(<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>)))</span><br><span class="line">raw_gray = cv2.cvtColor(cv2.imread(<span class="string">&#x27;rice.tif&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_3_0.png" alt="png"  />
</center>
<p>​</p>
<h3 id="brief-results">Brief Results</h3>
<p>Here is all the results that required of this homework.</p>
<p><strong>Nearest Neighbor Interpolation</strong>: According to analysis and the efficiency test in the last part, this is the fastest algorithms. The pay-off is that it would occur discontinuity and obvious serration.</p>
<p><strong>Bilinear Interpolation</strong>: It is more complex than Nearest Neighbor, but it do not have serration for the result gray image. Basically, the result is smooth and continuous, but this method would filter some high-frequency component, thus the image might be a little faintness.</p>
<p><strong>Bicubic Interpolation</strong>: The time complexity is the greatest, but the interpolation effect is the best. It is important to choose a proper weight policy, exactly choosing an appropriate kernel. The kernel value is usually set to -0.5 or -0.75 (OpenCV set as -0.75).</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_6_0.png" alt="png" style="zoom:80%;" />
</center>
<h3 id="nearest-neighbor-interpolation-1">Nearest Neighbor Interpolation</h3>
<p>Comparing the result of OpenCV with self-implemented, they are the same when enlarging. Besides, the result shows that I can apply different resized factors in x and y axes.</p>
<p>During enlarging the figure, nearest neighbor algorithm cannot interpolate smoothly among the original pixels, the boundaries of color blocks is significantly clear.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_8_0.png" alt="png"  />
</center>
<p>The results of OpenCV and self-implemented algorithms differ when operating shrunk, I look through the code of OpenCV and find that it uses <code>cvFloor</code> , which cutoff the integer part of a float number while I use <code>round</code> to get the neighbors, thus the down-sample result of OpenCV would lean to the left and top sides while mine is center aligned. The comparison of pixel values are also provided below:</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_9_0.png" alt="png"  />
</center>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Raw:</span></span><br><span class="line"> [[<span class="number">172</span>  <span class="number">47</span> <span class="number">117</span> <span class="number">192</span>  <span class="number">67</span> <span class="number">251</span> <span class="number">195</span>]</span><br><span class="line"> [<span class="number">103</span>   <span class="number">9</span> <span class="number">211</span>  <span class="number">21</span> <span class="number">242</span>  <span class="number">36</span>  <span class="number">87</span>]</span><br><span class="line"> [ <span class="number">70</span> <span class="number">216</span>  <span class="number">88</span> <span class="number">140</span>  <span class="number">58</span> <span class="number">193</span> <span class="number">230</span>]</span><br><span class="line"> [ <span class="number">39</span>  <span class="number">87</span> <span class="number">174</span>  <span class="number">88</span>  <span class="number">81</span> <span class="number">165</span>  <span class="number">25</span>]</span><br><span class="line"> [ <span class="number">77</span>  <span class="number">72</span>   <span class="number">9</span> <span class="number">148</span> <span class="number">115</span> <span class="number">208</span> <span class="number">243</span>]]</span><br><span class="line"><span class="attr">OpenCV:</span></span><br><span class="line"> [[<span class="number">172</span> <span class="number">117</span>  <span class="number">67</span>]</span><br><span class="line"> [ <span class="number">70</span>  <span class="number">88</span>  <span class="number">58</span>]]</span><br><span class="line"><span class="attr">Mine:</span></span><br><span class="line"> [[  <span class="number">9</span>  <span class="number">21</span>  <span class="number">36</span>]</span><br><span class="line"> [ <span class="number">87</span>  <span class="number">88</span> <span class="number">165</span>]]</span><br></pre></td></tr></table></figure>
<p>I extend my codes for RGB images, actually, this is nearly the same as operating gray images, what's new is to do interpolation separately in 3 color channels. I use the following code to judge what shape of array should be returned: <code>interpolated = np.zeros(dim, dtype=int) if input_raw.ndim == 2 else np.zeros((dim[0], dim[1], 3), dtype=int)</code>. When updating the returned array <code>interpolated</code>, use the convenient numpy operator <code>:</code> (numpy is much more efficient than raw python codes), the RGB channels could be calculated within one line of code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> input_raw.ndim == <span class="number">2</span>:</span><br><span class="line">    interpolated[i, j] = input_raw[r_idx, c_idx] <span class="comment"># calculate gray figure</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    interpolated[i, j, :] = input_raw[r_idx, c_idx, :] <span class="comment"># calculate RGB figure</span></span><br></pre></td></tr></table></figure>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_11_0.png" alt="png"  />
</center>
<h3 id="bilinear-interpolation-1">Bilinear Interpolation</h3>
<p>Below is to sample the "Random Raw" to 100 x 100, the result is similar with OpenCV. The figure with title "Self-linear2" uses repeated linear interpolation, and the one with "Self-polyfit" uses polynomial fit.</p>
<p>It also supports RGB figures just like <code>nearest_11910206</code> does. From the results, we could see that bilinear interpolation has better effect than nearest neighbor, it could compensate some transitional values between the original color blocks.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_13_0.png" alt="png"  />
</center>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/interpolation_11910206_14_0.png" alt="png" style="zoom:100%;" />
</center>
<p>From the figure above with title "Inverse-Shrunk", it is down-sampled back to 5 x 5 from the image up-sampled to 100 x 100. It reveal that the bilinear process dramatically could be inverse! From wiki, I get the following proof for Inverse computation under special condition (if the point is inside any convex quadrilateral, which means 4-border-polygons that are convex, the "unit square coordinates" could be found).<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>The <span class="math inline">\(\{a, b, c, d\}\)</span> could be seen as weights of current interpolation, the unit square are parameterized by <span class="math inline">\(\{\lambda,\mu\}\in[0, 1]\)</span> . The target is to solve these two parameters. <span class="math display">\[
\begin{align}
&amp; a + b\lambda+c\mu+d\lambda\mu=0 \\
\\
&amp; a = x_{00} - x \\
&amp; b = x_{10} - x_{00} \\
&amp; c = x_{01} - x_{00} \\
&amp; d = x_{11} - x_{01} - x_{10} + x_{00} \\
\end{align}
\]</span> Take 2-d cross product of the system, reveals that: <span class="math display">\[
\begin{align}
&amp; (a+b\lambda+c\mu)\times d &amp; = 0 \\
&amp; (a+b\lambda)\times (c+d\mu) &amp; = 0 \\
&amp; (a+c\mu)\times (b+d\mu) &amp; = 0 \\
&amp; \Rightarrow \\
&amp; C+E\lambda+F\mu &amp; = 0 \\
&amp; B+(C+D)\lambda +E\lambda^2 &amp; = 0 \\
&amp; A+(C-D)\mu+F\mu^2 &amp; = 0 \\
\\
&amp; with \\
&amp; A=a\times b \quad B=a\times c \quad C=a\times d \\
&amp; D=b\times c \quad E=b\times d \quad F=c\times d
\end{align}
\]</span> Use quadratic formula to solve the equations, we get: <span class="math display">\[
\mathbb{D}=(C+D)^2-4EB=(C-D)^2-4FA \\
\Rightarrow \quad \lambda=\frac{-C-D\pm \sqrt{\mathbb{D}}}{2E} \quad \mu=\frac{-C+D\pm \sqrt{\mathbb{D}}}{2F}
\]</span> This might explain the dramatic inverse property I found, actually I not sure I totally understand it...</p>
<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>
<h4 id="enlarge">Enlarge</h4>
<p>I use the built-in <code>time</code> package in python to record running time in float seconds, and then use <code>matplotlib</code> to plot them, here shows the results. The time complexity of bilinear interpolation and nearest neighbor interpolation are both <span class="math inline">\(O(N^2)\)</span>, due to the embedded two for loops. Apparently, bilinear cost more time than nearest neighbor, because it does more calculation in the for loops, which also means that bilinear interpolation has larger coefficient for the 2nd-order term.</p>
<p>Compare the two bilinear methods, it turns out that when interpolated size is under 800 they hardly have difference. Therefore, it is reasonable to guess that using repeated linear interpolation and polynomial fitting occupy similar calculation.</p>
<p>OpenCV test is weird, I guess it might have down different optimization strategies for these 3 methods. By the way, when interpolated size is larger than 3000, the time cost of nearest neighbor method would increase horribly.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/buffer_time_result_2.png" alt="png" style="zoom:100%;" />
</center>
<h4 id="shrunk">Shrunk</h4>
<p>The shrunk result is similar with enlarge, a interesting fact is that shrunk cost much less time than enlarge. This means that the limitation and challenge of interpolation problem is up-sample rather than down-sample. For example, recovering image and super-resolution task might be relevant to this, I guess.</p>
<p>The OpenCV result is still strange, might relate to its bottom optimization or it use other methods instead.</p>
<center>
<img src="https://cdn.jsdelivr.net/gh/Judera9/Pictures-for-Blogs@main//img/2022/DIP/buffer_time_result_3.png" alt="png" style="zoom:100%;" />
</center>
<h2 id="reference">Reference</h2>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Bilinear_interpolation. https://en.wikipedia.org/wiki/Bilinear_interpolation.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Cubic convolution interpolation for digital image processing<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>scipy.interpolate.interp2d. https://bbs.huaweicloud.com/blogs/329665.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Bilinear_interpolation. https://en.wikipedia.org/wiki/Bilinear_interpolation.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://judera9.github.io">Jude</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://judera9.github.io/2022/03/04/2022-3-4-Image-Interpolation/">https://judera9.github.io/2022/03/04/2022-3-4-Image-Interpolation/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://judera9.github.io" target="_blank">Jude's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DIP/">DIP</a><a class="post-meta__tags" href="/tags/NumPy/">NumPy</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/">图像插值</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/16/2022-3-16-Connection-refused-error-for-proxy/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">解决proxy导致的Connection refused</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/20/2022-2-20-Origin-and-Develop-of-Male-Gaze/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">讨论当代大学生日益尖锐的性别对立</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/12/2022-06-12-Frequency-Domain-Filtering/" title="频率域滤波"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">频率域滤波</div></div></a></div><div><a href="/2022/03/16/2022-3-16-Image-Spatial-Operations-and-Filtering/" title="Image Spatial Operations and Filtering"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-16</div><div class="title">Image Spatial Operations and Filtering</div></div></a></div><div><a href="/2022/03/27/2022-3-27-Intensity-Transform-and-Spatial-Filtering/" title="灰度变换与空间滤波"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">灰度变换与空间滤波</div></div></a></div><div><a href="/2022/06/12/2022-06-12-Lena-the-CV-girl/" title="CV和DIP处理常见的那个女孩到底是谁"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">CV和DIP处理常见的那个女孩到底是谁</div></div></a></div><div><a href="/2022/06/12/2022-06-12-FFT-description-and-code/" title="一维快速傅里叶变换"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">一维快速傅里叶变换</div></div></a></div><div><a href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-13</div><div class="title">光流估计目标追踪-简单的KLT Feature Tracker</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jude</div><div class="author-info__description">Record anything interesting!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#image-interpolation"><span class="toc-number">1.</span> <span class="toc-text">Image Interpolation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#objectives"><span class="toc-number">1.1.</span> <span class="toc-text">Objectives</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#principle"><span class="toc-number">1.2.</span> <span class="toc-text">Principle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#geometric-center-alignment"><span class="toc-number">1.2.1.</span> <span class="toc-text">Geometric Center Alignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nearest-neighbor-interpolation"><span class="toc-number">1.2.2.</span> <span class="toc-text">Nearest Neighbor Interpolation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#derivation"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Pseudo Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bilinear-interpolation"><span class="toc-number">1.2.3.</span> <span class="toc-text">Bilinear Interpolation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#derivation-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Pseudo Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bicubic-interpolation"><span class="toc-number">1.2.4.</span> <span class="toc-text">Bicubic Interpolation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#derivation-2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pseudo-code-2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Pseudo Code</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#analysis"><span class="toc-number">1.3.</span> <span class="toc-text">Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#brief-results"><span class="toc-number">1.3.1.</span> <span class="toc-text">Brief Results</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nearest-neighbor-interpolation-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">Nearest Neighbor Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bilinear-interpolation-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">Bilinear Interpolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-complexity-analysis"><span class="toc-number">1.3.4.</span> <span class="toc-text">Time Complexity Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enlarge"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Enlarge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shrunk"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">Shrunk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">1.4.</span> <span class="toc-text">Reference</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/Review-of-fourier-transform/" title="Review of fourier transform"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Review of fourier transform"/></a><div class="content"><a class="title" href="/2022/07/21/Review-of-fourier-transform/" title="Review of fourier transform">Review of fourier transform</a><time datetime="2022-07-21T14:28:37.000Z" title="发表于 2022-07-21 22:28:37">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/20/Introduction-to-Hexo-pdf-and-music-plugins/" title="Introduction to Hexo pdf and music plugins"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to Hexo pdf and music plugins"/></a><div class="content"><a class="title" href="/2022/07/20/Introduction-to-Hexo-pdf-and-music-plugins/" title="Introduction to Hexo pdf and music plugins">Introduction to Hexo pdf and music plugins</a><time datetime="2022-07-19T17:04:21.000Z" title="发表于 2022-07-20 01:04:21">2022-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/20/2022-07-20-Introduction-to-chrono/" title="Introduction to chrono"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Introduction to chrono"/></a><div class="content"><a class="title" href="/2022/07/20/2022-07-20-Introduction-to-chrono/" title="Introduction to chrono">Introduction to chrono</a><time datetime="2022-07-19T16:30:08.000Z" title="发表于 2022-07-20 00:30:08">2022-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/19/2022-07-19-The-usage-of-round-in-design/" title="The usage of round in design"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The usage of round in design"/></a><div class="content"><a class="title" href="/2022/07/19/2022-07-19-The-usage-of-round-in-design/" title="The usage of round in design">The usage of round in design</a><time datetime="2022-07-19T15:49:21.000Z" title="发表于 2022-07-19 23:49:21">2022-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="光流估计目标追踪-简单的KLT Feature Tracker"/></a><div class="content"><a class="title" href="/2022/06/13/2022-06-13-KLT-naive-version/" title="光流估计目标追踪-简单的KLT Feature Tracker">光流估计目标追踪-简单的KLT Feature Tracker</a><time datetime="2022-06-13T15:36:22.000Z" title="发表于 2022-06-13 23:36:22">2022-06-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jude</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>